//a side-by-side reference sheet//

[#grammar-invocation grammar and invocation] | [#var-expr variables and expressions] | [#arithmetic-logic arithmetic and logic] | [#strings strings] | [#arrays arrays] | [#sets sets] | [#arith-seq arithmetic sequences] | [#dictionaries dictionaries] | [#functions functions] | [#execution-control execution control] | [#exceptions exceptions] | [#streams streams] | [#files files] | [#directories directories] | [#libraries-namespaces libraries and namespaces] |  [#reflection reflection]
 
[#symbolic-expr symbolic expressions] | [#calculus calculus] | [#equations-unknowns equations and unknowns] | [#optimization optimization] | [#vectors vectors] | [#matrices matrices] | [#combinatorics combinatorics] | [#number-theory number theory] |  [#polynomials polynomials] | [#trigonometry trigonometry] | [#special-functions special functions] | [#permutations permutations] |  [#descriptive-statistics descriptive statistics] | [#distributions distributions] | [#statistical-tests statistical tests]

[#bar-charts bar charts] | [#scatter-plots scatter plots] | [#line-charts line charts] | [#surface-charts surface charts] | [#chart-options chart options]

||~ ||~ [#mathematica mathematica]||~ [#maple maple]||~ [#maxima maxima]||~ [#sage sage]||~ [#sympy sympy]||
||[[# version-used]][#version-used-note version used] _
@<&nbsp;>@||##gray|//10.0//##||##gray|//2016//##||##gray|//5.37//##||##gray|//6.10//##||##gray|//Python 2.7; SymPy 0.7//##||
||[[# show-version]][#show-version-note show version] _
@<&nbsp;>@||##gray|//select// About Mathematica //in// Mathematica //menu//##||##gray|//select// About Maple //in// Maple //menu//##||$ maxima @@--@@version||$ sage @@--@@version _
 _
##gray|//also displayed on worksheet//##||@@sympy.__version__@@||
||[[# implicit-prologue]][#implicit-prologue-note implicit prologue]|| || || ||##gray|# unknowns other than x must be declared:## _
y = var('y')||from sympy import * _
 _
##gray|# enable LaTeX rendering in Jupyter notebook:## _
init_printing() _
 _
##gray|# unknown variables must be declared:## _
x, y = symbols('x y')||
||||||||||||~ [[# grammar-invocation]][#grammar-invocation-note grammar and invocation]||
||~ ||~ mathematica||~ maple||~ maxima||~ sage||~ sympy||
||[[# interpreter]][#interpreter-note interpreter] _
@<&nbsp;>@||$ cat @@>@@ hello.m _
Print["Hello, World!"] _
 _
$  MathKernel -script hello.m|| ||$ cat @@>>@@ hello.max _
print("Hello, world!"); _
 _
$ maxima -b hello.maxima||$ cat > hello.sage _
print("Hello, World!") _
 _
$ sage hello.sage||##gray|//if// foo.py //imports sympy://## _
$ python ##gray|//foo//##.py||
||[[# repl]][#repl-note repl] _
@<&nbsp;>@||$ MathKernel||$ maple||$ maxima||$ sage||$ python _
@@>>>@@ from sympy import *||
||[[# block-delimiters]][#block-delimiters-note block delimiters] _
@<&nbsp;>@||( ##gray|//stmt//##; ##gray|//...//##)|| ||block([x: 3, y: 4], x + y); _
 _
##gray|/* Multiple stmts are separated by commas; a list of assignments can be used to set variables local to the block. */##||: ##gray|//and offside rule//##||: ##gray|//and offside rule//##||
||[[# stmt-separator]][#stmt-separator-note statement separator]||; ##gray|//or sometimes newline//## _
 _
##gray|//A semicolon suppresses echoing value of previous expression.//##||; ##gray|//or//## : _
 _
##gray|//The colon// : //suppresses output.//## _
 _
##gray|//In the worksheet, typing// RETURN //causes a cell to be evaluated.  The expression in the cell does not have to end with a semicolon.  To enter a newline in a cell, use// SHIFT + RETURN. _
 _
//In the command line REPL, a statement is terminated by a semicolon.//##||; ##gray|//or//## $ _
 _
##gray|//The dollar sign// $ //suppresses output.//##||##gray|//newline or//## ; _
 _
##gray|//newlines not separators inside (), [], {}, triple quote literals, or after backslash: @@\@@//##||##gray|//newline or//## ; _
 _
##gray|//newlines not separators inside (), [], {}, triple quote literals, or after backslash: @@\@@//##||
||[[# eol-comment]][#eol-comment-note end-of-line comment] _
@<&nbsp;>@||##gray|//none//##||1 + 1; ##gray|# addition##||##gray|//none//##||1 + 1 ##gray|# addition##||1 + 1 ##gray|# addition##||
||[[# multiple-line-comment]][#multiple-line-comment-note multiple line comment] _
@<&nbsp;>@||1 + ##gray|(* addition *)## 1||1 + ##gray|(* addition *)## 1;||1 + ##gray|/* addition */## 1;||##gray|//none//##||##gray|//none//##||
||||||||||||~ [[# var-expr]][#var-expr-note variables and expressions]||
||~ ||~ mathematica||~ maple||~ maxima||~ sage||~ sympy||
||[[# assignment]][#assignment-note assignment]||a = 3 _
Set[a, 3] _
 _
##gray|(* rhs evaluated each time a is accessed: *)## _
a := x + 3 _
SetDelayed[a, x + 3]||a := 3; _
 _
##gray|# rhs evaluated each time a is accessed:## _
a := 'x + 3';||a: 3;||a = 3||a = 3||
||[[# parallel-assignment]][#parallel-assignment-note parallel assignment]||{a, b} = {3, 4} _
Set[{a, b}, {3, 4}]||a, b := 3, 4;||[a, b]: [3, 4]||a, b = 3, 4||a, b = 3, 4||
||[[# compound-assignment]][#compound-assignment-note compound assignment]||+= -= *= /= _
##gray|//corresponding functions://## _
AddTo SubtractFrom TimeBy DivideBy||##gray|//none//##||##gray|//none//##||+= -= *= /= @@//=@@ %= @@**=@@||+= -= *= /= @@//=@@ %= ^= @@**=@@||
||[[# incr-decr]][#incr-decr-note increment and decrement]||++x @@--@@x _
PreIncrement[x] PreDecrement[x] _
x++ x@@--@@ _
Increment[x] Decrement[x]||##gray|//none//##||##gray|//none//##||##gray|//none//##||##gray|//none//##||
||[[# non-referential-id]][#non-referential-id-note non-referential identifier]||##gray|//any unassigned identifier is non-referential//##||##gray|//any unassigned identifier is non-referential//##||##gray|//any unassigned identifier is non-referential//##||y, z, w = var('y z w') _
 _
##gray|# x is non-referential unless assigned a value##||x, y, z, w = symbols('x y z w')||
||[[# id-as-val]][#id-as-val-note identifier as value]||x = 3 _
y = HoldForm[x]|| ||x: 3; _
y: 'x;|| || ||
||[[# global-var]][#global-var-note global variable]||##gray|//variables are global by default//##|| ||##gray|//variables are global by default//##||g1, g2 = 7, 8 _
 _
def swap_globals(): _
@<&nbsp;&nbsp;>@global g1, g2 _
@<&nbsp;&nbsp;>@g1, g2 = g2, g1||g1, g2 = 7, 8 _
 _
def swap_globals(): _
@<&nbsp;&nbsp;>@global g1, g2 _
@<&nbsp;&nbsp;>@g1, g2 = g2, g1||
||[[# local-var]][#local-var-note local variable]||Module[{x = 3, y = 4}, Print[x + y]] _
 _
##gray|(* makes x and y read-only: *)## _
With[{x = 3, y = 4}, Print[x + y]] _
 _
##gray|(* Block[ ] declares dynamic scope *)##|| ||block([x: 3, y: 4], print(x + y));||##gray|//assignments inside functions are to local variables by default//##||##gray|//assignments inside functions are to local variables by default//##||
||[[# null]][#null-note null] _
@<&nbsp;>@||Null|| ||##gray|//no null value//##||None||None||
||[[# null-test]][#null-test-note null test] _
@<&nbsp;>@||x == Null|| ||##gray|//no null value//##||x is None||x is None||
||[[# undef-var]][#undef-var-note undefined variable access] _
@<&nbsp;>@||##gray|//treated as an unknown number//##||##gray|//treated as an unknown number//##||##gray|//treated as an unknown number//##||##gray|//raises// NameError##||##gray|//raises// NameError##||
||[[# rm-var-binding]][#rm-var-binding-note remove variable binding]||Clear[x] _
Remove[x]||x := 'x'||kill(x);||del x||del x||
||[[# cond-expr]][#cond-expr-note conditional expression] _
@<&nbsp;>@||If[x > 0, x, -x]||if x < 0 then -x else x end if;||if x < 0 then -x else x;||x if x > 0 else -x||x if x > 0 else -x||
||||||||||||~ [[# arithmetic-logic]][#arithmetic-logic-note arithmetic and logic]||
||~ ||~ mathematica||~ maple||~ maxima||~ sage||~ sympy||
||[[# true-false]][#true-false-note true and false] _
@<&nbsp;>@||True False||true false||true false||True False||True False||
||[[# falsehoods]][#falsehoods-note falsehoods] _
@<&nbsp;>@||False|| || ||False None 0 0.0 '' [] {}||False 0 0.0||
||[[# logical-op]][#logical-op-note logical operators]||! True @@||@@ (True && False) _
Or[Not[True], And[True, False]]||and or not||and or not|| ||Or(Not(True), And(True, False)) _
 _
##gray|# when arguments are symbols:## _
@@~ x | (y & z)@@||
||[[# relational-expr]][#relational-expr-note relational expression]||1 < 2||evalb(1 < 2);||is(1 < 2);|| || ||
||[[# relational-op]][#relational-op-note relational operators]||== != > < >= <= _
##gray|//corresponding functions://## _
Equal Unequal Greater Less GreaterEqual LessEqual||@@=@@ != > < >= <=||@@=@@ # > < >= <=||== != > < >= <=||Eq Ne Gt Lt Ge Le _
 _
##gray|# when arguments are symbols:## _
== != > < >= <=||
||[[# arith-op]][#arith-op-note arithmetic operators]||+ - * / Quotient Mod _
##gray|//adjacent terms are multiplied, so * is not necessary.// Quotient //and// Mod //are functions, not binary infix operators.  These functions are also available://## _
Plus Subtract Times Divide||+ - * / iquo mod _
 _
##gray|iquo //and// mod //are functions//##||+ - * / quotitent() mod() _
 _
##gray|quotient //and// mod //are functions, not binary infix operators.//##||+ - * / @@//@@ %||+ - * / ##gray|//??//## % _
 _
##gray|//if an expression contains a symbol, then the above operators are rewritten using the following classes://## _
Add Mul Pow Mod||
||[[# int-div]][#int-div-note integer division] _
@<&nbsp;>@||Quotient[a, b]||iquo(7, 3);||quotient(7, 3);||7 @@//@@ 3|| ||
||[[# int-div-zero]][#int-div-zero-note integer division by zero]||##gray|//dividend is zero://## _
Indeterminate _
##gray|//otherwise://## _
ComplexInfinity||##gray|//error, numeric exception//##||##gray|//error//##||##gray|//raises// ZeroDivisionError##|| ||
||[[# float-div]][#float-div-note float division]||##gray|//exact division://## _
a / b||##gray|# exact division:## _
a / b; _
 _
##gray|# float division:## _
a * 1.0 / b;||a / b|| || ||
||[[# float-div-zero]][#float-div-zero-note float division by zero]||##gray|//dividend is zero://## _
Indeterminate _
##gray|//otherwise://## _
ComplexInfinity||float(infinity) _
float(undefined) _
-float(infinity)||##gray|//error//##|| || ||
||[[# power]][#power-note power]||2 ^ 32 _
Power[2, 32]||2 ^ 32 _
 _
##gray|//The worksheet rewrites the expression using a superscript.  Do not put spaces around the operator.//##||2 ^ 32; _
2 @@**@@ 32;||2 ^ 32 _
2 @@**@@ 32||2 @@**@@ 32 _
Pow(2, 32)||
||[[# sqrt]][#sqrt-note sqrt]||##gray|//returns symbolic expression://## _
Sqrt[2]||sqrt(2)||sqrt(2);||sqrt(2)||sqrt(2)||
||[[# sqrt-negative-one]][#sqrt-negative-one-note sqrt -1] _
@<&nbsp;>@||I||I||%i||I||I||
||[[# transcendental-func]][#transcendental-func-note transcendental functions]||Exp Log _
Sin Cos Tan _
ArcSin ArcCos ArcTan _
ArcTan _
##gray|ArcTan //accepts 1 or 2 arguments//##||exp log _
sin cos tan _
arcsin arccos _
arctan(##gray|//y//##, ##gray|//x//##)||exp log _
sin cos tan _
asin acos atan _
atan2||exp log _
sin cos tan _
asin acos atan _
atan2||exp log _
sin cos tan _
asin acos atan _
atan2||
||[[# transcendental-const]][#transcendental-const-note transcendental constants] _
##gray|//Ï€ and Euler's number//##||Pi E EulerGamma||Pi exp(1) gamma||%pi %e %gamma||pi e euler_gamma||pi E||
||[[# float-truncation]][#float-truncation-note float truncation] _
##gray|//round towards zero, round to nearest integer, round down, round up//##||IntegerPart Round Floor Ceiling||trunc round floor ceil||truncate _
round _
floor _
ceiling||int _
round _
floor _
ceil||floor _
ceiling||
||[[# absolute-val]][#absolute-val-note absolute value] _
##gray|//and signum//##||Abs Sign||abs sign||abs sign _
 _
##gray|sign //returns// pos, neg, //or// zero##||abs sign||Abs sign||
||[[# int-overflow]][#int-overflow-note integer overflow] _
@<&nbsp;>@||##gray|//none, has arbitrary length integer type//##||##gray|//none, has arbitrary length integer type//##||##gray|//none, has arbitrary length integer type//##||##gray|//none, has arbitrary length integer type//##||##gray|//none, has arbitrary length integer type//##||
||[[# float-overflow]][#float-overflow-note float overflow] _
@<&nbsp;>@||##gray|//none//##|| ||##gray|//none//##|| || ||
||[[# rational-construction]][#rational-construction-note rational construction]||2 / 7||2 / 7||2 / 7||2 / 7||Mul(2, Pow(7, -1)) _
Rational(2, 7)||
||[[# rational-decomposition]][#rational-decomposition-note rational decomposition] _
@<&nbsp;>@||Numerator[2 / 7] _
Denominator[2 / 7]||numer(2 / 7) _
denom(2 / 7)||num(2 / 7); _
denom(2 / 7);||numerator(2 / 7) _
denominator(2 / 7)||numer, denom = fraction(Rational(2, 7))||
||[[# decimal-approx]][#decimal-approx-note decimal approximation]||N[2 / 7] _
2 / 7 + 0. _
2 / 7 @@//@@ N _
N[2 / 7, 100]||evalf(2 / 7) _
2 / 7 + 0.0 _
evalf[100](2 / 7) _
 _
##gray|# use hardware floats:## _
evalhf(2 / 7);||2 / 7, numer;||n(2 / 7) _
n(2 / 7, 100) _
 _
##gray|# synonyms for n:## _
N(2 / 7) _
numerical_approx(2 / 7)||N(Rational(2, 7)) _
N(Rational(2, 7), 100)||
||[[# complex-construction]][#complex-construction-note complex construction] _
@<&nbsp;>@||1 + 3I||1 + 3I||1 + 3 * %i;||1 + 3 * I||1 + 3 * I||
||[[# complex-decomposition]][#complex-decomposition-note complex decomposition] _
##gray|//real and imaginary part, argument and modulus, conjugate//##||Re Im _
Arg Abs _
Conjugate||Re Im _
argument abs _
conjugate||realpart imagpart _
cabs carg _
conjugate||(3 + I).real() _
(3 + I).imag() _
abs(3 + I) _
arg(3 + I) _
(3 + I).conjugate()||re im _
Abs arg _
conjugate||
||[[# random-num]][#random-num-note random number] _
##gray|//uniform integer, uniform float//##||RandomInteger[{0, 99}] _
RandomReal[]||rgen := rand(0..99); _
rgen(); _
 _
rgen := rand(0.0 .. 1.0); _
rgen();||random(100); _
random(1.0);|| || ||
||[[# random-seed]][#random-seed-note random seed] _
##gray|//set, get//##||SeedRandom[17] _
##gray|//??//##|| ||set_random_state(make_random_state(17)); _
##gray|//??//##|| || ||
||[[# bit-op]][#bit-op-note bit operators]||BitAnd[5, 1] _
BitOr[5, 1] _
BitXor[5, 1] _
BitNot[5] _
BitShiftLeft[5, 1] _
BitShiftRight[5, 1]||with(Bits): _
 _
And(5, 1) _
Or(5, 1) _
Xor(5, 1) _
Not(1, bits=32) _
Join([0, op(Split(5))]) _
Join(subsop(1 = NULL, Split(5)))||##gray|//none//##|| || ||
||[[# binary-octal-hex-literals]][#binary-octal-hex-literals-note binary, octal, and hex literals]||2@@^^@@101010 _
8@@^^@@52 _
16@@^^@@2a|| ||ibase: 2; _
101010; _
 _
ibase: 8; _
52; _
 _
##gray|/* If first hex digit is a letter, prefix a zero: */## _
ibase: 16; _
2a;|| || ||
||[[# radix]][#radix-note radix]||BaseForm[42, 7] _
BaseForm[7^^60, 10]||##gray|# [0, 6]:## _
convert(42, base, 7)||obase: 7; _
42;|| || ||
||[[# to-array-of-digits]][#to-array-of-digits-note to array of digits]||##gray|(* base 10: *)## _
IntegerDigits[1234] _
##gray|(* base 2: *)## _
IntegerDigits[1234, 2]||convert(1234, base, 10) _
convert(1234, base, 2)|| || || ||
||||||||||||~ [[# strings]][#strings-note strings]||
||~ ||~ mathematica||~ maple||~ maxima||~ sage||~ sympy||
||[[# str-literal]][#str-literal-note string literal] _
@<&nbsp;>@||"don't say \"no\""||"don't say \"no\""||"don't say \"no\""||##gray|//use//## [[[scripting#strings|Python strings]]]||##gray|//use//## [[[scripting#strings|Python strings]]]||
||[[# newline-in-str-literal]][#newline-in-str-literal-note newline in literal] _
@<&nbsp;>@||##gray|//yes//##||##gray|//Yes.  String literals separated only by spaces or linebreaks are merged into a single literal.//##||##gray|//Newlines are inserted into strings by continuing the string on the next line.  However, if the last character on a line inside a string is a backslash, the backslash and the following newline are omitted.//##|| || ||
||[[# str-literal-esc]][#str-literal-esc-note literal escapes]||\\ \" \b \f \n \r \t \##gray|//ooo//##|| ||\" \\|| || ||
||[[# str-concat]][#str-concat-note concatenate] _
@<&nbsp;>@||"one " <> "two " <> "three"||"one "@@||@@"two "@@||@@"three"; _
cat("one ", "two ", "three");||concat("one ", "two ", "three");|| || ||
||[[# translate-case]][#translate-case-note translate case]||ToUpperCase["foo"] _
ToLowerCase["FOO"]||with(StringTools): _
 _
UpperCase("foo"); _
LowerCase("FOO");||supcase("foo"); _
sdowncase("FOO");|| || ||
||[[# trim]][#trim-note trim] _
@<&nbsp;>@||StringTrim[" foo "]||with(StringTools): _
 _
Trim(" foo ");||strim(" ", " foo ");|| || ||
||[[# num-to-str]][#num-to-str-note number to string] _
@<&nbsp;>@||"value: " <> ToString[8]||cat("value: ", 8);||concat("value: ", 8);|| || ||
||[[# str-to-num]][#str-to-num-note string to number]||7 + ToExpression["12"] _
73.9 + ToExpression[".037"]||7 + parse("12"); _
73.9 + parse(".037");||7 + parse_string("12"); _
73.9 + parse_string(".037"); _
 _
##gray|/* parse_string raises error if the string does _
not contain valid Maxima code.  Use numberp _
predicate to verify that the return value is _
numeric. */##|| || ||
||[[# str-join]][#str-join-note string join]||StringJoin[Riffle[{"foo", "bar", "baz"}, ","]]||with(StringTools): _
 _
Join(["foo", "bar", "baz"], ",");||simplode(["foo", "bar", "baz"], ",");|| || ||
||[[# split]][#split-note split] _
@<&nbsp;>@||StringSplit["foo,bar,baz", ","]||with(StringTools): _
 _
Split("foo,bar,baz", ",");||split("foo,bar,baz", ",");|| || ||
||[[# str-subst]][#str-subst-note substitute] _
 _
##gray|//first occurrence, all occurences//## ||s = "do re mi mi" _
re = RegularExpression["mi"] _
 _
StringReplace[s, re -> "ma", 1] _
StringReplace[s, re -> "ma"]||with(StringTools): _
 _
Substitute("do re mi mi mi", "mi", "ma"); _
SubstituteAll("do re mi mi mi", "mi", "ma"); _
 _
##gray|# supports regexes:## _
RegSubs("mi"="ma", "do re mi mi mi");||ssubst("mi", "ma", "do re mi mi mi"); _
ssubstfirst("mi", "ma", "do re mi mi mi");|| || ||
||[[# str-len]][#str-len-note length] _
@<&nbsp;>@||StringLength["hello"]||length("hello");||slength("hello");|| || ||
||[[# index-substr]][#index-substr-note index of substring]||StringPosition["hello", "el"][[1]][[1]] _
 _
##gray|(* The index of the first character is 1.*)## _
 _
##gray|(* StringPosition returns an array of pairs, one for each occurrence of the substring.  Each pair contains the index of the first and last character of the occurrence. *)##||searchtext("el", "hello"); _
 _
##gray|# Index of first character is 1. _
# Returns 0 if not found.##||ssearch("el", "hello"); _
 _
##gray|/* 1 is index of first character; _
returns false if substring not found */## _|| || ||
||[[# extract-substr]][#extract-substr-note extract substring]||##gray|(* "el": *)## _
StringTake["hello", {2, 3}]||substring("hello", 2..3);||substring("hello", 2, 4);|| || ||
||[[# char-literal]][#char-literal-note character literal] _
@<&nbsp;>@||##gray|//none//##||##gray|//none//##||##gray|//none//##|| || ||
||[[# lookup-char]][#lookup-char-note character lookup]||Characters["hello"][[1]]||##gray|# string of length 1:## _
"hello"[1]|| || || ||
||[[# chr-ord]][#chr-ord-note chr and ord]||FromCharacterCode[{65}] _
ToCharacterCode["A"][[1]]||with(StringTools): _
 _
Char(65); _
Ord("A")||ascii(65); _
cint("A");|| || ||
||[[# delete-char]][#delete-char-note delete characters]||rules = {"a" -> "", "e" -> "", "i" -> "", _
@<&nbsp;&nbsp;>@"o" -> "", "u" -> ""} _
StringReplace["disemvowel me", rules]||with(StringTools): _
 _
Remove(IsVowel, "disemvowel me");|| || || ||
||||||||||||~ [[# arrays]][#arrays-note arrays]||
||~ ||~ mathematica||~ maple||~ maxima||~ sage||~ sympy||
||[[# array-literal]][#array-literal-note literal]||{1, 2, 3} _
 _
List[1, 2, 3]||a := [1, 2, 3];||[1, 2, 3];||##gray|//use//## [[[scripting#arrays|Python lists]]]||##gray|//use//## [[[scripting#arrays|Python lists]]]||
||[[# array-size]][#array-size-note size] _
@<&nbsp;>@||Length[{1, 2, 3}]||numelems([1, 2, 3]);||length([1, 2, 3]);|| || ||
||[[# array-lookup]][#array-lookup-note lookup]||##gray|(* access time is O(1) *)## _
##gray|(* indices start at one: *)## _
{1, 2, 3}[[1]] _
 _
Part[{1, 2, 3}, 1]||a := [6, 7, 8]; _
a[1];||a: [6, 7, 8]; _
a[1];|| || ||
||[[# array-update]][#array-update-note update] _
@<&nbsp;>@||a[[1]] = 7||a[1] := 7;||a[1]: 7;|| || ||
||[[# array-out-of-bounds]][#array-out-of-bounds-note out-of-bounds behavior]||##gray|//left as unevaluated// Part[] //expression//##||##gray|//Error for both lookup and update.//##||##gray|//Error for both lookup and update.//##|| || ||
||[[# array-element-index]][#array-element-index-note element index]||##gray|(* Position returns list of all positions: *)## _
First /@ Position[{7, 8, 9, 9}, 9]||with(ListTools): _
 _
Search(9, [7, 8, 9]); _
 _
##gray|# SearchAll returns all positions##||a: [7, 8, 9, 9]; _
first(sublist_indices(a, lambda([x], x = 9)));|| || ||
||[[# array-slice]][#array-slice-note slice] _
@<&nbsp;>@||{1, 2, 3}[[1 ;; 2]]|| || || || ||
||[[# array-of-integers-as-index]][#array-of-integers-as-index-note array of integers as index]||##gray|(* evaluates to {7, 9, 9} *)## _
{7, 8, 9}[[{1, 3, 3}]]|| || || || ||
||[[# array-back]][#array-back-note manipulate back]||a = {6,7,8} _
AppendTo[a, 9] _
elem = a[[Length[a]]] _
a = Delete[a, Length[a]] _
elem|| || || || ||
||[[# array-front]][#array-front-note manipulate front]||a = {6, 7, 8} _
PrependTo[a, 5] _
elem = a[[1]] _
a = Delete[a, 1] _
elem|| ||a: [6, 7, 8]; _
push(5, a); _
elem: pop(a);|| || ||
||[[# array-head]][#array-head-note head] _
@<&nbsp;>@||First[{1, 2, 3}]|| ||first([1, 2, 3]);|| || ||
||[[# array-tail]][#array-tail-note tail] _
@<&nbsp;>@||Rest[{1, 2, 3}]|| ||rest([1, 2, 3]);|| || ||
||[[# array-cons]][#array-cons-note cons]||##gray|(* first arg must be an array *)## _
Prepend[{2, 3}, 1]|| ||cons(1, [2, 3]);|| || ||
||[[# array-concatenate]][#array-concatenate-note concatenate] _
@<&nbsp;>@||Join[{1, 2, 3}, {4, 5, 6}]||[op([1, 2, 3]), op([4, 5, 6])]||append([1, 2, 3], [4, 5, 6]);|| || ||
||[[# array-replicate]][#array-replicate-note replicate] _
@<&nbsp;>@||ten_zeros = Table[0, {i, 0, 9}]|| ||ten_zeros: makelist(0, 10);|| || ||
||[[# copy-array]][#copy-array-note copy] _
@<&nbsp;>@||a2 = a|| ||a2: copylist(a);|| || ||
||[[# iterate-over-array]][#iterate-over-array-note iterate] _
@<&nbsp;>@||Function[x, Print[x]] /@ {1, 2, 3}||for i in [1, 2, 3] do _
@<&nbsp;&nbsp;>@print(i); _
end do;||for i in [1, 2, 3] do print(i);|| || ||
||[[# reverse-array]][#reverse-array-note reverse] _
@<&nbsp;>@||Reverse[{1, 2, 3}]||with(ListTools): _
 _
Reverse([1, 2, 3]);||reverse([1, 2, 3]);|| || ||
||[[# sort-array]][#sort-array-note sort]||##gray|(* original list not modified: *)## _
a = Sort[{3, 1, 4, 2}]||##gray|# original list not modified:## _
a := sort([3, 1, 4, 2]);||sort([3, 1, 4, 2]);|| || ||
||[[# dedupe-array]][#dedupe-array-note dedupe] _
@<&nbsp;>@||DeleteDuplicates[{1, 2, 2, 3}]||with(ListTools): _
 _
##gray|# original list not modified:## _
a := MakeUnique([1, 1, 2, 3]);||unique([1, 2, 2, 3]);|| || ||
||[[# membership]][#membership-note membership] _
@<&nbsp;>@||MemberQ[{1, 2, 3}, 2]||evalb(2 in [1, 2, 3]); _
member(2, [1, 2, 3]);||member(7, {1, 2, 3}); _
evalb(7 in {1, 2, 3});|| || ||
||[[# map]][#map-note map]||Map[Function[x, x x], {1, 2, 3}] _
 _
Function[x, x x] /@ {1, 2, 3} _
 _
##gray|(* if function has Listable attribute, Map is unnecessary: *)## _
sqr[x_] := x * x _
SetAttributes[sqr, Listable] _
sqr[{1, 2, 3, 4}]||map(x -> x * x, [1, 2, 3]);||map(lambda([x], x * x), [1, 2, 3]);|| || ||
||[[# filter]][#filter-note filter] _
@<&nbsp;>@||Select[{1, 2, 3}, # > 2 &]||select(x -> x > 2, [1, 2, 3]);||sublist([1, 2, 3], lambda([x], x > 2));|| || ||
||[[# reduce]][#reduce-note reduce] _
@<&nbsp;>@||Fold[Plus, 0, {1, 2, 3}]|| || || || ||
||[[# universal-existential-test]][#universal-existential-test-note universal and existential tests]||##gray|//none//##|| || || || ||
||[[# min-max-elem]][#min-max-elem-note min and max element]||Min[{6, 7, 8}] _
Max[{6, 7, 8}]||with(ListTools): _
 _
FindMinimalElement([6, 7, 8]); _
FindMaximalElement([6, 7, 8]);||apply(min, [6, 7, 8]); _
apply(max, [6, 7, 8]);|| || ||
||[[# shuffle-sample]][#shuffle-sample-note shuffle and sample]||x = {3, 7, 5, 12, 19, 8, 4} _
 _
RandomSample[x] _
RandomSample[x, 3]|| || || || ||
||[[# flatten]][#flatten-note flatten] _
##gray|//one level, completely//##||Flatten[{1, {2, {3, 4}}}, 1] _
Flatten[{1, {2, {3, 4}}}]||with(ListTools): _
 _
FlattenOnce([1, [2, [3, 4]]]); _
Flatten([1, [2, [3, 4]]]);||##gray|/* completely: */## _
flatten([1, [2, [3, 4]]]);|| || ||
||[[# zip]][#zip-note zip]||##gray|(* list of six elements: *)## _
Riffle[{1, 2, 3}, {"a", "b", "c"}] _
 _
##gray|(* list of lists with two elements: *)## _
Inner[List, {1, 2, 3}, {"a", "b", "c"}, List] _
 _
##gray|(* same as Dot[{1, 2, 3}, {2, 3, 4}]: *)## _
Inner[Times, {1, 2, 3}, {2, 3, 4}, Plus]||with(ListTools): _
 _
##gray|# list of six elements:## _
Interleave([1, 2, 3], ["a", "b", "c"]); _
 _
##gray|# list of lists with two elements:## _
zip(@@`[]`@@, [1, 2, 3], ["a", "b", "c"]); _
 _
##gray|# same as DotProduct([1, 2, 3], [2, 3, 4]):## _
add(zip(@@`*`@@, [1, 2, 3], [2, 3, 4]))||##gray|/* list of six elements: */## _
join([1, 2, 3], ["a", "b", "c"]);|| || ||
||[[# cartesian-product]][#cartesian-product-note cartesian product]||Outer[List, {1, 2, 3}, {"a", "b", "c"}]|| || || || ||
||||||||||||~ [[# sets]][#sets-note sets]||
||~ ||~ mathematica||~ maple||~ maxima||~ sage||~ sympy||
||[[# set-literal]][#set-literal-note literal]||##gray|(* same as arrays: *)## _
{1, 2, 3}||{1, 2, 3}||{1, 2, 3}||{1, 2, 3}||{1, 2, 3}||
||[[# set-size]][#set-size-note size]||Length[{1, 2, 3}]|| ||cardinality({1, 2, 3});||len({1, 2, 3})||len({1, 2, 3})||
||[[# array-to-set]][#array-to-set-note array to set]||DeleteDuplicates[{1, 2, 2, 3}]||{op([1, 2, 3])};||setify([1, 2, 3]);||set([1, 2, 3])||set([1, 2, 3])||
||[[# set-to-array]][#set-to-array-note set to array]||##gray|//none; sets are arrays//##||[op({1, 2, 3})];||listify({1, 2, 3});||list({1, 2, 3})||list({1, 2, 3})||
||[[# set-membership]][#set-membership-note membership test] _
@<&nbsp;>@||MemberQ[{1, 2, 3}, 7]||evalb(7 in {1, 2, 3}); _
member(7, {1, 2, 3});||elementp(7, {1, 2, 3});||7 in {1, 2, 3}||7 in {1, 2, 3}||
||[[# set-subset]][#set-subset-note subset test]||SubsetQ[{1, 2, 3}, {1, 2}]|| ||subsetp({1, 2}, {1, 2, 3});||{1, 2} <= {1, 2, 3} _
{1, 2}.issubset({1, 2, 3}) _
 _
{1, 2, 3} >= {1, 2} _
{1, 2, 3}.issuperset({1, 2})||{1, 2} <= {1, 2, 3} _
{1, 2}.issubset({1, 2, 3}) _
 _
{1, 2, 3} >= {1, 2} _
{1, 2, 3}.issuperset({1, 2})||
||[[# set-universal-existential-test]][#set-universal-existential-test-note universal and existential tests]|| || ||every(lambda([x], x > 2), [1, 2, 3]); _
 _
some(lambda([x], x > 2), [1, 2, 3]);|| || ||
||[[# set-union]][#set-union-note union]||Union[{1, 2}, {2, 3, 4}]||{1, 2, 3} union {2, 3, 4};||union({1, 2, 3}, {2, 3, 4});||{1, 2, 3} | {2, 3, 4} _
{1, 2, 3}.union({2, 3, 4})||{1, 2, 3} | {2, 3, 4} _
{1, 2, 3}.union({2, 3, 4})||
||[[# set-intersection]][#set-intersection-note intersection] _
@<&nbsp;>@||Intersect[{1, 2}, {2, 3, 4}]||{1, 2, 3} intersect {2, 3, 4};||intersection({1, 2, 3}, {2, 3, 4});||{1, 2, 3} & {2, 3, 4} _
{1, 2, 3}.intersection({2, 3, 4})||{1, 2, 3} & {2, 3, 4} _
{1, 2, 3}.intersection({2, 3, 4})||
||[[# set-diff]][#set-diff-note relative complement]||Complement[{1, 2, 3}, {2}]||{1, 2, 3} minus {2, 3, 4};||setdifference({1, 2, 3}, {2, 3, 4});||{1, 2, 3} - {2, 3, 4} _
{1, 2, 3}.difference({2, 3, 4})||{1, 2, 3} - {2, 3, 4} _
{1, 2, 3}.difference({2, 3, 4})||
||[[# powerset]][#powerset-note powerset]|| || ||powerset({1, 2, 3});||set(Set({1, 2, 3}).subsets())|| ||
||[[# set-cartesian-prod]][#set-cartesian-prod-note cartesian product]||Outer[List, {1, 2, 3}, {"a", "b", "c"}]|| ||cartesian_product({1, 2, 3}, {"a", "b", "c"});|| || ||
||||||||||||~ [[# arith-seq]][#arith-seq-note arithmetic sequences]||
||~ ||~ mathematica||~ maple||~ maxima||~ sage||~ sympy||
||[#range unit difference] _
@<&nbsp;>@||Range[1, 100]||i $ i = 1..100;||makelist(i, i, 1, 100);||range(1, 101)||range(1, 101)||
||[#arithmetic-sequence-integer difference of 10] _
@<&nbsp;>@||Range[1, 100, 10]||10 * i + 1 $ i = 1..9;||makelist(i, i, 1, 100, 10);||range(1, 100, 10)||range(1, 100, 10)||
||[#airthmetic-sequence-float difference of 1/10] _
@<&nbsp;>@||Range[1, 100, 1/10]||1 + 1/10 * i $ i = 0..990||makelist(i, i, 1, 100, 1/10);||[1 + (1/10)*i for i in range(0, 991)]||[1 + Rational(1,10)*i for i in range(0, 991)]||
||||||||||||~ [[# dictionaries]][#dictionaries-note dictionaries]||
||~ ||~ mathematica||~ maple||~ maxima||~ sage||~ sympy||
||[[# dict-literal]][#dict-literal-note literal] _
@<&nbsp;>@||d = <|"t" -> 1, "f" -> 0|> _
 _
##gray|(* or convert list of rules: *)## _
d = Association[{"t" -> 1, "f" -> 0}] _
##gray|(* and back to list of rules: *)## _
Normal[d]||d := table(["t"=1, "f"=0]);||d: [["t", 1], ["f", 0]];||##gray|//use//## [[[scripting#dictionaries|Python dictionaries]]]||##gray|//use//## [[[scripting#dictionaries|Python dictionaries]]]||
||[[# dict-size]][#dict-size-note size] _
@<&nbsp;>@||Length[Keys[d]]||numelems(d);||length(d);|| || ||
||[[# dict-lookup]][#dict-lookup-note lookup] _
@<&nbsp;>@||d["t"]||d["t"]||assoc("t", d);|| || ||
||[[# dict-update]][#dict-update-note update]||d["f"] = -1||d["f"] := -1;||d2: cons(["f", -1], _
@<&nbsp;&nbsp;>@sublist(d, lambda([p], p[1] # "f")));|| || ||
||[[# dict-missing-key]][#dict-missing-key-note missing key behavior] _
@<&nbsp;>@||##gray|//Returns a symbolic expression with head "Missing".  If the lookup key was "x", the expression is:// _
 _
@<&nbsp;&nbsp;>@Missing["KeyAbsent", "x"]##||##gray|//Returns unevaluated expression.//##||##gray|assoc //returns// false##|| || ||
||[[# dict-key-check]][#dict-key-check-note is key present] _
@<&nbsp;>@||KeyExistsQ[d, "t"]|| || || || ||
||[[# dict-iter]][#dict-iter-note iterate] _
@<&nbsp;>@|| || || || || ||
||[[# dict-key-val]][#dict-key-val-note keys and values as arrays]||Keys[d] _
Values[d]||with(ListTools): _
 _
FlattenOnce(indices(d)); _
FlattenOnce(entries(d));||map(lambda([p], p[1]), d); _
map(lambda([p], p[2]), d);|| || ||
||[[# dict-sort-values]][#dict-sort-values-note sort by values]||Sort[d]|| || || || ||
||||||||||||~ [[# functions]][#functions-note functions]||
||~ ||~ mathematica||~ maple||~ maxima||~ sage||~ sympy||
||[#function-definition define function]||Add[a_, b_] := a + b _
 _
##gray|(* alternate syntax: *)## _
Add = Function[{a, b}, a + b]||add2 := (a, b) -> a + b _
 _
add2 := proc(a, b) _
@<&nbsp;&nbsp;>@a + b _
end proc;||add(a, b) := a + b; _
 _
define(add(a, b), a + b); _
 _
##gray|/* block body: */## _
add(a, b) := block(print("adding", a, "and", b), a + b); _
 _
##gray|/* square bracket syntax: */## _
I[row, col] := if row = col then 1 else 0; _
I[10, 10];|| || ||
||[#function-invocation invoke function]||Add[3, 7] _
 _
Add @<@@>@ {3, 7} _
 _
##gray|(* syntax for unary functions: *)## _
2 @@//@@ Log||add2(3, 7)||add(3, 7);|| || ||
||[[# boolean-func-attr]][#boolean-func-attr-note boolean function attributes] _
##gray|//list, set, clear//##||Attributes[add] _
SetAttributes[add, {Orderless, Flat, Listable}] _
ClearAtttibutes[add, Listable]|| || || || ||
||[[# undef-func]][#undef-func-note undefine function]||Clear[Add]||add2 := 'add2';||remfunction(add);|| || ||
||[[# redefine-func]][#redefine-func-note redefine function]||Add[a_, b_] := b + a||add2 := (a, b) -> b + a;||add(a, b) := b + a;|| || ||
||[[# missing-func]][#missing-func-note missing function behavior]||##gray|//The expression is left unevaluated.  The head is the function name as a symbol, and the parts are the arguments.//##||##gray|//The expression is left unevaluated.//##||##gray|//The expression is left unevaluated.//##|| || ||
||[[# missing-arg]][#missing-arg-note missing argument behavior]||##gray|//The expression is left unevaluated.  The head is the function name as a symbol, and the parts are the arguments.//##||##gray|//Invalid input error.//##||##gray|//Too few arguments error.//##|| || ||
||[[# extra-arg]][#extra-arg-note extra argument behavior]||##gray|//The expression is left unevaluated.  The head is the function name as a symbol, and the parts are the arguments.//##||##gray|//Extra arguments are ignored.//##||##gray|//Too many arguments error.//##|| || ||
||[[# default-arg]][#default-arg-note default argument]||Options[myLog] = {base -> 10} _
myLog[x_, OptionsPattern[]] := _
@<&nbsp;&nbsp;>@N[Log[x]/Log[OptionValue[base]]] _
 _
##gray|(* call using default: *)## _
myLog[100] _
 _
##gray|(* override default: *)## _
myLog[100, base -> E]|| || || || ||
||[[# retval]][#retval-note return value]||##gray|//last expression evaluated, or argument of// Return[]##|| ||##gray|//last expression evaluated//## _
 _
##gray|//Inside a// block(), //the last expression evaluated or the argument of// return()##|| || ||
||[#anonymous-function anonymous function]||Function[{a, b}, a + b] _
 _
(#1 + #2) &|| ||f: lambda([x, y], x + y); _
 _
f(3, 7);|| || ||
||[#variable-number-arguments variable number of arguments]||##gray|(* one or more arguments: *)## _
add[a@@__@@] := Plus[a] _
 _
##gray|(* zero or more arguments: *)## _
add[a@@___@@] := Plus[a]|| ||add([a]) := sum(a[i], i, 1, length(a));|| || ||
||[[# expand-array]][#expand-array-note pass array elements as separate arguments]||Apply[f, {a, b, c}] _
 _
f @<@@>@ {x, y, z}|| ||add(a, b) := a + b; _
apply(add, [3, 7]);|| ||a = [x, y, z] _
f(*a)||
||||||||||||~ [[# execution-control]][#execution-control-note execution control]||
||~ ||~ mathematica||~ maple||~ maxima||~ sage||~ sympy||
||[#if if]||If[x > 0, _
@<&nbsp;&nbsp;>@Print["positive"], _
@<&nbsp;&nbsp;>@If[x < 0, _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@Print["negative"], _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@Print["zero"]]]||if x > 0 then _
@<&nbsp;&nbsp;>@print("positive"); _
elif x < 0 then _
@<&nbsp;&nbsp;>@print("negative"); _
else _
@<&nbsp;&nbsp;>@print("zero"); _
end if||if x > 0 _
@<&nbsp;&nbsp;>@then print("positive") _
@<&nbsp;&nbsp;>@else if x < 0 _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@then print("negative") _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@else print("zero");||##gray|//use//## [http://hyperpolyglot.org/scripting#execution-control Python execution control]||##gray|//use//## [http://hyperpolyglot.org/scripting#execution-control Python execution control]||
||[#while while]||i = 0 _
While[i < 10, Print[i]; i++]|| ||for i: 0 step 1 while i < 10 do print(i);|| || ||
||[#for for]||For[i = 0, i < 10, i++, Print[i]]||for i from 1 by 1 while i < 10 do _
@<&nbsp;&nbsp;>@print(i); _
end do;||for i: 1 step 1 thru 10 do print(i);|| || ||
||[#break break]||Break[]|| || || || ||
||[#continue continue]||Continue[]|| || || || ||
||||||||||||~ [[# exceptions]][#exceptions-note exceptions]||
||~ ||~ mathematica||~ maple||~ maxima||~ sage||~ sympy||
||[[# raise-exc]][#raise-exc-note raise exception]||Throw["failed"]||error "failed";||error("failed");||##gray|//use//## [http://hyperpolyglot.org/scripting#exceptions Python exceptions]||##gray|//use//## [http://hyperpolyglot.org/scripting#exceptions Python exceptions]||
||[[# handle-exc]][#handle-exc-note handle exception]||Print[Catch[Throw["failed"]]]|| ||errcatch(error("failed"));|| || ||
||||||||||||~ [[# streams]][#streams-note streams]||
||~ ||~ mathematica||~ maple||~ maxima||~ sage||~ sympy||
||[[# std-file-handles]][#std-file-handles-note standard file handles]||Streams["stdout"] _
Streams["stderr"] _
 _
##gray|(* all open file handles: *)## _
Streams[]|| || || || ||
||[[# write-line-stdout]][#write-line-stdout-note write line to stdout]||Print["hello"]|| || || || ||
||[[# open-file]][#open-file-note open file for reading]||f  = OpenRead["/etc/hosts"]|| || || || ||
||[[# open-file-write]][#open-file-write-note open file for writing]||f = OpenWrite["/tmp/test"]|| || || || ||
||[[# open-file-append]][#open-file-append-note open file for appending]||f = OpenAppend["/tmp/test"]|| || || || ||
||[[# close-file]][#close-file-note close file]||Close[f]|| || || || ||
||[[# read-file-str]][#read-file-str-note read file into string]||s = ReadString[f]|| || || || ||
||[[# write-str]][#write-str-note write string]||WriteString[f, "lorem ipsum"]|| || || || ||
||[#read-file-string-array read file into array of strings]||s = Import["/etc/hosts"] _
a = StringSplit[s, "\n"]|| || || || ||
||[[# seek]][#seek-note file handle position] _
 _
##gray|//get, set//##||f = StringToStream["foo bar baz"] _
 _
StreamPosition[f] _
 _
##gray|(* beginning of stream: *)## _
SetStreamPosition[f, 0] _
##gray|(# end of stream: *)## _
SetStreamPosition[f, Infinity]|| || || || ||
||[[# tmp-file]][#tmp-file-note open temporary file]||f = OpenWrite[] _
path = Part[f, 1]|| || || || ||
||||||||||||~ [[# files]][#files-note files]||
||~ ||~ mathematica||~ maple||~ maxima||~ sage||~ sympy||
||[[# file-test]][#file-test-note file exists test, regular file test]||FileExistsQ["/etc/hosts"] _
FileType["/etc/hosts"] == File|| || || || ||
||[[# file-size]][#file-size-note file size]||FileByteCount["/etc/hosts"]|| || || || ||
||[[# readable-writeable-executable]][#readable-writable-executable-note is file readable, writable, executable]|| ||with(FileTools): _
 _
isReadable("/etc/hosts"); _
IsWritable("/etc/hosts"); _
IsExecutable("/etc/hosts");|| || || ||
||[[# last-modification-time]][#last-modification-time-note last modification time]||FileDate["/etc/hosts"]|| || || || ||
||[[# file-cp-rm-mv]][#file-cp-rm-mv-note copy file, remove file, rename file]||CopyFile["/tmp/foo", "/tmp/bar"] _
DeleteFile["/tmp/foo"] _
RenameFile["/tmp/bar", "/tmp/foo"]|| || || || ||
||||||||||||~ [[# directories]][#directories-note directories]||
||~ ||~ mathematica||~ maple||~ maxima||~ sage||~ sympy||
||[[# working-dir]][#working-dir-note working directory]||dir = Directory[] _
 _
SetDirectory["/tmp"]||dir := currentdir(); _
 _
currentdir("/tmp");|| || || ||
||[[# build-pathname]][#build-pathname-note build pathname]||FileNameJoin[{"/etc", "hosts"}]||with(FileTools): _
 _
JoinPath(["/etc", "hosts"]);|| || || ||
||[[# dirname-basename]][#dirname-basename-note dirname and basename]||DirectoryName["/etc/hosts"] _
FileBaseName["/etc/hosts"]||with(FileTools): _
 _
ParentDirectory("/etc/hosts"); _
Filename("/etc/hosts");|| || || ||
||[[# absolute-pathname]][#absolute-pathname-note absolute pathname]||##gray|(* file must exist; _
@<&nbsp;&nbsp;&nbsp;>@symbolic links are resolved: *)## _
AbsoluteFileName["foo"] _
AbsoluteFileName["/foo"] _
AbsoluteFileName["../foo"] _
AbsoluteFileName["./foo"] _
AbsoluteFileName["~/foo"]|| || || || ||
||[[# glob]][#glob-note glob paths]||Function[x, Print[x]] /@ FileNames["/tmp/*"]|| || || || ||
||[[# mkdir]][#mkdir-note make directory]||CreateDirectory["/tmp/foo.d"]||mkdir("/tmp/foo.d");|| || || ||
||[[# recursive-cp]][#recursive-cp-note recursive copy]||CopyDirectory["/tmp/foo.d", "/tmp/baz.d"]|| || || || ||
||[[# rmdir]][#rm-dir-note remove empty directory]||DeleteDirectory["/tmp/foo.d"]||rmdir("/tmp/foo.d");|| || || ||
||[[# rm-rf]][#rm-rf-note remove directory and contents]||DeleteDirectory["/tmp/foo.d", _
@<&nbsp;&nbsp;>@DeleteContents -> True]|| || || || ||
||[[# dir-test]][#dir-test-note directory test]||DirectoryQ["/etc"]||isdir("/etc");|| || || ||
||||||||||||~ [[# libraries-namespaces]][#libraries-namespaces-note libraries and namespaces]||
||~ ||~ mathematica||~ maple||~ maxima||~ sage||~ sympy||
||[[# load-lib]][#load-lib-note load library]||Get["foo.m"]|| ||load(grobner);|| || ||
||||||||||||~ [[# reflection]][#reflection-note reflection]||
||~ ||~ mathematica||~ maple||~ maxima||~ sage||~ sympy||
||[#function-documentation get function documentation]||?Tan _
Information[Tan]||Describe(solve);||describe(solve); _
 _
? solve;||solve?||print(solve.@@__doc__@@) _
 _
##gray|# in IJupyter:## _
solve? _
help(solve)||
||[[# func-options]][#func-options-note function options]||Options[Solve] _
Options[Plot]|| || || || ||
||[[# func-src]][#func-src-note function source]|| ||interface(verboseproc = 2); _
print(ScatterPlot);|| || ||import inspect _
 _
inspect.getsourcelines(integrate)||
||[#data-type query data type]||Head[x]||whattype(x);||symbolp(x); _
numberp(7); _
stringp("seven"); _
listp([1, 2, 3]);||type(x)|| ||
||[#list-variables list variables in scope]||Names[$Context <> "*"]|| ||##gray|/* user defined variables: */## _
values; _
 _
##gray|/* user defined functions: */## _
functions;|| || ||
||||||||||||~ [[# symbolic-expr]][#symbolic-expr-note symbolic expressions]||
||~ ||~ mathematica||~ maple||~ maxima||~ sage||~ sympy||
||[[# symbolic-expr-literal]][#symbolic-expr-literal-note literal]||expr = 1 + x + x^2||expr := 1 + x + x^2;||expr = 1 + x + x^2;||expr = 1 + x + x^2||x = symbols('x') _
 _
expr = 1 + x + x^2||
||[[# prevent-simplification]][#prevent-simplification-note prevent simplification]||HoldForm[x + x] _
x + x @@//@@ HoldForm|| || || || ||
||[[# symbolic-expr-var-update]][#symbolic-expr-var-update-note variable update]||expr = 1 + x _
x = 3 _
##gray|(* 4: *)## _
expr||expr := 1 + x; _
x := 3; _
##gray|# 4:## _
expr;||expr: 1 + x; _
x: 3; _
##gray|/* 1 + x: */## _
expr;||expr = 1 + x _
x = 7 _
##gray|# 1 + x:## _
expr||x = symbols('x') _
expr = 1 + x _
x = 3 _
##gray|# 1 + x:## _
expr||
||[[# symbolic-expr-subst]][#symbolic-expr-subst-note substitute]||##gray|(* {3, 3}: *)## _
ReplaceAll[{x, x}, x -> 3] _
 _
##gray|(* {3, 3}: *)## _
{x, x} /. x -> 3 _
 _
##gray|(* {3, 4}: *)## _
{x, y} /. {x -> 3, y -> 4}||##gray|# [3, 3]:## _
subs(x = 3, [x, x]); _
 _
##gray|# [3, 4]:## _
subs([x = 3, y = 4], [x, y])||##gray|/* [3, 3]: */## _
subst(3, x, [x, x]);||vector([x, x]).subs({x: 3})||Matrix([x, x]).subs(x, 3)||
||[[# piecewise-symbolic-expr]][#piecewise-symbolic-expr-note piecewise-defined expression]||Piecewise[@@{{x, x >= 0}, {-x, x < 0}}@@] _
 _
##gray|(* otherwise case: *)## _
Piecewise[@@{{-x, x < 0}}@@, x]||piecewise(x < 0, -x, x >= 0, x); _
 _
##gray|# otherwise case:## _
piecewise(x < 0, -x, x);||if x < 0 then -x else x; _
 _
##gray|/* integrating over piecewise-defined expression fails */##||piecewise([ _
@<&nbsp;&nbsp;>@((-infinity,0), -x), _
@<&nbsp;&nbsp;>@((0,infinity), x)])||Piecewise((-x, x < 0), (x, x >= 0)) _
 _
##gray|# otherwise case:## _
Piecewise((-x, x < 0), (x, True))||
||[[# simplify]][#simplify-note simplify]||Simplify[Cos[x]^2 + Sin[x]^2] _
 _
##gray|(* perform more simplications: *)## _
FullSimplify[-(1/2) I E^(-I x) (-1 + E^(2 I x))]||simplify(cos(x)^2 + sin(x)^2);|| || ||simplify(cos(x)@@**@@2 + sin(x)@@**@@2)||
||[[# assumption]][#assumption-note assumption]||Simplify[Sqrt[x^2], Assumptions -> x >= 0] _
Simplify[(-1)^(n * (n + 1)), _
@<&nbsp;&nbsp;>@Assumptions -> Element[n, Integers]] _
 _
##gray|(* perform fewer simplications: *)## _
Refine[Sqrt[x^2], Assumptions -> x >= 0] _
Refine[(-1)^(n * (n + 1)), Element[n, Integers]]||assume(x > 0); _
##gray|# Maple puts a tilde after an unknown with _
# an assumption; e.g: x~:## _
sqrt(x^2); _
 _
##gray|# expression-local assumption:## _
sqrt(x^2) assuming(x > 0); _
 _
simplify((-1)^(n * (n + 1))) assuming(n, integer);||assume(x > 0); _
sqrt(x^2); _
 _
##gray|/* There is no assumption predicate for _
@<&nbsp;&nbsp;&nbsp;>@integer variables. */##||assume(x > 0) _
sqrt(x^2)||x = symbols('x', positive=True) _
sqrt(x ** 2) _
 _
n = symbols('n', integer=True) _
(-1)@@**@@((n) * (n + 1))||
||[[# assumption-predicates]][#assumption-predicates-note assumption predicates]||Element[x, Complexes] _
Element[x, Reals] _
Element[x, Algebraics] _
Element[x, Rationals] _
Element[x, Integers] _
Element[x, Primes] _
Element[x, Integers] && Mod[x, 5] == 0 _
Element[x, Booleans] _
 _
##gray|(* assumptions can use inequalities and logical operators: *)## _
x > 0 @@||@@ x < 0||##gray|# a partial list:## _
complex _
real _
rational _
integer _
prime _
odd _
even _
positive _
nonnegative _
negative||##gray|//Assumptions can only be created using relational operators.//##||assume(x, 'complex') _
assume(x, 'real') _
assume(x, 'rational') _
assume(x, 'integer') _
assume(x, 'odd') _
assume(x, 'even')||##gray|# a partial list:## _
complex _
real _
algebraic _
rational _
integer _
positive _
nonpositive _
negative _
nonnegative _
nonzero _
prime _
odd _
even||
||[[# list-assumptions]][#list-assumptions-note list assumptions]||##gray|//None.  Assumptions are always local.//##||getassumptions(x);||facts(x); _
 _
##gray|# assumptions on all symbols:## _
facts();||assumptions()||x.assumptions0||
||[[# rm-assumption]][#rm-assumption-note remove assumption]||##gray|//None.  Assumptions are always local.//##||##gray|# removes all assumptions about x:## _
x := 'x';||forget(x > 0);||forget(x > 0) _
 _
##gray|# rm all assumptions:## _
forget()||##gray|# removes all assumptions about x:## _
x = symbols('x')||
||||||||||||~ [[# calculus]][#calculus-note calculus]||
||~ ||~ mathematica||~ maple||~ maxima||~ sage||~ sympy||
||[[# limit]][#limit-note limit] _
@<&nbsp;>@||Limit[Sin[x]/x, x -> 0]||limit(sin(x) / x, x = 0);||limit(sin(x)/x, x, 0);||limit(sin(x)/x, x=0)||limit(sin(x)/x, x, 0)||
||[[# limit-at-infinity]][#limit-at-infinity-note limit at infinity] _
@<&nbsp;>@||Limit[1/x, x -> Infinity]||limit(1 / x, x = infinity);||limit(1/x, x, inf);||limit(1/x, x=infinity)||limit(1/x, x, oo)||
||[[# one-sided-limit]][#one-sided-limit-note one-sided limit] _
 _
##gray|//from left, from right//##||Limit[1/x, x -> 0, Direction -> 1] _
Limit[1/x, x -> 0, Direction -> -1]||limit( 1/ x, x = 0, left); _
limit( 1/ x, x = 0, right);||limit(1/x, x, 0, minus); _
limit(1/x, x, 0, plus);||limit(1/x, x=0, dir='-') _
limit(1/x, x=0, dir='+')||limit(1/x, x, 0, '-') _
limit(1/x, x, 0, '+')||
||[[# derivative]][#derivative-note derivative]||D[x^3 + x + 3, x] _
 _
D[x^3 + x + 3, x] /. x -> 2||diff(x^3 + x + 3, x);||diff(x^3 + x + 3, x); _
 _
at(diff(x^3 + x + 3, x), [x=2]);||diff(x^3 + x + 3, x) _
 _
diff(x^3 + x + 3, x).subs({x: 2}) _
 _
##gray|# derivative is synonym of diff##||diff(x@@**@@3 + x + 3, x) _
 _
diff(x@@**@@3 + x + 3, x).subs(x, 2)||
||[[# derivative-func]][#derivative-func-note derivative of a function]||f[x_] = x^3 + x + 3 _
 _
##gray|(* returns expression: *)## _
D[f[x, x] _
 _
##gray|(* return functions: *)## _
f' _
Derivative[1][f] _
 _
##gray|(* evaluating derivative at a point: *)## _
f'[2] _
Derivative[1][f][2]||f := (x) -> x^3 + x + 3; _
 _
##gray|# returns expression:## _
diff(f(x), x); _
 _
##gray|# returns function:## _
D(f); _
 _
##gray|# evaluating derivative at a point:## _
D(f)(2);|| ||f(x) = x^3 + x + 3 _
 _
diff(f) _
 _
diff(f)(2)|| ||
||[[# derivative-const]][#derivative-const-note constants]||##gray|(* a depends on x; b does not: *)## _
D[a x + b, x,  NonConstants -> {a}] _
 _
Dt[a x + b, x, Constants -> {b}]|| ||##gray|/* symbols constant unless declared with depends: */## _
depends(a, x); _
diff(a * x + b, x); _
 _
##gray|/* makes a constant again: */## _
remove(a, dependency);|| || ||
||[[# higher-order-derivative]][#higher-order-derivative-note higher order derivative]||D[Log[x], {x, 3}] _
Log'''[x] _
Derivative[3][Log][x]||diff(log(x), [x$3]);||diff(log(x), x, 3);||diff(log(x), x, 3)||diff(log(x), x, 3)||
||[[# mixed-partial-derivative]][#mixed-partial-derivative-note mixed partial derivative]||D[x^9 * y^8, x, y, y] _
D[x^9 * y^8, x, {y, 2}]||diff(x^9*y^8, x, y, y); _
diff(x^9 * y^8, x, [y$2]);||diff(x^9 * y^8, x, 1, y, 2);||diff(x^9 * y^8, x, 1).diff(y, 2)||diff(x@@**@@9 * y@@**@@8, x, y, y)||
||[[# div-grad-curl]][#div-grad-curl-note div, grad, and curl]||Div[{x^2, x * y, x * y * z}, {x, y, z}] _
 _
Grad[2 * x * y * z^2, {x, y, z}] _
 _
Curl[{x * y * z, y^2, 0}, {x, y, z}]||with(VectorCalculus): _
SetCoordinates('cartesian'[x, y, z]); _
 _
Divergence(VectorField(<x^2, x*y, x*y*z>))); _
Gradient(2*x*y*z^2, [x, y, z]); _
Curl(VectorField(<x*y*z, y^2, 0>));|| || || ||
||[[# antiderivative]][#antiderivative-note antiderivative] _
@<&nbsp;>@||Integrate[x^3 + x + 3, x]||integrate(x^3 + x + 3, x)||integrate(x^3 + x + 3, x);||integral(x^3 + x + 3, x)||integrate(x@@**@@3 + x + 3, x)||
||[[# definite-integral]][#definite-integral-note definite integral] _
@<&nbsp;>@||Integrate[x^3 + x + 3, {x, 0, 1}]||integrate(x^3 + x + 3, [x = 0 .. 1]);||integrate(x^3 + x + 3, x, 0, 1);||integral(x^3 + x + 3, x, 0, 1)||integrate(x@@**@@3 + x + 3, [x, 0, 1])||
||[[# improper-integral]][#improper-integral-note improper integral] _
@<&nbsp;>@||Integrate[Exp[-x], {x, 0, Infinity}]||integrate(exp(-x), [x = 0 .. infinity]);||integrate(exp(-x), x, 0, inf);||integral(exp(-x), x, 0, infinity)||integrate(exp(-x), (x, 0, oo))||
||[[# double-integral]][#double-integral-note double integral]||##gray|(* integrates over y first: *)## _
Integrate[x^2 + y^2, {x, 0, 1}, {y, 0, x}]||##gray|# integrates over y first:## _
integrate(x^2 + y^2, [y = 0 .. x, x = 0 .. 1]);||integrate( _
@<&nbsp;&nbsp;>@integrate(x^2+y^2, y, 0, x), x, 0, 1);||integral(integral(x^2+y^2, y, 0, x), x, 0, 1)||f = integrate(@@x**2 + y**2@@, (y, 0, x)) _
integrate(f, (x, 0, 1))||
||[[# find-poles]][#find-poles-note find poles] _
@<&nbsp;>@|| ||singular(1/(z-I));|| || || ||
||[[# residue]][#residue-note residue] _
@<&nbsp;>@||Residue[1/(z - I), {z, I}]||residue(1/(z-I), z = I);||residue(1 / (z - %i), z, %i);||f(z) = 1/(z - I) _
f.maxima_methods().residue(z, I)||residue(1/(z-I), z, I)||
||[[# sum]][#sum-note sum] _
@<&nbsp;>@||Sum[2^i, {i, 1, 10}]||sum(2^i, i = 1 .. 10);||sum(2^i, i, 1, 10);||sum(2^i for i in (1..10))||Sum(2@@**@@i, (i, 1, 10)).doit()||
||[[# series-sum]][#series-sum-note series sum] _
@<&nbsp;>@||Sum[2^-n, {n, 1, Infinity}]||sum(2^(-n), n = 1 .. infinity);||sum(2^-n, n, 1, inf), simpsum;||sum(2^-n, n, 1, infinity)||Sum(2@@**@@(-n), (n, 1, oo)).doit()||
||[[# series-expansion-func]][#series-expansion-func-note series expansion of function]||Series[Cos[x], {x, 0, 10}]||series(cos(x), x = 0, 10);||taylor(cos(x), [x, 0, 10]);||taylor(cos(x), x, 0, 10)||series(cos(x), x, n=11)||
||[[# omitted-order-term]][#omitted-order-term-note omitted order term]||expr = 1 + x + x/2 + x^2/6 + O[x]^3 _
 _
##gray|(* remove omitted order term: *)## _
Normal[expr]|| || || || ||
||[[# product]][#product-note product] _
@<&nbsp;>@||Product[2*i + 1, {i, 0, 9}]||product(2*i+1, i = 0 .. 9);||product(2*i + 1, i, 0, 9);||prod(2*i + 1 for i in (0..9))||Product(2*i + 1, (i, 0, 9)).doit()||
||||||||||||~ [[# equations-unknowns]][#equations-unknowns-note equations and unknowns]||
||~ ||~ mathematica||~ maple||~ maxima||~ sage||~ sympy||
||[[# solve-eqn]][#solve-eqn-note solve equation] _
@<&nbsp;>@||Solve[x^3 + x + 3 == 0, x]||solve(x^3 + x + 3 = 0, x);||solve(x^3 + x + 3 = 0, x);||solve(x^3 + x + 3 == 0, x)||solve(x@@**@@3 + x + 3, x)||
||[[# solve-eqns]][#solve-eqns-note solve equations]||Solve[x + y == 3 &&  x == 2 * y, _
@<&nbsp;&nbsp;>@{x, y}] _
 _
##gray|(* or: *)## _
Solve[{x + y == 3, x == 2 * y}, {x, y}]||solve({x = 2 * y, x + y = 3}, {x, y});||solve([x + y = 3, x = 2*y], [x, y]);||solve([x + y == 3, x == 2*y], x, y)||solve([x + y - 3, 3*x - 2*y], [x, y])||
||[[# differential-eqn]][#differential-eqn-note differential equation]||DSolve[y'[x] == y[x], y[x], x]||dsolve(diff(y(x), x) = y(x), y(x));||desolve([diff(y(x), x) = y(x)], [y(x)]);||y = function('y')(x) _
 _
desolve(diff(y, x) == y, y)||y = Function('y') _
 _
dsolve(Derivative(y(x), x) - y(x), y(x))||
||[[# differential-eqn-boundary-condition]][#differential-eqn-boundary-condition-note differential equation with boundary condition]||DSolve[{y'[x] == y[x], y[0] == 1}, y[x], x] _
 _
DSolve[{y''[x] == y[x], y[0] == 1, y'[0] == 2}, _
@<&nbsp;&nbsp;>@y[x], x]||dsolve({diff(y(x), x) = y(x), y(0) = 1}, y(x)); _
 _
dsolve({diff(y(x), x, x) = y(x), _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@y(0) = 1, (D(y))(0) = 2}, _
@<&nbsp;&nbsp;>@y(x))||atvalue(y(x), x=0, 1); _
desolve([diff(y(x), x) = y(x)], [y(x)]);||y = function('y')(x) _
 _
##gray|# y(0) = 1:## _
desolve(diff(y, x) == y, y, [0, 1]) _
 _
##gray|# y(0) = 1 and y'(0) = 2:## _
desolve(diff(y, x, x) == y, y, [0, 1, 2])||##gray|//support for boundary conditions is limited//##||
||[[# differential-eqns]][#differential-eqns-note differential equations]||eqn1 = x'[t] == x[t] - x[t] * y[t] _
eqn2 = y'[t] == x[t] * y[t] - y[t] _
DSolve[{eqn1, eqn2}, {x[t], y[t]}, t]||eqn1 := diff(x(t), t) = x(t)-x(t)*y(t); _
eqn2 := diff(y(t), t) = x(t)*y(t)-y(t); _
dsolve([eqn1, eqn2], [x(t), y(t)]);||eqn1: diff(x(t), t) = x(t) - x(t) * y(t); _
eqn2: diff(y(t), t) = x(t) * y(t) - y(t); _
desolve([eqn1, eqn2], [x(t), y(t)]);|| || ||
||[[# recurrence-eqn]][#recurrence-eqn-note recurrence equation]||eqns = {a[n + 2] == a[n + 1] + a[n], _
@<&nbsp;&nbsp;>@a[0] == 0, _
@<&nbsp;&nbsp;>@a[1] == 1} _
 _
RSolve[eqns, a[n], n] _
 _
##gray|(* remove Fibonacci[] from solution: *)## _
FunctionExpand[RSolve[eqns, a[n], n]]||eqns := {a(0) = 0, _
@<&nbsp;&nbsp;>@a(1) = 1, _
@<&nbsp;&nbsp;>@a(n+2) = a(n+1)+a(n)}; _
 _
rsolve(eqns, a);||solve_rec(a[n]=a[n-1]+a[n-2], a[n], a[0] = 0, a[1] = 1);|| ||n = symbols('n') _
a = Function('a') _
eqn = a(n+2) - a(n+1) - a(n) _
 _
rsolve(eqn, a(n), {a(0): 0, a(1): 1})||
||||||||||||~ [[# optimization]][#optimization-note optimization]||
||~ ||~ mathematica||~ maple||~ maxima||~ sage||~ sympy||
||[[# minimize]][#minimize-note minimize]||##gray|(* returns list of two items: min value and rule _
@<&nbsp;&nbsp;&nbsp;>@transforming x to argmin *)## _
Minimize[x^2 + 1, x] _
 _
##gray|(* 2 ways to get min value: *)## _
Minimize[x^2 + 1, x][[1]] _
MinValue(x^2 + 1, x] _
 _
##gray|(* 2 ways to get argmin: *)## _
x /. Minimize[x^2 + 1, x][[2]] _
ArgMin[x^2 + 1, x]||##gray|# 1:## _
minimize(x^2 + 1, x); _
 _
##gray|# 1, {[{x = 0}, 1]}:## _
minimize(x^2+1, x, location);|| || || ||
||[[# maximize]][#maximize-note maximize]||Maximize[-x^4 + 3 x^3, x] _
 _
Maxvalue[-x^4 + 3 x^3, x] _
ArgMax[-x^4 + 3 x^3, x]||##gray|# 2187/256:## _
maximize(-x^4+3*x^3, x); _
 _
##gray|# 2187/256, {[{x = 9/4}, 2187/256]}:## _
maximize(-x^4+3*x^3, x, location);|| || || ||
||[[# optimize-unknown-param]][#optimize-unknown-param-note objective with unknown parameter]||##gray|(* minval and argmin are expressions _
@<&nbsp;&nbsp;&nbsp;>@containing a: *)## _
Minimize[(x - a)^2 + x, x]||##gray|//Doesn't work; returns expression unevaluated.//##|| || || ||
||[[# unbounded-behavior]][#unbounded-behavior-note unbounded behavior]||##gray|(* MaxValue will be Infinity; MinValue will be _
@<&nbsp;&nbsp;&nbsp;>@-Infinity *)##||##gray|# minimize will return -infinity; _
# maximize will return infinity##|| || || ||
||[[# optimize-multiple-var]][#optimize-multiple-var-note multiple variables]||##gray|(* returns one solution: *)## _
Minimize[x^4 - 2 x^2 + 2 y^4 - 3 y^2, {x, y}]||expr := x^4+2*y^4-2*x^2-3*y^2; _
##gray|# returns all four solutions:## _
minimize(expr, [x, y], location);|| || || ||
||[[# optimize-constraints]][#optimize-constraints-note constraints]||Minimize[{-x - 2 y^2, y^2 <= 17, 2 x + y <= 5}, _
@<&nbsp;&nbsp;>@{x, y}]||##gray|//none//##|| || || ||
||[[# infeasible-behavior]][#infeasible-behavior-note infeasible behavior]||##gray|(* MaxValue will be -Infinity; MinValue will be _
@<&nbsp;&nbsp;&nbsp;>@Infinity; ArgMax or ArgMin will be _
@<&nbsp;&nbsp;&nbsp;>@Indeterminate *)##||##gray|//no infeasible expressions//##|| || || ||
||[[# optimize-int-var]][#optimize-int-var-note integer variables]||Maximize[{x^2 + 2*y, _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@x >= 0, y >= 0, _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@2 x + Pi * y <= 4}, _
@<&nbsp;&nbsp;>@{x, y}, Integers]|| || || || ||
||||||||||||~ [[# vectors]][#vectors-note vectors]||
||~ ||~ mathematica||~ maple||~ maxima||~ sage||~ sympy||
||[[# vec-literal]][#vec-literal-note vector literal]||##gray|(* row vector is same as array: *)## _
{1, 2, 3}||Vector(3, [1, 2, 3]);||##gray|/* row vector is same as array: */## _
[1, 2, 3];||vector([1, 2, 3])||##gray|# column vector:## _
Matrix([1, 2, 3])||
||[[# const-vec]][#const-vec-note constant vector] _
 _
##gray|//all zeros, all ones//##||Table[0, {i, 1, 100}] _
Table[1, {i, 1, 100}]||Vector(100, fill=0); _
Vector(100, fill=1);||makelist(0, 100); _
makelist(1, 100);||vector([0] * 100) _
vector([1] * 100)||Matrix([0] * 100) _
Matrix([1] * 100)||
||[[# vec-coordinate]][#vec-coordinate-note vector coordinate]||##gray|(* indices start at one: *)## _
{6, 7, 8}[[1]]||Vector(3, [6, 7, 8])[1];||[6, 7, 8][1];||vector([6, 7, 8])[0]||Matrix([6, 7, 8])[0]||
||[[# vec-dim]][#vec-dim-note vector dimension] _
@<&nbsp;>@||Length[{1, 2, 3}]||nops(Vector(3, [1, 2, 3]));||length([1, 2, 3]);||len(vector([1, 2, 3]))||len(Matrix([6, 7, 8])) _
Matrix([6, 7, 8]).shape[0]||
||[[# vec-element-wise]][#vec-element-wise-note element-wise arithmetic operators]||+ - * / _
##gray|//adjacent lists are multiplied element-wise//##||+ - *~ /~|| + - * /||+ -||+ - _
 _
##gray|# element-wise multiplication:## _
A = Matrix([1, 2, 3]) _
B = Matrix([2, 3, 4]) _
A.multiply_elementwise(B)||
||[[# vec-length-mismatch]][#vec-length-mismatch-note vector length mismatch] _
@<&nbsp;>@||##gray|//error//##||##gray|//dimensions do not match error//##||##gray|//error//##||##gray|//raises// TypeError##||##gray|//raises// ShapeError##||
||[[# vec-scalar]][#vec-scalar-note scalar multiplication]||3 {1, 2, 3} _
{1, 2, 3} 3 _
##gray|//* may also be used//##||3 * Vector(3, [1, 2, 3]); _
Vector(3, [1, 2, 3]) * 3;||3 * [1, 2, 3]; _
[1, 2, 3] * 3;||3 * vector([1, 2, 3]) _
vector([1, 2, 3]) * 3||3 * Matrix([1, 2, 3]) _
Matrix([1, 2, 3]) * 3||
||[[# vec-dot]][#vec-dot-note dot product]||{1, 1, 1} . {2, 2, 2} _
Dot[{1, 1, 1}, {2, 2, 2}]||Vector(3, [1, 1, 1]) . Vector(3, [2, 2, 2]);||[1, 1, 1] . [2, 2, 2];||vector([1, 1, 1]) * vector([2, 2, 2]) _
vector([1,1,1]).dot_product(vector([2,2,2]))||v1 = Matrix([1, 1, 1]) _
v2 = Matrix([2, 2, 2]) _
v1.dot(v2)||
||[[# vec-cross]][#vec-cross-note cross product]||Cross[{1, 0, 0}, {0, 1, 0}]||with(LinearAlgebra): _
 _
e1 := Vector(3, [1, 0, 0]); _
e2 := Vector(3, [0, 1, 0]); _
CrossProduct(e1, e2); _
e1 &x e2;|| ||e1 = vector([1, 0, 0]) _
e2 = vector([0, 1, 0]) _
e1.cross_product(e2)||e1 = Matrix([1, 0, 0]) _
e2 = Matrix([0, 1, 0]) _
e1.cross(e2)||
||[[# vec-norms]][#vec-norms-note norms]||Norm[{1, 2, 3}, 1] _
Norm[{1, 2, 3}] _
Norm[{1, 2, 3}, Infinity]||with(LinearAlgebra): _
 _
v := Vector(3, [1, 2, 3]); _
VectorNorm(v, 1); _
VectorNorm(v, 2); _
VectorNorm(v, infinity);|| ||vector([1, 2, 3]).norm(1) _
vector([1, 2, 3]).norm() _
vector([1, 2, 3]).norm(infinity)||vec = Matrix([1, 2, 3]) _
 _
vec.norm(1) _
vec.norm() _
vec.norm(inf)||
||[[# orthonormal-basis]][#orthonormal-basis-note orthonormal basis]||Orthogonalize[@@{{1, 0, 1}, {1, 1, 1}}@@]|| ||load(eigen); _
 _
gramschmidt([[1, 0, 1], [1, 1, 1]]);||A = matrix([[1, 0, 1], [1, 1, 1]] _
 _
##gray|# Rows of B are orthogonal and span same _
# space as rows of A. 2nd return value _
# expresses rows of A as linear combos _
# of rows of B.## _
B, _ = A.gram_schmidt()|| ||
||||||||||||~ [[# matrices]][#matrices-note matrices]||
||~ ||~ mathematica||~ maple||~ maxima||~ sage||~ sympy||
||[[# matrix-literal-ctor]][#matrix-literal-ctor-note literal or constructor]||##gray|(* used a nested array for each row: *)## _
@@{{@@1, 2}, {3, 4@@}}@@ _
 _
##gray|(* display as grid with aligned columns: *)## _
MatrixForm[@@{{@@1, 2}, {3, 4@@}}@@]||A := <1, 2; 3, 4>;||matrix([1, 2], [3, 4]);||matrix([[1, 2], [3, 4]])||Matrix([[1, 2], [3, 4]])||
||[[# matrix-from-seq]][#matrix-from-seq-note construct from sequence]||ArrayReshape[{1, 2, 3, 4, 5, 6}, {2, 3}]||Matrix(2, 3, [1, 2, 3, 4, 5, 6])|| ||matrix([1, 2, 3, 4, 5, 6], nrows=2)||Matrix(2, 3, [1, 2, 3, 4, 5, 6])||
||[[# const-matrices]][#const-matrices-note constant matrices] _
 _
##gray|//all zeros, all ones//##||Table[0, {i, 3}, {j, 3}] _
Table[1, {i, 3}, {j, 3}]||Matrix(3, 3, fill=0); _
Matrix(3, 3, fill=1);||zeromatrix(3, 3); _
 _
f[i, j] := 1; _
genmatrix(f, 3, 3);||matrix([0] * 9, nrows=3) _
matrix([1] * 9, nrows=3)||zeros(3, 3) _
ones(3, 3)||
||[[# diagonal-matrices]][#diagonal-matrices-note diagonal matrices] _
##gray|//and identity//##||DiagonalMatrix[{1, 2, 3}] _
IdentityMatrix[3]||with(LinearAlgebra): _
 _
IdentityMatrix(3); _
DiagonalMatrix([1, 2, 3]);||ident(3) * [1, 2, 3]; _
ident(3);||matrix.identity(3) * vector([1, 2, 3]) _
matrix.identity(3)||diag(*[1, 2, 3]) _
eye(3)||
||[[# matrix-formula]][#matrix-formula-note matrix by formula]||Table[1/(i + j - 1), {i, 1, 3}, {j, 1, 3}]||h := (i, j) -> 1/(i+j-1); _
Matrix(3, 3, h);||h2[i, j] := 1/(i + j -1); _
genmatrix(h2, 3, 3);|| || ||
||[[# matrix-dim]][#matrix-dim-note dimensions]||##gray|(* returns {3, 2}: *)## _
Dimensions[@@{{1, 2}, {3, 4}, {5, 6}}@@]||with(LinearAlgebra): _
 _
A := Matrix(3, 2, [1, 2, 3, 4, 5, 6]); _
r, c := Dimension(A);||A: matrix([1, 2, 3], [4, 5, 6]); _
matrix_size(A);||A = matrix([[1, 2], [3, 4], [5, 6]]) _
A.nrows() _
A.ncols()||A = matrix([[1, 2], [3, 4], [5, 6]]) _
 _
##gray|# returns (3, 2):## _
A.shape||
||[[# matrix-elem-lookup]][#matrix-elem-lookup-note element lookup]||##gray|(* top left corner: *)## _
@@{{1, 2}, {3, 4}}@@[[1, 1]]||<1, 2; 3, 4>[1][1]; _
<1, 2; 3, 4>[1, 1];||A: matrix([1, 2], [3, 4]); _
 _
A[1, 1]; _
A[1][1];||A = matrix([[1, 2], [3, 4]]) _
A[0, 0] _
A[0][0]||A = Matrix([[1, 2], [3, 4]]) _
 _
##gray|# top left corner:## _
A[0, 0]||
||[[# extract-matrix-row]][#extract-matrix-row-note extract row]||##gray|(* first row: *)## _
@@{{1, 2}, {3, 4}}@@[[1]]||<1, 2; 3, 4>[1];||row(matrix([1, 2], [3, 4]), 1); _
matrix([1, 2], [3, 4])[1];||##gray|# first row as vector:## _
A[0] _
A.rows()[0]||##gray|# first row:## _
A[0, :]||
||[[# extract-matrix-col]][#extract-matrix-col-note extract column]||##gray|(* first column as array: *)## _
@@{{1, 2}, {3, 4}}@@[[All, 1]]||with(LinearAlgebra): _
 _
Column(<1, 2; 3, 4>, 1);||col(matrix([1, 2], [3, 4]), 1);||##gray|# first column as vector:## _
A.columns()[0]||##gray|# first column as 1x2 matrix:## _
A[:, 0]||
||[[# extract-submatrix]][#extract-submatrix-note extract submatrix]||A = @@{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}@@ _
A[[1;;2, 1;;2]]||A := <1, 2, 3; 4, 5, 6; 7, 8, 9>; _
A[1..2, 1..2];|| ||A = matrix(range(1, 10), nrows=3) _
 _
##gray|# takes two lists of indices:## _
A.matrix_from_rows_and_columns([0, 1], [0, 1])||rows = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] _
A = Matrix(rows) _
A[0:2, 0:2]||
||[[# matrix-scalar-mult]][#matrix-scalar-mult-note scalar multiplication]||3 * @@{{1, 2}, {3, 4}}@@ _
@@{{1, 2}, {3, 4}}@@ * 3||3 * <1, 2; 3, 4>; _
<1, 2; 3, 4> * 3;||3 * matrix([1, 2], [3, 4]); _
matrix([1, 2], [3, 4]) * 3;||3 * matrix([[1, 2], [3, 4]]) _
matrix([[1, 2], [3, 4]]) * 3||3 * Matrix([[1, 2], [3, 4]]) _
Matrix([[1, 2], [3, 4]]) * 3||
||[[# matrix-elem-wise-op]][#matrix-elem-wise-op-note element-wise operators]||+ - * / _
##gray|//adjacent matrices are multiplied element-wise//##||+ - *~||+ - * /||+ -||+ - _
 _
##gray|# for Hadamard product:## _
A.multiply_elementwise(B)||
||[[# matrix-mult]][#matrix-mult-note product]||A = @@{{1, 2}, {3, 4}}@@ _
B = @@{{4, 3}, {2, 1}}@@ _
Dot[A, B] _
##gray|(* or use period: *)## _
A . B||A := <1, 2; 3, 4>; _
B := <4, 3; 2, 1>; _
A . B;||A: matrix([1, 2], [3, 4]); _
B: matrix([4, 3], [2, 1]); _
A . B;||A = matrix([[1, 2], [3, 4]]) _
B = matrix([[4, 3], [2, 1]]) _
A * B||A = matrix([[1, 2], [3, 4]]) _
B = matrix([[4, 3], [2, 1]]) _
A * B||
||[[# matrix-power]][#matrix-power-note power]||MatrixPower[@@{{1, 2}, {3, 4}}@@, 3] _
 _
##gray|(* element-wise operator: *)## _
A ^ 3||with(LinearAlgebra): _
 _
MatrixPower(<1, 2; 3, 4>, 3);||matrix([1, 2], [3, 4]) @@^^@@ 3;||A ^ 3 _
A @@**@@ 3||A @@**@@ 3||
||[[# matrix-exponential]][#matrix-exponential-note exponential]||MatrixExp[@@{{1, 2}, {3, 4}}@@]||with(LinearAlgebra): _
 _
MatrixExponential(<1, 2; 3, 4>);|| ||exp(matrix([[1, 2], [3, 4]]))|| ||
||[[# matrix-log]][#matrix-log-note log]||MatrixLog[@@{{1, 2}, {3, 4}}@@]|| || || || ||
||[[# kronecker-prod]][#kronecker-prod-note kronecker product]||A = @@{{1, 2}, {3, 4}}@@ _
B = @@{{4, 3}, {2, 1}}@@ _
KroneckerProduct[A, B]||with(LinearAlgebra): _
 _
A := <1, 2; 3, 4>; _
B := <4, 3; 2, 1>; _
KroneckerProduct(A, B);||A: matrix([1, 2], [3, 4]); _
B: matrix([4, 3], [2, 1]); _
kronecker_product(A, B);||A = matrix([[1, 2], [3, 4]]) _
B = matrix([[4, 3], [2, 1]]) _
A.tensor_product(B)|| ||
||[[# matrix-norms]][#matrix-norms-note norms]||A = @@{{1, 2}, {3, 4}}@@ _
 _
Norm[A, 1] _
Norm[A, 2] _
Norm[A, Infinity] _
Norm[A, "Frobenius"]||with(LinearAlgebra): _
 _
A := <1, 2; 3, 4>; _
 _
Norm(A, 1); _
Norm(A, 2); _
Norm(A, infinity); _
Norm(A, Frobenius);||A: matrix([1, 2], [3, 4]); _
 _
mat_norm(A, 1); _
##gray|/* none */## _
mat_norm(A, inf); _
mat_norm(A, frobenius);||A = matrix([[1, 2], [3, 4]]) _
 _
##gray|# floating point values:## _
A.norm(1) _
A.norm() _
A.norm(infinity) _
A.norm('frob')|| ||
||[[# matrix-transpose]][#matrix-transpose-note transpose]||Transpose[@@{{1, 2}, {3, 4}}@@] _
 _
##gray|(* or ESC tr ESC for T exponent notation *)##||with(LinearAlgebra): _
 _
Transpose(<1, 2; 3, 4>);||transpose(A);||A.transpose()||A.T||
||[[# matrix-conjugate-transpose]][#matrix-conjugate-transpose-note conjugate transpose]||A = @@{{1, I}, {2, -I}}@@ _
ConjugateTranspose[A] _
 _
##gray|(* or ESC ct ESC for dagger exponent notation *)##||with(LinearAlgebra): _
 _
A := <1, I; 2, -I>; _
HermitianTranspose(A);||ctranspose(matrix([1, %i], [2, -%i]));||M = matrix([[1, I], [2, -I]]) _
M.conjugate_transpose()||M = Matrix([[1, I], [2, -I]]) _
M.adjoint()||
||[[# matrix-inverse]][#matrix-inverse-note inverse]||Inverse[@@{{1, 2}, {3, 4}}@@] _
 _
##gray|(* expression left unevaluated: *)## _
Inverse[@@{{1, 0}, {0, 0}}@@]||with(LinearAlgebra): _
 _
MatrixInverse(<1, 2; 3, 4>); _
 _
##gray|# error:## _
MatrixInverse(<1, 0; 0, 0>);||invert(A); _
A @@^^@@ -1; _
 _
##gray|/* error: */## _
invert(matrix([1, 0], [0, 0]));||A.inverse() _
A ^ -1 _
A ** -1||A.inv() _
 _
##gray|# raises ValueError:## _
Matrix([[1, 0], [0, 0]]).inv()||
||[[# row-echelon-form]][#row-echelon-form-note row echelon form]||RowReduce[@@{{1, 1}, {1, 1}}@@]||with(LinearAlgebra): _
 _
ReducedRowEchelonForm(<1, 1; 1, 1>);||echelon(matrix([1, 1], [1, 1]));||matrix([[1, 1], [1, 1]]).echelon_form()|| ||
||[[# pseudoinverse]][#pseudoinverse-note pseudoinverse]||PseudoInverse[@@{{1, 0}, {3, 0}}@@]|| || || || ||
||[[# determinant]][#determinant-note determinant]||Det[@@{{1, 2}, {3, 4}}@@]||with(LinearAlgebra): _
 _
Determinant(<1, 2; 3, 4>);||determinant(A);||A.determinant()||A.det()||
||[[# trace]][#trace-note trace]||Tr[@@{{1, 2}, {3, 4}}@@]||with(LinearAlgebra): _
 _
Trace(<1, 2; 3, 4>);||load("nchrpl"); _
 _
mattrace(matrix([1, 2], [3, 4]));||A.trace()|| ||
||[[# characteristic-polynomial]][#characteristic-polynomial-note characteristic polynomial]||CharacteristicPolynomial[@@{{1, 2}, {3, 4}}@@, x]||with(LinearAlgebra): _
 _
CharacteristicPolynomial(<1, 2; 3, 4>, x);||A: matrix([1, 2], [3, 4]); _
 _
charpoly(A, x);||matrix([[1, 2], [3, 4]]).charpoly('x')|| ||
||[[# minimal-polynomial]][#minimal-polynomial-note minimal polynomial]|| ||with(LinearAlgebra): _
 _
MinimalPolynomial(IdentityMatrix(3), x);||load(diag); _
 _
minimalPoly(jordan(ident(3)));||matrix.identity(3).minpoly('x')|| ||
||[[# matrix-rank]][#matrix-rank-note rank]||MatrixRank[@@{{1, 1}, {0, 0}}@@]||with(LinearAlgebra): _
 _
Rank(<1, 1; 0, 0>);||rank(matrix([1, 1], [0, 0]));||matrix([[1, 1], [0, 0]]).rank()|| ||
||[[# nullspace-basis]][#nullspace-basis-note nullspace basis]||NullSpace[@@{{1, 1}, {0, 0}}@@]||with(LinearAlgebra): _
 _
NullSpace(<1, 1; 0, 0>);||nullspace(matrix([1, 1], [0, 0]));|| || ||
||[[# eigenval]][#eigenval-note eigenvalues]||Eigenvalues[@@{{1, 2}, {3, 4}}@@]||with(LinearAlgebra): _
 _
Eigenvalues(<1, 2; 3, 4>);||##gray|/* returns list of two lists: _
@<&nbsp;&nbsp;&nbsp;>@first is the eigenvalues, _
@<&nbsp;&nbsp;&nbsp;>@second is their multiplicities */## _
eigenvalues(A);||matrix([[1, 2], [3, 4]]).eigenvalues()||A.eigenvals()||
||[[# eigenvec]][#eigenvec-note eigenvectors]||Eigenvectors[@@{{1, 2}, {3, 4}}@@]||Eigenvectors(<1, 2; 3, 4>);||##gray|/* returns list of two lists.  The first item is the return value of eigenvalues().  The second item is a list containing a list of eigenvectors for each eigenvalue. */## _
eigenvectors(A);|| ||A.eigenvects()||
||[[# spectral-decomposition]][#spectral-decomposition-note spectral decomposition]||A = @@{{1, 2}, {2, 1}}@@ _
z :=  Eigensystem[A] _
d := DiagonalMatrix[z[[1]]] _
P := Transpose[z[[2]]] _
 _
P . d . Inverse[P] == A|| || || || ||
||[[# lup-decomposition]][#lup-decomposition-note LUP decomposition]||{lu, p, c} = LUDecomposition[@@{{1, 2}, {3, 4}}@@] _
L = LowerTriangularize[lu] _
U = UpperTriangularize[lu] _
P = Permute[IdentityMatrix[2], p]||L, U, P := LUDecomposition(<1, 2; 3, 4>);|| || || ||
||[[# qr-decomposition]][#qr-decomposition-note QR decomposition]||A := @@{{1, 2}, {3, 4}}@@ _
{Q, R} = QRDecomposition[A] _
A == Q . R|| || || || ||
||[[# jordan-decomposition]][#jordan-decomposition-note jordan decomposition]||A := {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}} _
z := JordanDecomposition[A] _
P := z[[1]] _
J := z[[2]] _
A . P == P . J|| || || || ||
||[[# svd]][#svd-note singular value decomposition]||A := @@{{1, 2}, {3, 4}}@@ _
z := SingularValueDecomposition[A] _
U := z[[1]] _
S := z[[2]] _
V := z[[3]] _
 _
N[A] == N[U . S . ConjugateTranspose[V]]|| || || || ||
||[[# polar-decomposition]][#polar-decomposition-note polar decomposition]||A := @@{{1, 2}, {3, 4}}@@ _
{u, s, v} := SingularValueDecomposition[A] _
vt :=  ConjugateTranspose[v] _
 _
U := u * vt _
P =  v * s * vt|| || || || ||
||||||||||||~ [[# combinatorics]][#combinatorics-note combinatorics]||
||~ ||~ mathematica||~ maple||~ maxima||~ sage||~ sympy||
||[[# factorial]][#factorial-note factorial] _
 _
##gray|//and permutations//##||5! _
Factorial[5] _
 _
Permutations[Range[1, 5]]||5! _
factorial(5)||5! _
factorial(5);||factorial(5) _
5.factorial()||factorial(5)||
||[[# binomial-coefficient]][#binomial-coefficient-note binomial coefficient] _
 _
##gray|//and combinations//##||Binomial[10, 3]||binomial(10, 3)||binomial(10, 3);||binomial(10, 3)||binomial(10, 3)||
||[[# multinomial-coefficient]][#multinomial-coefficient-note multinomial coefficient]||Multinomial[3, 4, 5]||with(combinat): _
 _
multinomial(12, 3, 4, 5);||multinomial(12, [3, 4, 5]);||multinomial([3, 4, 5])|| ||
||[[# rising-falling-factorial]][#rising-falling-factorial-note rising and falling factorial]||Pochhammer[1/2, 3] _
 _
FactorialPower[1/2, 3]||pochhammer(1/2, 3); _
 _
pochhammer(1/2 - 2, 3);||pochhammer(1/2, 3); _
 _
pochhammer(1/2 - 2, 3);||rising_factorial(1/2, 3) _
 _
falling_factorial(1/2, 3)|| ||
||[[# subfactorial]][#subfactorial-note subfactorial] _
 _
##gray|//and derangments//##||Needs["Combinatorica@@`@@"] _
 _
NumberOfDerangements[10]|| || ||subfactorial(10)||subfactorial(10)||
||[[# int-partitions]][#int-partitions-note integer partitions]||##gray|(* number of partitions: *)## _
PartitionsP[10] _
 _
##gray|(* the partitions as an array: *)## _
IntegerPartitions[10]||with(combinat): _
 _
##gray|# number of partitions:## _
numbpart(10); _
 _
##gray|# the partitions as an array:## _
partition(10);||length(integer_partitions(10)); _
 _
##gray|/* the partitions as an array: */## _
integer_partitions(10); _
 _
||Partitions(10).cardinality() _
Partitions(10).list()||from sympy.utilities.iterables \ _
@<&nbsp;&nbsp;>@import partitions _
 _
len(list(partitions(10))) _
 _
[p.copy() for p in partitions(10)]||
||[[# compositions]][#compositions-note compositions]||Needs["Combinatorica@@`@@"] _
 _
##gray|(* weak compositions of size 3 is 66: *)## _
NumberOfCompositions[10, 3] _
 _
Compositions[10, 3]||with(combinat): _
 _
##gray|# compositions of size 3 is 36:## _
numbcomp(10, 3); _
 _
composition(10, 3);|| ||##gray|# compositions of all lengths:## _
Compositions(10).cardinality() _
 _
Compositions(10).list() _
 _
##gray|# of length 3:## _
Compositions(10, min_length=3, _
@<&nbsp;&nbsp;>@max_length=3).list()|| ||
||[[# set-partitions]][#set-partitions-note set partitions]||StirlingS2[10, 3] _
 _
Needs["Combinatorica@@`@@"] _
 _
KSetPartitions[10, 3] _
SetPartititions[10]||Stirling2(10, 3);||stirling2(10, 3);||stirling_number2(10, 3)|| ||
||[[# bell-num]][#bell-num-note bell number]||BellB[10]||with(combinat): _
 _
bell(10);||belln(10);||bell_number(10)||bell(10)||
||[[# permutations-k-disjoint-cycles]][#permutations-k-disjoint-cyclces permutations with k disjoint cycles]||Abs[StirlingS1[10, 3]]||abs(Stirling1(10, 3));||abs(stirling1(10, 3));||stirling_number1(10, 3)|| ||
||[[# fibonacci-num]][#fibonacci-num-note fibonacci number] _
 _
##gray|//and lucas number//##||Fibonacci[10] _
LucasL[10]||with(combinat): _
 _
fibonacci(10);||fib(10); _
lucas(10);||fibonacci(10) _
lucas_number2(10, 1, -1)||fibonacci(10) _
lucas(10)||
||[[# bernoulli-num]][#bernoulli-num-note bernoulli number]||BernoulliB[100]||bernoulli(100);||bern(100);||bernoulli(100)||bernoulli(100)||
||[[# harmonic-num]][#harmonic-num-note harmonic number]||HarmonicNumber[100]||sum(1/n, n = 1 .. 100);|| || ||harmonic(100)||
||[[# catalan-num]][#catalan-num-note catalan number]||CatalanNumber[10]|| || ||catalan_number(10)||catalan(10)||
||||||||||||~ [[# number-theory]][#number-theory-note number theory]||
||~ ||~ mathematica||~ maple||~ maxima||~ sage||~ sympy||
||[[# divisible-test]][#divisible-test-note divisible test] _
@<&nbsp;>@||Divisible[1001, 7]||evalb(mod(1001, 7) = 0);||is(mod(1001, 7) = 0);||7.divides(1001)||1001 % 7 == 0||
||[[# divisors]][#divisors-note divisors]||##gray|(* {1, 2, 4, 5, 10, 20, 25, 50, 100}: *)## _
Divisors[100]||with(NumberTheory): _
 _
Divisors(100);||divisors(100);||divisors(100)||ntheory.divisors(100)||
||[[# pseudoprime-test]][#pseudoprime-test-note pseudoprime test]||PrimeQ[7]||isprime(7);||primep(7);||is_prime(7) _
is_pseudoprime(7)||ntheory.primetest.isprime(7) _
ntheory.primetest.mr(7, [2, 3])||
||[[# prime-factors]][#prime-factors prime factors]||##gray|(* returns @<{{>@2, 2}, {3, 1}, {7, 1}} *)## _
FactorInteger[84]||##gray|# [1, [[2, 2], [3, 1], [7, 1]]]:## _
ifactors(84);||##gray|/* 2^2 3 7: */## _
factor(84); _
 _
##gray|/* [[2,2],[3,1],[7,1]]: */## _
ifactors(84);||##gray|# 2^2 * 3 * 7:## _
factor(84)||##gray|# {2: 2, 3: 1, 7: 1}:## _
ntheory.factorint(84)||
||[[# next-prime]][#next-prime-note next prime] _
 _
##gray|//and preceding//##||NextPrime[1000] _
NextPrime[1000, -1]||nextprime(1000); _
prevprime(1000);||next_prime(1000); _
prev_prime(1000);||next_prime(1000) _
previous_prime(1000)||ntheory.generate.nextprime(1000) _
ntheory.generate.prevprime(1000)||
||[[# nth-prime]][#nth-prime-note nth prime]||##gray|(* 541: *)## _
Prime[100]||ithprime(100);|| ||primes_first_n(100)[-1]||ntheory.generate.prime(100)||
||[[# prime-counting-func]][#prime-counting-func-note prime counting function]||##gray|(* 25: *)## _
PrimePi[100]||with(NumberTheory): _
 _
pi(100);|| ||prime_pi(100)||ntheory.generate.primepi(100)||
||[[# divmod]][#divmod-note divmod] _
@<&nbsp;>@||QuotientRemainder[7, 3]|| ||divide(7, 3);||divmod(7, 3)||divmod(7, 3)||
||[[# gcd]][#gcd-note greatest common divisor] _
 _
##gray|//and relatively prime test//##||GCD[14, 21] _
GCD[14, 21, 777] _
 _
CoprimeQ[14, 21]||igcd(14, 21); _
igcd(14, 21, 777); _
 _
with(NumberTheory): _
 _
AreCoprime(14, 21);||gcd(14, 21); _
gcd(gcd(14, 21), 777);||gcd(14, 21) _
gcd(gcd(14, 21), 777)||gcd(14, 21) _
gcd(gcd(14, 21), 777)||
||[[# extended-euclidean-algorithm]][#extended-euclidean-algorithm-note extended euclidean algorithm]||##gray|(* {1, {2, -1}}: *)## _
ExtendedGCD[3, 5]||##gray|# Returns 1; _
# sets a and b to 2 and -1:## _
igcdex(3, 5, 'a', 'b')||##gray|/* [2,-1,1]: */## _
gcdex(3, 5);||##gray|# (1, 2, -1):## _
xgcd(3, 5)||from sympy.ntheory.modular import igcdex _
 _
##gray|# (2, -1, 1):## _
igcdex(3, 5)||
||[[# lcm]][#lcm-note least common multiple]||LCM[14, 21]||ilcm(14, 21);||lcm(14, 21);||lcm(14, 21)||lcm(14, 21)||
||[[# power-mod]][#power-mod-note power modulus]||PowerMod[3, 212, 7]|| || ||power_mod(3, 212, 7)|| ||
||[[# mult-inverse]][#mult-inverse-note multiplicative inverse]||##gray|(* inverse of 2 mod 7: *)## _
PowerMod[2, -1, 7] _
 _
##gray|(* left unevaluated: *)## _
PowerMod[2, -1, 4]|| || ||r = Integers(7) _
r(2)^-1 _
 _
r2 = Integers(4) _
##gray|# raises ZeroDivisionError:## _
r2(4)^-1|| ||
||[[# chinese-remainder-thm]][#chinese-remainder-thm-note chinese remainder theorem]||##gray|(* returns 173, which is equal to 3 mod 17 and 8 mod 11: *)## _
ChineseRemainder[{3, 8}, {17, 11}]||##gray|# 173:## _
chrem([3, 8], [17, 11]);||##gray|/* 173: */## _
chinese([3, 8], [17, 11]);||crt(3, 8, 17, 11)|| ||
||[[# euler-totient]][#euler-totient-note euler totient] _
@<&nbsp;>@||EulerPhi[256]||with(NumberTheory): _
 _
Totient(256);||totient(256);||euler_phi(256)||ntheory.totient(256)||
||[[# carmichael-func]][#carmichael-func-note carmichael function]||CarmichaelLambda[561]||with(NumberTheory): _
 _
CarmichaelLambda(561);|| ||from sage.crypto.util import carmichael_lambda _
 _
carmichael_lambda(561)|| ||
||[[# mult-order]][#mult-order-note multiplicative order]||MultiplicativeOrder[7, 108]||with(NumberTheory): _
 _
MultiplicativeOrder(7, 108);|| ||Mod(7, 108).multiplicative_order()|| ||
||[[# primitive-roots]][#primitive-roots-note primitive roots]||PrimitiveRoot[11] _
 _
##gray|(* all primitive roots: *)## _
PrimitiveRootList[11]||with(NumberTheory): _
 _
PrimitiveRoot(11);|| ||primitive_root(11) _
 _
##gray|# raises ValueError if none##|| ||
||[[# discrete-log]][#discrete-log-note discrete logarithm]||##gray|(* solves 10 = 2^x (mod 11): *)## _
MultiplicativeOrder[2, 11, 10]||with(NumberTheory): _
 _
ModularLog(10, 2, 11);|| ||log(Mod(10, 11), Mod(2, 11))|| ||
||[[# quadratic-residues]][#quadratic-residues-note quadratic residues]||Select[Range[0, 4], KroneckerSymbol[#, 5] == 1 &]|| || ||quadratic_residues(5)|| ||
||[[# discrete-sqrt]][#discrete-sqrt-note discrete square root]||PowerMod[4, 1/2, 5]|| || ||Mod(4, 5).sqrt()|| ||
||[[# kronecker-symbol]][#kronecker-symbol-note kronecker symbol] _
 _
##gray|//and jacobi symbol//##||KroneckerSymbol[3, 5] _
JacobiSymbol[3, 5]||with(NumberTheory): _
 _
KroneckerSymbol(3, 5); _
JacobiSymbol(3, 5);||##gray|//??//## _
jacobi(3, 5);||kronecker_symbol(3, 5)|| ||
||[[# moebius-func]][#moebius-func-note moebius function]||MoebiusMu[11]||with(NumberTheory): _
 _
Moebius(11);||moebius(11);||moebius(11)|| ||
||[[# riemann-zeta-func]][#riemann-zeta-func-note riemann zeta function]||Zeta[2]||Zeta(2);||zeta(2);||zeta(2)||mpmath.zeta(2)||
||[[# continued-fraction]][#continued-fraction-note continued fraction]||##gray|(* {0, 1, 1, 1, 5}: *)## _
ContinuedFraction[11/17] _
 _
##gray|(* arrray of first 100 digits for for pi: *)## _
ca= ContinuedFraction[Pi, 100] _
 _
##gray|(* rational approximation of pi: *)## _
FromContinuedFraction[a]||##gray|# [0, 1, 1, 1, 5]:## _
convert(11/17, confrac); _
 _
convert(Pi, confrac, 100);||##gray|/* [0,1,1,1,5]: */## _
cf(11/17); _
 _
float_pi: %pi, numer; _
a = cf(float_pi); _
 _
##gray|/* as continued fraction: */## _
as_cf: cfdisrep(a); _
 _
##gray|/* as simple fraction: */## _
ratsimp(as_cf);||continued_fraction(11/17) _
 _
continued_fraction(pi, 100)|| ||
||[[# convergents]][#convergents-note convergents]||Convergents[11/17] _
 _
##gray|(* for continued fraction: *)## _
Convergents[{0, 1, 1, 1, 5}] _
 _
##gray|(* first 100 rational approximations: *)## _
Convergents[Pi, 100]||##gray|# no retval; convergents printed to stdout:## _
convergs(convert(11/17, confrac)); _
 _
convergs(convert(Pi, confrac, 100));|| ||##gray|# [0, 1, 1/2, 2/3, 11/17]:## _
continued_fraction(11/17).convergents() _
 _
##gray|# iterable infinite list:## _
continued_fraction(pi, 100).convergents()|| ||
||||||||||||~ [[# polynomials]][#polynomials-note polynomials]||
||~ ||~ mathematica||~ maple||~ maxima||~ sage||~ sympy||
||[[# polynomial-literal]][#polynomial-literal-note literal]||p = 2 -3 * x + 2* x^2 _
p2 = (1 + x)^10||p := x^2 - 3*x + 2; _
p2 := (1 + x)^10;||p: x^2 - 3*x + 2; _
p2: (x + 1)^10;||p = x^2 - 3*x + 2 _
p2 = (x + 1)^10|| ||
||[[# extract-polynomial-coefficient]][#extract-polynomial-coefficient-note extract coefficient]||Coefficient[(1 + x)^10, x, 3]||coeff((1 + x)^10, x, 3);||coeff(expand((x + 1)^10), x^3); _
 _
coeff(expand((x + 1)^10), x, 3);||p = (1 + x)^10 _
 _
##gray|# coefficients() returns (power, coeff) pairs:## _
[pair[0] for pair in p.coefficients() _
@<&nbsp;>@if pair[1] == 3][0]|| ||
||[[# extract-polynomial-coefficients]][#extract-polynomial-coefficients-note extract coefficients]||CoefficientList[(x + 1)^10, x]||coeffs(collect((1 + x)^10, x), x);||p: expand((x+1)^10); _
makelist(coeff(p, x^i), i, 0, 10);|| || ||
||[[# polynomial-from-coefficient-array]][#polynomial-from-coefficient-array-note from array of coefficients]||a = {2, -3, 1} _
Sum[a[[i]] * x^i, {i, 1, 3}]||a := [2, -3, 1]; _
sum(a[i] * x^i, i = 1 .. 3);||a: [2, -3, 1]; _
sum(x^i * a[i + 1], i, 0, 2);|| || ||
||[[# polynomial-degree]][#polynomial-degree-note degree]||Exponent[(x + 1)^10, x]||degree((1 + x)^10, x);||hipow(expand((1 + x)^10), x);|| || ||
||[[# expand-polynomial]][#expand-polynomial-note expand]||Expand[(1 + x)^5]||expand((1 + x)^5);||expand((1 + x)^5);||expand((1 + x)^5)||expand((1 + x)@@**@@5)||
||[[# factor-polynomial]][#factor-polynomial-note factor]||Factor[3 + 10 x + 9 x^2 + 2 x^3] _
 _
Factor[x^10 - y^10]||factor(2*x^3 + 9*x^2 + 10*x + 3); _
 _
factor(x^10 - y^10);||factor(2*x^3 + 9*x^2 + 10*x + 3);||factor(2*x^3 + 9*x^2 + 10*x + 3)||factor(3 + 10*x + 9*x@@**@@2 + 2*x@@**@@3)||
||[[# polynomial-roots]][#polynomial-roots-note roots]||Solve[x^3 + 3 x^2 + 2 x - 1 == 0, x] _
 _
##gray|(* just the 2nd root: *)## _
Root[x^3 + 3 x^2 + 2 x - 1, 2]||solve(x^3 + 3*x^2 + 2*x - 1 = 0, x); _
 _
##gray|# rational roots only:## _
roots(2*x^4 - 17*x^3 + 23*x^2 - 17*x + 21, x);||solve(x^3 + 3*x^2 + 2*x - 1 = 0, x);|| || ||
||[[# polynomial-quotient-remainder]][#polynomial-quotient-remainder-note quotient and remainder]||PolynomialReduce[x^10 - 1, x - 1, {x}]||quo(x^10 - 1, x - 1, x); _
rem(x^10 - 1, x - 1, x);||[q, r]: divide(x^10-1, x - 1);|| || ||
||[[# polynomial-gcd]][#polynomial-gcd-note greatest common divisor]||p1 = -2 - x + 2 x^2 + x^3 _
p2 = 6 - 7 x + x^3 _
PolynomialGCD[p1, p2]||p1 := x^3 + 2*x^2 - x - 2; _
p2 := x^3 - 7*x + 6; _
 _
gcd(p1, p2);||p1: -2 - x + 2 * x^2 + x^3; _
p2: 6 - 7*x + x^3; _
gcd(p1, p2);|| || ||
||[[# polynomial-extended-euclidean-algo]][#polynomial-extended-euclidean-algor-note extended euclidean algorithm]||p1 = -2 - x + 2 x^2 + x^3 _
p2 = 6 - 7 x + x^3 _
 _
##gray|(* returns list; first element is GCD; 2nd element is list of two polynomials *)## _
PolynomialExtendedGCD[p1, p2, x]||p1 := x^3 + 2*x^2 - x - 2; _
p2 := x^3 - 7*x + 6; _
 _
##gray|# returns gcd; sets a and b to polynomials:## _
gcdex(p1, p2, x, a, b);|| || || ||
||[[# resultant]][#resultant-note resultant]||Resultant[(x-1) * (x-2), (x-3) * (x-3), x]||resultant((x-1)*(x-2), (x-3)*(x-3), x);||resultant((x - 1)*(x - 2), (x - 3)*(x - 3), x);|| || ||
||[[# discrimant]][#discriminant-note discriminant]||Discriminant[(x + 1) * (x - 2), x]||discrim((x+1)*(x-2), x);|| || || ||
||[[# collect-terms]][#collect-terms-note collect terms]||##gray|(* write as polynomial in x: *)## _
Collect[(1 + x + y)^3, x]||collect((1 + x + y)^3, x);||load(facexp); _
 _
facsum(expand((1 + x + y)^5), x);|| ||collect(expand((x+y+1)**3), x)||
||[[# multivariate-polynomial-quotient-remainder]][#multivariate-polynomial-quotient-remainder-note multivariate quotient and remainder]||PolynomialReduce[x^10 - y^10, x - y, {x, y}]|| ||[q, r]: divide(x^10 - y^10, x - y);|| || ||
||[[# groebner-basis]][#groebner-basis-note groebner basis]||p1 = x^2 + y + z - 1 _
p2 = x + y^2 + z - 1 _
p3 = x + y + z^2 - 1 _
 _
##gray|(* uses lexographic order by default: *)## _
GroebnerBasis[{p1, p2, p3}, {x, y, z}]||with(Groebner): _
 _
p1 := x^2+y+z-1; _
p2 := y^2+x+z-1; _
p3 := z^2+x+y-1; _
 _
Basis([p1, p2, p3], plex(x, y, z));|| || || ||
||specify ordering||GroebnerBasis[{p1, p2, p3}, {x, y, z}, _
@<&nbsp;&nbsp;>@MonomialOrder -> DegreeReverseLexicographic] _
 _
##gray|(* possible values for MonomialOrder: _
 _
@<&nbsp;&nbsp;&nbsp;>@Lexicographic _
@<&nbsp;&nbsp;&nbsp;>@DegreeLexicographic _
@<&nbsp;&nbsp;&nbsp;>@EliminationOrder _
@<&nbsp;&nbsp;&nbsp;>@{1, 2, 3} *)##|| || || || ||
||elementary symmetric polynomial||SymmetricPolynomial[3, {x1, x2, x3, x4}]|| || || || ||
||symmetric reduction||##gray|(* returns list of two elements; 2nd element is remainder if polynomial not symmetric: *)## _
SymmetricReduction[x^3 + y^3 + z^3, {x, y, z}]||##gray|# error if not symmetric:## _
convert(x^3 + y^3 + z^3, 'elsymfun');|| || || ||
||[[# cyclotomic-polynomial]][#cyclotomic-polynomial-note cyclotomic polynomial]||Cyclotomic[10, x]||with(NumberTheory): _
 _
CyclotomicPolynomial(10, x);|| || || ||
||[[# hermite-polynomial]][#hermite-polynomial-note hermite polynomial]||HermiteH[4, x]||with(orthopoly): _
 _
H(4, x)|| || || ||
||[[# chebyshev-polynomial]][#chebyshev-polynomial-note chebyshev polynomial] _
 _
##gray|//first and second kind//##||ChebyshevT[4, x] _
ChebyshevU[4, x]||with(orthopoly): _
 _
T(4, x); _
U(4, x);|| || || ||
||interpolation polynomial||pts = Inner[List, {1, 2, 3}, {2, 4, 7}, List] _
InterpolatingPolynomial[pts, x]|| || || || ||
||spline|| || || || || ||
||[[# partial-fraction-decomposition]][#partial-fraction-decomposition-note partial fraction decomposition]||Apart[(3*x + 2)/ (x^2 + x)] _
 _
##gray|(* can handle multiple vars in denominator: *)## _
Apart[(b * c + a * d)/(b * d)]||convert((2 + 3*x)/(x^2 + x), 'parfrac');||partfrac((3*x + 2) / (x^2 + x), x);|| ||apart((3*x+2) / (x*(x+1)))||
||[[# add-fractions]][#add-fractions-note add fractions]||Together[a/b + c/d]||simplify(a/b + c/d);||ratsimp(a/b + c/d);|| ||together(x/y + z/w)||
||[[# pade-approximant]][#pade-approximant-note pade approximant]||PadeApproximant[Log[x], {x, 1, {2, 3}}]||with(numapprox): _
 _
pade(log(x), x = 1, [3, 2]);||p: taylor(log(x + 1), [x, 0, 5]); _
 _
pade(p, 3, 2);|| || ||
||||||||||||~ [[# trigonometry]][#trigonometry-note trigonometry]||
||~ ||~ mathematica||~ maple||~ maxima||~ sage||~ sympy||
||[[# trig-eliminate-powers-products]][#trig-eliminate-powers-products-note eliminate powers and products of trigonometric functions]||TrigReduce[Sin[x]^2 + Cos[x] Sin[x]]||combine(sin(x)^2+cos(x)*sin(x));||trigreduce(sin(x)^2 + cos(x) * sin(x));|| || ||
||[[# trig-eliminate-sums-multiples]][#trig-eliminate-sums-multiples-note eliminate sums and multiples inside trigonometric functions]||TrigExpand[Sin[2 * x + 1]]||expand(sin(2*x + 1));||trigexpand(sin(2*x + 1));|| || ||
||[[# trig-to-exp]][#trig-to-exp-note trigonometric to exponential]||TrigToExp[Cos[x]]||convert(cos(x), exp);||exponentialize(cos(x));|| ||cos(x).rewrite(cos, exp)||
||[[# exp-to-trig]][#exp-to-trig-note exponential to trigonometric]||ExpToTrig[Exp[I x]]||convert(exp(I*x), trig);||demoivre(exp(%i * x));|| ||from sympy import exp, sin, I _
 _
exp(I * x).rewrite(exp, sin)||
||[[# fourier-expansion]][#fourier-expansion-note fourier expansion]||##gray|(* in sin and cos: *)## _
FourierTrigSeries[SquareWave[x / (2*Pi)], _
@<&nbsp;&nbsp;>@x, 10] _
 _
##gray|(* in complex exponentials: *)## _
FourierSeries[SquareWave[x / (2*Pi)], x, 10]|| || || || ||
||[[# periodic-func]][#periodic-func-note periodic functions on unit interval]||##gray|(*1: [0, 0.5); -1: [0.5, 1.0) *)## _
SquareWave[x] _
 _
##gray|(* 0 at 0 and 0.5; 1 at 0.25; -1 at 0.75 *)## _
TriangleWave[x] _
 _
##gray|(* x on [0, 1) *)## _
SawtoothWave[x]|| || || || ||
||[[# fourier-transform]][#fourier-transform-note fourier transform]||f[w_] = FourierTransform[ Sin[t], t, w] _
 _
InverseFourierTransform[f[w], w, t]||with(inttrans): _
 _
fourier(sin(t), t, w); _
invfourier(f, w, t);|| || || ||
||[[# heaviside-step-func]][#heaviside-step-func-note heaviside step function]|| ||Heaviside(1);@<&nbsp;&nbsp;&nbsp;>@##gray|# 1## _
Heaviside(0);@<&nbsp;&nbsp;&nbsp;>@##gray|# undefined## _
Heaviside(-1);@<&nbsp;&nbsp;>@##gray|# 0## _
 _
diff(Heaviside(x), x);@<&nbsp;&nbsp;>@##gray|# Dirac(x)##|| || || ||
||[[# dirac-delta]][#direct-delta-note dirac delta]|| ||Dirac(1);@<&nbsp;&nbsp;&nbsp;>@##gray|# 0## _
Dirac(0);@<&nbsp;&nbsp;&nbsp;>@##gray|# Dirac(0)## _
Dirac(-1);@<&nbsp;&nbsp;>@##gray|# 0## _
 _
integrate(Dirac(x), x); ##gray|# Heaviside(x)## _
integrate(Dirac(x), x=-1..1); ##gray|# 1##|| || || ||
||||||||||||~ [[# special-functions]][#special-functions-note special functions]||
||~ ||~ mathematica||~ maple||~ maxima||~ sage||~ sympy||
||[[# gamma-func]][#gamma-func-note gamma function]||Gamma[1/2]||GAMMA(1/2);||gamma(1/2);||gamma(1/2)||gamma(Rational(1, 2))||
||[[# err-func]][#err-func-note error function]||Erf[1/2] // N _
 _
Erfc Erfi _
InverseErf InverseErfc||evalf(erf(1/2)); _
 _
erfc erfi||erf(1/2), numer; _
 _
erfc erfi||n(erf(1/2))||N(erf(Rational(1, 2))) _
 _
erfc erfi||
||[[# hyperbolic-func]][#hyperbolic-func-note hyperbolic functions]||Sinh Cosh Tanh _
ArcSinh ArcCosh ArcTanh||sinh cosh tanh _
arcsinh arccosh arctanh||sinh cosh tanh _
asinh acosh atanh||sinh cosh tanh _
asinh acosh atanh||sinh cosh tanh _
asinh acosh atanh||
||[[# elliptic-func]][#elliptic-func-note elliptic integerals]||EllipticK _
EllipticF _
EllipticE _
EllipticPi||EllipticK _
EllipticF _
EllipticE _
EllipticPi||elliptic_f _
elliptic_e _
elliptic_pi|| || ||
||[[# bessel-func]][#bessel-func-note bessel functions]||BesselJ _
BesselY _
BesselI _
BesselK||BesselJ _
BesselY _
BesselI _
BesselK||bessel_j _
bessel_y _
bessel_i _
bessel_k|| || ||
||||||||||||~ [[# permutations]][#permutations-note permutations]||
||~ ||~ mathematica||~ maple||~ maxima||~ sage||~ sympy||
||[[# permutation-from-disjoint-cycles]][#permutation-from-disjoint-cycles-note from disjoint cycles]||p = Cycles[@@{{1, 2}, {3, 4}}@@]|| || ||Permutation([(1, 2), (3, 4)])||import sympy.combinatorics as comb _
 _
p = combinatorics.Permutation(0, 1)(2, 3)||
||[[# permutation-to-disjoint-cycles]][#permutation-to-disjoint-cycles-note to disjoint cycles]|| || || || || ||
||[[# permutation-from-array]][#permutation-from-array-note from array]||p = PermutationCycles[{2, 1, 4, 3}]|| || ||Permutation((2, 1, 4, 3))||import sympy.combinatorics as comb _
 _
p = combinatorics.Permutation([1, 0, 3, 2])||
||[[# permutation-from-two-arrays]][#permutation-from-two-arrays-note from two arrays with same elements]||FindPermutation[{a, b, c}, {b, c, a}]|| || || || ||
||[[# permutation-size]][#permutation-size-note size]|| || || || || ||
||[[# permutation-support]][#permutation-support-note support] _
 _
##gray|//and fixed points//##||PermutationSupport[Cycles[@@{{1, 3, 5}, {7, 8}}@@]]|| || || ||import sympy.combinatorics as comb _
 _
p = comb.Permutation(0, 2, 4)(6, 7) _
p.support()||
||[[# permutation-act-on-element]][#permutation-act-on-element-note act on element]||p = Cycles[@@{{1, 2}, {3, 4}}@@] _
 _
PermutationReplace[1, p]|| || ||Permutation((2, 1, 4, 3))(1)||p(0)||
||[[# permutation-act-on-list]][#permutation-act-on-list-note act on list]||##gray|(* if list is too big, extra elements retain _
@<&nbsp;&nbsp;&nbsp;>@their positions; if list is too small, _
@<&nbsp;&nbsp;&nbsp;>@expression is left unevaluated. *)## _
Permute[{a, b, c, d}, p12n34]|| || ||a, b, c, d = var('a b c d') _
 _
p = Permutation([(1, 2), (3, 4)]) _
p.action([a, b, c, d])||import sympy.combinatorics as comb _
  _
p = comb.Permutation(0, 1)(2, 3) _
p([a, b, c, d])||
||[[# permutation-compose]][#permutation-compose-note compose]||p1 = Cycles[@@{{1, 2}, {3, 4}}@@] _
p2 = Cycles[@@{{1, 3}}@@] _
PermutationProduct[p1, p2]|| || ||p1 = Permutation([(1, 2), (3, 4)]) _
p2 = Permutation((1, 3)) _
p1 * p2||import sympy.combinatorics as comb _
 _
p1 = comb.Permutation(0, 1)(2, 3) _
p2 = comb.Permutation(0, 2) _
p1 * p2||
||[[# permutation-inverse]][#permutation-inverse-note inverse]||InversePermutation[Cycles[@@{{1, 2, 3}}@@]]|| || ||Permutation((1, 2, 3)).inverse()||import sympy.combinatorics as comb _
 _
comb.Permutation(0, 1, 2) ** -1||
||[[# permutation-power]][#permutation-power-note power]||PermutationPower[Cycles[@@{{1, 2, 3, 4, 5}}@@], 3]|| || ||Permutation((1, 2, 3, 4, 5))^3||import sympy.combinatorics as comb _
 _
comb.Permutation(0, 1, 2, 3, 4) ** 3||
||[[# permutation-order]][#permutation-order-note order]||PermutationOrder[Cycles[@@{{1, 2, 3, 4, 5}}@@]]|| || ||p = Permutation((1,2,3,4,5)) _
p.to_permutation_group_element().order()||import sympy.combinatorics as comb _
 _
comb.Permutation(0, 1, 2, 3, 4).order()||
||[[# permutation-num-inversions]][#permutation-num-inversions-note number of inversions]|| || || ||Permutation((1, 3, 2)).length()||import sympy.combinatorics as comb _
 _
comb.Permutation(0, 2, 1).inversions()||
||[[# permutation-parity]][#permutation-parity-note parity]|| || || ||Permutation((1, 3, 2)).is_even()||import sympy.combinatorics as comb _
 _
comb.Permutation(0, 2, 1).parity()||
||[[# permutation-to-inversion-vec]][#permutation-to-inversion-vec-note to inversion vector]|| || || ||Permutation((1, 3, 2)).to_inversion_vector()||import sympy.combinatorics as comb _
 _
comb.Permutation(0, 2, 1).inversion_vector()||
||[[# permutation-from-inversion-vec]][#permutation-from-inversion-vec-note from inversion vector]|| || || || ||import sympy.combinatorics as comb _
 _
comb.Permutation.from_inversion_vector([2, 0])||
||[[# permutation-list]][#permutation-list-note list permutations]||GroupElements[SymmetricGroup[4]] _
 _
##gray|(* of a list: *)## _
Permutations[{a, b, c, d}]|| || ||list(SymmetricGroup(4))|| ||
||[[# permutation-random]][#permutation-random-note random permutation]||RandomPermutation[10]|| || || ||Permutation.random(10)||
||||||||||||~ [[# descriptive-statistics]][#descriptive-statistics-note descriptive statistics]||
||~ ||~ mathematica||~ maple||~ maxima||~ sage||~ sympy||
||[[# first-moment-stats]][#first-moment-stats-note first moment statistics]||vals = {1, 2, 3, 8, 12, 19} _
X = NormalDistribution[0, 1] _
 _
Mean[vals] _
Total[vals] _
Mean[X]||with(Statistics): _
 _
vals := [1, 2, 3, 8, 12, 19]; _
X := RandomVariable(Normal(0, 1)); _
 _
Mean(vals); _
Mean(X);||load(distrib); _
 _
##gray|/* Other distributions have similar functions: */## _
mean_normal(0, 1);|| || ||
||[[# second-moment-stats]][#second-moment-stats-note second moment statistics]||Variance[X] _
StandardDeviation[X]||with(Statistics): _
 _
Variance(X); _
StandardDeviation(X);||load(distrib); _
 _
##gray|/* Other distributions have similar functions: */## _
var_normal(0, 1); _
std_normal(0, 1);|| || ||
||[[# second-moment-stats-sample]][#seond-moment-stats-sample-note second moment statistics for samples]||Variance[vals] _
StandardDeviation[vals]||with(Statistics): _
 _
Variance(vals); _
StandardDeviation(vals);|| || || ||
||[[# skewness]][#skewness-note skewness]||Skewness[vals] _
Skewness[X]||with(Statistics): _
 _
Skewness(vals); _
Skewness(X);||load(distrib); _
 _
##gray|/* Other distributions have similar functions: */## _
skewness_normal(0, 1);|| || ||
||[[# kurtosis]][#kurtosis-note kurtosis]||Kurtosis[vals] _
Kurtosis[X]||with(Statistics): _
 _
Kurtosis(vals); _
Kurtosis(X);||load(distrib); _
 _
##gray|/* Other distributions have similar functions: */## _
kurtosis_normal(0, 1);|| || ||
||[[# nth-moment]][#nth-moment-note nth moment and nth central moment]||Moment[vals, 5] _
CentralMoment[vals, 5] _
Moment[X, 5] _
CentralMoment[X, 5] _
 _
MomentGeneratingFunction[X, t]||with(Statistics): _
 _
Moment(vals, 5); _
CentralMoment(vals, 5); _
Moment(X, 5); _
CentralMoment(X, 5); _
 _
MGF(X, t);|| || || ||
||[[# cumulant]][#cumulant-note cumulant]||Cumulant[vals, 1] _
Cumulant[X, 1] _
 _
CumulantGeneratingFunction[X, t]||with(Statistics): _
 _
Cumulant(vals, 1); _
Cumulant(X, 1); _
 _
CGF(X, t);|| || || ||
||[[# entropy]][#entropy-note entropy] _
@<&nbsp;>@||Entropy[vals]|| || || || ||
||[[# mode]][#mode-note mode] _
@<&nbsp;>@||Commonest[{1, 2, 2, 2, 3, 3, 8, 12}]||with(Statistics): _
 _
Mode([1, 2, 2, 2, 3, 3, 8, 12]);|| || || ||
||[[# quantile-stats]][#quantile-stats-note quantile statistics]||Min[vals] _
Median[vals] _
Max[vals] _
InterquartileRange[vals] _
Quantile[vals, 9/10]||with(Statistics): _
 _
min(vals); _
Median(vals); _
max(vals); _
InterquartileRange(vals); _
Quantile(vals, 9/10);||load(distrib); _
 _
##gray|/* Other distributions have similar functions: */## _
quantile_normal(9/10, 0, 1);|| || ||
||[[# bivariate-stats]][#bivariate-stats-note bivariate statistiscs] _
##gray|//correlation, covariance, Spearman's rank//##||Correlation[{1, 2, 3}, {2, 4, 7}] _
Covariance[{1, 2, 3}, {2, 4, 7}] _
SpearmanRho[{1, 2, 3}, {2, 4, 7}]||with(Statistics): _
 _
Correlation([1, 2, 3], [2, 4, 7]); _
Covariance([1, 2, 3], [2, 4, 7]);|| || || ||
||[[# freq-table]][#freq-table-note data set to frequency table]||data = {1, 2, 2, 2, 3, 3, 8, 12} _
##gray|(* list of pairs: *)## _
tab = Tally[data] _
##gray|(* dictionary: *)## _
dict = Counts[data]||with(Statistics): _
 _
data := [1, 2, 2, 2, 3, 3, 8, 12]; _
##gray|# array of eqns:## _
Tally(data); _
##gray|# dictionary:## _
Tally(data, output=table);|| || || ||
||[[# invert-freq-table]][#invert-freq-table-note frequency table to data set]||f = Function[a, Table[a[[1]], {i, 1, a[[2]]}]] _
data = Flatten[Map[f, tab]]|| || || || ||
||[[# bin]][#bin-note bin]||data = {1.1, 3.7, 8.9, 1.2, 1.9, 4.1} _
##gray|(* bins are [0, 3), [3, 6), and [6, 9): *)## _
bins = BinCounts[data, {{0, 3, 6, 9}}]|| || || || ||
||||||||||||~ [[# distributions]][#distributions-note distributions]||
||~ ||~ mathematica||~ maple||~ maxima||~ sage||~ sympy||
||[[# binomial]][#binomial-note binomial] _
 _
##gray|//density, cumulative distribution, sample//##||X = BinomialDistribution[100, 1/2] _
 _
PDF[X][50] _
CDF[X][50] _
RandomVariate[X]||with(Statistics): _
 _
X := RandomVariable(Binomial(100, 1/2)); _
PDF(X, 50); _
CDF(X, 50); _
Sample(X, 1);||load(distrib); _
 _
pdf_binomial(x, 50, 1/2); _
cdf_binomial(x, 50, 1/2); _
random_binomial(50, 1/2);|| ||from sympy.stats import * _
 _
X = Binomial('X', 100, Rational(1, 2)) _
 _
density(Y).dict[Integer(50)] _
P(X < 50) _
sample(X)||
||[[# poisson]][#poisson-note poisson]||X = PoissonDistribution[1]||with(Statistics): _
 _
X := RandomVariable(Poisson(1));||load(distrib); _
 _
pdf_poisson(x, 1); _
cdf_poisson(x, 1); _
random_poisson(1);|| ||##gray|# P(X < 4) raises NotImplementedError:## _
X = Poisson('X', 1)||
||[[# discrete-uniform]][#discrete-uniform-note discrete uniform]||X = DiscreteUniformDistribution[{0, 99}]||with(Statistics): _
 _
X := RandomVariable(DiscreteUniform(0, 99));||load(distrib); _
 _
##gray|/* {1, 2, ..., 100}: */## _
pdf_discrete_uniform(x, 100); _
cdf_discrete_uniform(x, 100); _
random_discrete_uniform(100);|| ||X = DiscreteUniform('X', list(range(0, 100)))||
||[[# normal]][#normal-note normal] _
 _
##gray|//density, cumulative distribution, quantile, sample//##||X = NormalDistribution[0, 1] _
 _
PDF[X][0] _
CDF[X][0] _
InverseFunction[CDF[X]][1/2] _
RandomVariate[X, 10]||with(Statistics): _
 _
X := RandomVariable(Normal(0, 1)); _
 _
PDF(X, 0); _
CDF(X, 0); _
##gray|# no inverse cdf## _
Sample(X, 10);||with(distrib); _
 _
pdf_normal(x, 0, 1); _
cdf_normal(x, 0, 1); _
##gray|/* no inverse cdf */## _
random_normal(0, 1);||X = RealDistribution('gaussian', 1) _
 _
X.distribution_function(0) _
X.cum_distribution_function(0) _
X.cum_distribution_function_inv(0.5) _
X.get_random_element()||from sympy.stats import * _
 _
X = Normal('X', 0, 1) _
 _
density(X)(0) _
P(X < 0) _
##gray|//??//## _
sample(X)||
||[[# gamma]][#gamma-note gamma]||X = GammaDistribution[1, 1]||with(Statistics): _
 _
X := RandomVariable(Gamma(1, 1));||with(distrib); _
 _
pdf_gamma(x, 1, 1); _
cdf_gamma(x, 1, 1); _
random_gamma(1, 1);|| ||X = Gamma('X', 1, 1)||
||[[# exponential]][#exponential-note exponential]||X = ExponentialDistribution[1]||with(Statistics): _
 _
X := RandomVariable(Exponential(1));||with(distrib); _
 _
pdf_exponential(x, ); _
cdf_exponential(x, 1); _
random_exponential(1);|| ||X = Exponential('X', 1)||
||[[# chi-squared]][#chi-squared-note chi-squared]||X = ChiSquareDistribution[2]||with(Statistics): _
 _
X := RandomVariable(ChiSquare(2));||with(distrib); _
 _
pdf_chi2(x, 2); _
cdf_chi2(x, 2); _
random_chi2(2);||X = RealDistribution('chisquared', 2)||X = ChiSquared('X', 2)||
||[[# beta]][#beta-note beta]||X = BetaDistribution[10, 90]||with(Statistics): _
 _
X := RandomVariable(Beta(10, 90));||with(distrib); _
 _
pdf_beta(x, 10, 90); _
cdf_beta(x, 10, 90); _
random_beta(10, 90);||X = RealDistribution('beta', [10, 90])||X = Beta('X', 10, 90)||
||[[# uniform]][#uniform-note uniform]||X = UniformDistribution[{0, 1}]||with(Statistics): _
 _
X := RandomVariable(Uniform(0, 1));||with(distrib); _
 _
pdf_continuous_uniform(x, 0, 1); _
cdf_continuous_uniform(x, 0, 1); _
random_continuous_uniform(0, 1);||X = RealDistribution('uniform', [0, 1]) _
 _
X.distribution_function(0.5) _
X.cum_distribution_function(0.5) _
X.cum_distribution_function_inv(0.5) _
X.get_random_element()||X = Uniform('X', 0, 1)||
||[[# students-t]][#students-t-note student's t]||X = StudentTDistribution[2]||with(Statistics): _
 _
X := RandomVariable(StudentT(2));||with(distrib); _
 _
pdf_student_t(x, 2); _
cdf_student_t(x, 2); _
random_student_t(2);||X = RealDistribution('t', 2)||X = StudentT('X', 2)||
||[[# snedecors-f]][#snedecors-f-note snedecor's F]||X = FRatioDistribution[1, 1]||with(Statistics): _
 _
X := RandomVariable(FRatio(1, 1));||with(distrib); _
 _
pdf_f(x, 1, 1); _
cdf_f(x, 1, 1); _
random_f(1, 1);||X = RealDistribution('F', [1, 1])||X = FDistribution('X', 1, 1)||
||[[# empirical-density-func]][#empirical-density-func-note empirical density function]||X = NormalDistribution[0, 1] _
data = Table[RandomVariate[X], {i, 1, 30}] _
Y = EmpiricalDistribution[data] _
PDF[Y]||with(Statistics): _
 _
X := RandomVariable(Normal(0, 1)); _
Y := EmpiricalDistribution(Sample(X, 30)); _
Mean(Y);|| || || ||
||[[# empirical-cumulative-distribution]][#empirical-cumulative-distribution-note empirical cumulative distribution]||X = NormalDistribution[0, 1] _
data = Table[RandomVariate[X], {i, 1, 30}] _
Y = EmpiricalDistribution[data] _
Plot[CDF[Y][x], {x, -4, 4}]||with(Statistics): _
 _
X := RandomVariable(Normal(0, 1)); _
Y := EmpiricalDistribution(Sample(X, 30)); _
plot(CDF(Y, x), x = -4 .. 4);|| || || ||
||||||||||||~ [[# statistical-tests]][#statistical-tests-note statistical tests]||
||~ ||~ mathematica||~ maple||~ maxima||~ sage||~ sympy||
||[[# wilcoxon]][#wilcoxon-note wilcoxon signed-rank test] _
##gray|//variable is symmetric around zero//##||X = UniformDistribution[{-1/2, 1/2}] _
data = RandomVariate[X, 100] _
 _
##gray|(* null hypothesis is true: *)## _
SignedRankTest[data] _
 _
##gray|(* alternative hypothesis is true: *)## _
SignedRankTest[data + 1/2]|| ||load(distrib); load(stats); _
 _
data: makelist( _
@<&nbsp;&nbsp;>@random_continuous_uniform(-1/2, 1/2), _
@<&nbsp;&nbsp;>@i, 1, 100); _
 _
##gray|/* null hypothesis is true: */## _
test_signed_rank(data); _
 _
##gray|/* alternative hypothesis is true: */## _
test_signed_rank(data + 1/2);|| || ||
||[[# kruskal]][#kruskal-note kruskal-wallis rank sum test] _
##gray|//variables have same location parameter//##||X = NormalDistribution[0, 1] _
Y = UniformDistribution[{0, 1}] _
 _
##gray|(* null hypothesis is true: *)## _
LocationEquivalenceTest[ _
@<&nbsp;&nbsp;>@{RandomVariate[X, 100], _
@<&nbsp;&nbsp;&nbsp;>@RandomVariate[X, 200]}] _
 _
##gray|(* alternative hypothesis is true: *)## _
LocationEquivalenceTest[ _
@<&nbsp;&nbsp;>@{RandomVariate[X, 100], _
@<&nbsp;&nbsp;&nbsp;>@RandomVariate[Y, 200]}]|| ||load(distrib); load(stats); _
 _
x1: makelist( _
@<&nbsp;&nbsp;>@random_normal(0, 1), _
@<&nbsp;&nbsp;>@i, 1, 100); _
x2: makelist( _
@<&nbsp;&nbsp;>@random_normal(0, 1), _
@<&nbsp;&nbsp;>@i, 1, 100); _
y: makelist( _
@<&nbsp;&nbsp;>@random_continuous_uniform(-1/2, 1/2), _
@<&nbsp;&nbsp;>@i, 1, 100); _
 _
##gray|/* null hypothesis is true: */## _
test_rank_sum(x1, x2); _
 _
##gray|/* alternative hypothesis is true: */## _
test_rank_sum(x1, y);|| || ||
||[[# kolmogorov-smirnov-test]][#kolmogorov-smirnov-test-note kolmogorov-smirnov test] _
##gray|//variables have same distribution//##||X = NormalDistribution[0, 1] _
Y = UniformDistribution[{-1/2, 1/2}] _
 _
##gray|(* null hypothesis is true: *)## _
KolmogorovSmirnovTest[RandomVariate[X, 200], X] _
 _
##gray|(* alternative hypothesis is true: *)## _
KolmogorovSmirnovTest[RandomVariate[X, 200], Y]|| || || || ||
||[[# one-sample-t-test]][#one-sample-t-test-note one-sample t-test] _
##gray|//mean of normal variable with unknown variance is zero//##||X = NormalDistribution[0, 1] _
 _
##gray|(* null hypothesis is true: *)## _
TTest[RandomVariate[X, 200]] _
 _
##gray|(* alternative hypothesis is true: *)## _
TTest[RandomVariate[X, 200] + 1]||with(Statistics): _
 _
X := RandomVariable(Normal(0, 1)); _
 _
##gray|# null hypothesis is true:## _
OneSampleTTest(Sample(X, 100), 0); _
 _
##gray|# alternative hypothesis is true:## _
OneSampleTTest(Sample(X, 100) +~ 1, 0);|| || || ||
||[[# independent-two-sample-t-test]][#independent-two-sample-t-test-note independent two-sample t-test] _
##gray|//two normal variables have same mean//##||X = NormalDistribution[0, 1] _
 _
##gray|(* null hypothesis is true: *)## _
TTest[ _
@<&nbsp;&nbsp;>@{RandomVariate[X, 100], _
@<&nbsp;&nbsp;&nbsp;>@RandomVariate[X, 200]}] _
 _
##gray|(* alternative hypothesis is true: *)## _
TTest[ _
@<&nbsp;&nbsp;>@{RandomVariate[X, 100], _
@<&nbsp;&nbsp;&nbsp;>@RandomVariate[X, 100] + 1}]||with(Statistics): _
 _
X := RandomVariable(Normal(0, 1)); _
x := Sample(X, 100); _
 _
##gray|# null hypothesis is true:## _
TwoSampleTTest(x, Sample(X, 200), 0); _
 _
##gray|# alternative hypothesis is false:## _
TwoSampleTTest(x, Sample(X, 200) +~ 1, 0);|| || || ||
||[[# paired-sample-t-test]][#paired-sample-t-test-note paired sample t-test] _
##gray|//population has same mean across measurements//##|| || || || || ||
||[[# one-sample-binomial-test]][#one-sample-binomial-test-note one-sample binomial test] _
##gray|//binomial variable parameter are as given//##|| || || || || ||
||[[# two-sample-binomial-test]][#two-sample-binomial-test-note two-sample binomial test] _
##gray|//parameters of two binomial variables are equal//##|| || || || || ||
||[[# chi-squared-test]][#chi-squared-test-note chi-squared test] _
##gray|//parameters of multinomial variable are all equal//##|| || || || || ||
||[[# poisson-test]][#poisson-test-note poisson test] _
##gray|//parameter of poisson variable is as given//##|| || || || || ||
||[[# f-test]][#f-test-note F test] _
##gray|//ratio of variance of normal variables are the same//##||X = NormalDistribution[0, 1] _
Y = NormalDistribution[0, 2] _
 _
##gray|(* null hypothesis is true: *)## _
FisherRatioTest[ _
@<&nbsp;&nbsp;>@{RandomVariate[X, 100], _
@<&nbsp;&nbsp;&nbsp;>@RandomVariate[X, 200]}] _
 _
##gray|(* alternative hypothesis is true: *)## _
FisherRatioTest[ _
@<&nbsp;&nbsp;>@{RandomVariate[X, 100], _
@<&nbsp;&nbsp;&nbsp;>@RandomVariate[Y, 100]}]||with(Statistics); _
 _
X := RandomVariable(Normal(0, 1)); _
Y := RandomVariable(Normal(0, 2)); _
x := Sample(X, 100); _
 _
##gray|# null hypothesis is true:## _
TwoSampleFTest(x, Sample(X, 100), 1); _
 _
##gray|# alternative hypothesis is true:## _
TwoSampleFTest(x, Sample(Y, 100), 1);|| || || ||
||[[# pearson-product-moment-test]][#pearson-product-moment-test-note pearson product moment test] _
##gray|//normal variables are not correlated//##||X = NormalDistrubtion[0, 1] _
x = RandomVariate[X, 100] _
y = RandomVariate[X, 100] _
x2 = x + RandomVariate[X, 100] _
data1 = Inner[List, x, y, List] _
data2 = Inner[List, x, x2, List] _
 _
##gray|(* null hypothesis is true: *)## _
CorrelationTest[data1, 0, "PearsonCorrelation"] _
 _
##gray|(* alternative hypothesis is true: *)## _
CorrelationTest[data2, 0, "PearsonCorrelation"]|| || || || ||
||[[# spearman-rank-test]][#spearman-rank-test-note spearman rank test] _
##gray|//variables are not correlated//##||X = UniformDistribution[{0, 1}] _
x = RandomVariate[X, 100] _
y = RandomVariate[X, 100] _
x2 = x + RandomVariate[X, 100] _
data1 = Inner[List, x, y, List] _
data2 = Inner[List, x, x2, List] _
 _
##gray|(* null hypothesis is true: *)## _
CorrelationTest[data1, 0, "SpearmanRank"] _
 _
##gray|(* alternative hypothesis is true: *)## _
CorrelationTest[data2, 0, "SpearmanRank"]|| || || || ||
||[[# shapiro-wilk-test]][#shapiro-wilk-test-note shapiro-wilk test] _
##gray|//variable has normal distribution//##||X = NormalDistribution[0, 1] _
Y = UniformDistribution[{0, 1}] _
 _
##gray|(* null hypothesis is true: *)## _
ShapiroWilkTest[RandomVariate[X, 100]] _
 _
##gray|(* alternative hypothesis is true: *)## _
ShapiroWilkTest[RandomVariate[Y, 100]]||with(Statistics); _
 _
X := RandomVariable(Normal(0, 1)); _
Y := RandomVariable(Uniform(0, 1)); _
 _
##gray|# null hypothesis is true:## _
ShapiroWilkWTest(Sample(X, 100)); _
 _
##gray|# alternative hypothesis is true:## _
ShapiroWilkWTest(Sample(Y, 100));||load(distrib); load(stats); _
 _
x: makelist( _
@<&nbsp;&nbsp;>@random_normal(0, 1), _
@<&nbsp;&nbsp;>@i, 1, 100); _
y: makelist( _
@<&nbsp;&nbsp;>@random_continuous_uniform(-1/2, 1/2), _
@<&nbsp;&nbsp;>@i, 1, 100); _
 _
##gray|/* null hypothesis is true: */## _
test_normality(x); _
 _
##gray|/* alternative hypothesis is true: */## _
test_normality(y);|| || ||
||[[# bartletts-test]][#bartletts-test-note bartlett's test] _
##gray|//two or more normal variables have same variance//##|| || || || || ||
||[[# levene-test]][#levene-test-note levene's test] _
##gray|//two or more variables have same variance//##||X = NormalDistribution[0, 1] _
Y = NormalDistribution[0, 2] _
 _
##gray|(* null hypothesis is true: *)## _
LeveneTest[ _
@<&nbsp;&nbsp;>@{RandomVariate[X, 100], _
@<&nbsp;&nbsp;&nbsp;>@RandomVariate[X, 200]}] _
 _
##gray|(* alternative hypothesis is true: *)## _
LeveneTest[ _
@<&nbsp;&nbsp;>@{RandomVariate[X, 100], _
@<&nbsp;&nbsp;&nbsp;>@RandomVariate[Y, 100]}]|| || || || ||
||[[# one-way-anova]][#one-way-anova-note one-way anova] _
##gray|//two or more normal variables have same mean//##||Needs["ANOVA`"] _
 _
X = NormalDistribution[0, 1] _
ones = Table[1, {i, 1, 100}] _
x1 = Inner[ _
@<&nbsp;&nbsp;>@List, ones, RandomVariate[X, 100], List] _
x2 = Inner[ _
@<&nbsp;&nbsp;>@List, 2 * ones, RandomVariate[X, 100], List] _
x3 = Inner[ _
@<&nbsp;&nbsp;>@List, 3 * ones, RandomVariate[X, 100], List] _
y = Inner[ _
@<&nbsp;&nbsp;>@List, _
@<&nbsp;&nbsp;>@3 * ones, _
@<&nbsp;&nbsp;>@RandomVariate[X, 100] + 0.5, _
@<&nbsp;&nbsp;>@List] _
 _
##gray|(* null hypothesis is true: *)## _
ANOVA[Join[x1, x2, x3]] _
 _
##gray|(* alternative hypothesis is true: *)## _
ANOVA[Join[x1, x2, y]]|| || || || ||
||[[# two-way-anova]][#two-way-anova-note two-way anova]|| || || || || ||
||||||||||||~ [[# bar-charts]][#bar-charts-note bar charts]||
||~ ||~ mathematica||~ maple||~ maxima||~ sage||~ sympy||
||[[# vertical-bar-chart]][[image http://cdn.hyperpolyglot.org/images/vertical-bar-chart.jpg]] _
[#vertical-bar-chart-note vertical bar chart]||BarChart[{7, 3, 8, 5, 5}, _
@<&nbsp;&nbsp;>@ChartLegends-> _
@<&nbsp;&nbsp;&nbsp;&nbsp;>@{"a","b","c","d","e"}]||with(Statistics): _
 _
ColumnGraph( _
@<&nbsp;&nbsp;>@["a" =7, "b"=3, "c"=8, "d"=5, "e"=5]);||x: [7, 3, 8, 5, 5]; _
labs: [a, b, c, d, e]; _
data: makelist(makelist(labs[i], j, x[i]), i, 5); _
wxbarsplot(flatten(data));|| || ||
||[[# horizontal-bar-chart]][[image http://cdn.hyperpolyglot.org/images/horizontal-bar-chart.jpg]] _
[#horizontal-bar-chart-note horizontal bar chart]||BarChart[{7, 3, 8, 5, 5}, BarOrigin -> Left]||with(Statistics): _
 _
BarChart(["a"=7, "b"=3, "c"=8, "d"=5, "e"=5]);||##gray|//none//##|| || ||
||[[# grouped-bar-chart]][[image http://cdn.hyperpolyglot.org/images/grouped-bar-chart.jpg]] _
[#grouped-bar-chart-note grouped bar chart]||data = @@{{@@7, 1}, {3, 2}, {8, 1}, {5, 3}, {5, 1@@}}@@ _
BarChart[data]||with(Statistics): _
 _
ColumnGraph([[7, 3, 8, 5, 5], [1, 2, 1, 3, 1]]);||x: [7, 3, 8, 5, 5]; _
y: [1,2,1,3,1]; _
labs: [a, b, c, d, e]; _
d1: makelist(makelist(labs[i], j, x[i]), i, 5); _
d2: makelist(makelist(labs[i], j, y[i]), i, 5); _
wxbarsplot(flatten(d1), flatten(d2));|| || ||
||[[# stacked-bar-chart]][[image http://cdn.hyperpolyglot.org/images/stacked-bar-chart.jpg]] _
[#stacked-bar-chart-note stacked bar chart]||data = @@{{@@7, 1}, {3, 2}, {8, 1}, {5, 3}, {5, 1@@}}@@ _
BarChart[data, ChartLayout -> "Stacked"]||with(Statistics): _
 _
ColumnGraph([[7, 3, 8, 5, 5], [1, 2, 1, 3, 1]], _
@<&nbsp;&nbsp;>@format = stacked);||x: [7, 3, 8, 5, 5]; _
y: [1,2,1,3,1]; _
labs: [a, b, c, d, e]; _
d1: makelist(makelist(labs[i], j, x[i]), i, 5); _
d2: makelist(makelist(labs[i], j, y[i]), i, 5); _
wxbarsplot(flatten(d1), flatten(d2), _
@<&nbsp;&nbsp;>@grouping=stacked);|| || ||
||[[# pie-chart]][[image http://cdn.hyperpolyglot.org/images/pie-chart.jpg]] _
[#pie-chart-note pie chart]||PieChart[{7, 3, 8, 5, 5}]||with(Statistics): _
 _
PieChart(["a"=7, "b"=3, "c"=8, "d"=5, "e"=5]);||x: [7, 3, 8, 5, 5]; _
labs: [a, b, c, d, e]; _
data: makelist(makelist(labs[i], j, x[i]), i, 5); _
wxpiechart(flatten(data));|| || ||
||[[# histogram]][[image http://cdn.hyperpolyglot.org/images/histogram.jpg]] _
[#histogram-note histogram]||X = NormalDistribution[0, 1] _
##gray|(* 2nd arg is approx number of bins: *)## _
Histogram[RandomReal[X, 100], 10]||with(Statistics): _
 _
X := RandomVariable(Normal(0, 1)); _
Histogram(Sample(X, 100));||load(distrib); _
 _
data: makelist(random_normal(0, 1), i, 1, 100); _
wxhistogram(data);|| || ||
||[[# box-plot]][[image http://cdn.hyperpolyglot.org/images/box-plot.jpg]] _
[#box-plot-note box plot]||X = NormalDistribution[0, 1] _
n100 = RandomVariate[X, 100] _
BoxWhiskerChart[n100] _
 _
Y = ExponentialDistribution[1] _
e100 = RandomVariate[Y, 100] _
u100 = RandomReal[1, 100] _
data = {n100, e100, u100} _
BoxWhiskerChart[data]||with(Statistics): _
 _
X := RandomVariable(Normal(0, 1)); _
BoxPlot(Sample(X, 100));||load(distrib); _
 _
data: makelist(random_normal(0, 1), i, 1, 100); _
wxboxplot(data);|| || ||
||||||||||||~ [[# scatter-plots]][#scatter-plots-note scatter plots]||
||~ ||~ mathematica||~ maple||~ maxima||~ sage||~ sympy||
||[[# strip-chart]][[image http://cdn.hyperpolyglot.org/images/strip-chart.jpg]] _
[#strip-chart-note strip chart]||X = NormalDistribution[0, 1] _
data = {RandomReal[X], 0} & /@ Range[1, 50] _
ListPlot[data]||with(Statistics): _
 _
X := RandomVariable(Normal(0, 1)); _
ScatterPlot(Sample(X, 50), [0$i = 1 .. 50]);|| || || ||
||[[# strip-chart-jitter]][[image http://cdn.hyperpolyglot.org/images/strip-chart-jitter.jpg]] _
[#strip-chart-jitter-note strip chart with jitter]||X = NormalDistribution[0, 1] _
Y = UniformDistribution[{-0.05, 0.05}] _
data = {RandomReal[X], RandomReal[Y]} & /@ _
@<&nbsp;&nbsp;>@Range[1, 50] _
ListPlot[data, _
@<&nbsp;&nbsp;>@PlotRange -> {Automatic, {-1, 1}}]||with(Statistics): _
 _
X := RandomVariable(Normal(0, 1)); _
ScatterPlot(Sample(X, 50), _
@<&nbsp;&nbsp;>@jitter = true, _
@<&nbsp;&nbsp;>@view = [-2 .. 2, -19 .. 20]);|| || || ||
||[[# scatter-plot]][[image http://cdn.hyperpolyglot.org/images/scatter-plot.jpg]] _
[#scatter-plot-note scatter plot]||X = NormalDistribution[0, 1] _
rand = Function[RandomReal[X]] _
data = {rand[], rand[]} & /@ Range[1, 50] _
ListPlot[data]||with(Statistics): _
 _
X := RandomVariable(Normal(0, 1)); _
ScatterPlot(Sample(X, 50), Sample(X, 50));||load(distrib); _
 _
x: makelist(random_normal(0, 1), i, 1, 50); _
y: makelist(random_normal(0, 1), i, 1, 50); _
wxplot2d([discrete, x, y], [style, points]);|| || ||
||[[# additional-point-set]][[image http://cdn.hyperpolyglot.org/images/additional-point-set.jpg]] _
[#additional-point-set-note additional point set]||X = NormalDistribution[0, 1] _
rand = Function[RandomReal[X]] _
data1 = {rand[], rand[]} & /@ Range[1, 50] _
data2 = {rand[]+1, rand[]+1} & /@ Range[1, 50] _
Show[ListPlot[data1], _
@<&nbsp;&nbsp;>@ListPlot[data2, PlotStyle -> Red]]||with(Statistics): _
with(plots): _
 _
X := RandomVariable(Normal(0, 1)); _
p1 := plot(Sample(X, 50), Sample(X, 50), _
@<&nbsp;&nbsp;>@color = black, style = point); _
p2 := plot(Sample(X, 50) +~ 1, _
@<&nbsp;&nbsp;>@Sample(X, 50) +~ 1, color = red, _
@<&nbsp;&nbsp;>@style = point); _
display([p1, p2]);||load(distrib); _
 _
x1: makelist(random_normal(0, 1), i, 1, 50); _
y1: makelist(random_normal(0, 1), i, 1, 50); _
x2: makelist(random_normal(0, 1), i, 1, 50) + 1; _
y2: makelist(random_normal(0, 1), i, 1, 50); + 1; _
wxplot2d([[discrete, x1, y1], _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@[discrete, x2, y2]], _
@<&nbsp;&nbsp;>@[style, points], [color, black, red]);|| || ||
||[[# point-types]][#point-types-note point types]||ListPlot[data, PlotMarkers -> {"*"}] _
 _
##gray|(* shows standard sequence of point types: *)## _
Graphics`PlotMarkers[] _
 _
##gray|(* The elements of the PlotMarkers array can be strings, symbols, expressions, or images. *)##||ScatterPlot(Sample(X, 50), Sample(X, 50), _
@<&nbsp;&nbsp;>@symbol = asterisk); _
 _
##gray|(* possible symbol values: _
 _
@<&nbsp;&nbsp;>@asterisk _
@<&nbsp;&nbsp;>@box _
@<&nbsp;&nbsp;>@circle _
@<&nbsp;&nbsp;>@cross _
@<&nbsp;&nbsp;>@diagonalcross _
@<&nbsp;&nbsp;>@diamond _
@<&nbsp;&nbsp;>@point _
@<&nbsp;&nbsp;>@solidbox _
@<&nbsp;&nbsp;>@solidcircle _
@<&nbsp;&nbsp;>@soliddiamond _
*)##||wxplot2d([discrete, x, y], _
@<&nbsp;&nbsp;>@[style, points], _
@<&nbsp;&nbsp;>@[point_type, asterisk]); _
 _
##gray|/* possible point_type values: _
 _
@<&nbsp;&nbsp;>@asterisk _
@<&nbsp;&nbsp;>@box _
@<&nbsp;&nbsp;>@bullet _
@<&nbsp;&nbsp;>@circle _
@<&nbsp;&nbsp;>@diamond _
@<&nbsp;&nbsp;>@plus _
@<&nbsp;&nbsp;>@square _
@<&nbsp;&nbsp;>@times _
@<&nbsp;&nbsp;>@triangle _
 _
The bullet and box are filled versions of circle and square. _
*/##|| || ||
||[[# point-size]][#point-size-note point size]||X = NormalDistribution[0, 1] _
rand = Function[RandomReal[X]] _
data = {rand[], rand[]} & /@ Range[1, 50] _
##gray|(* point size is fraction of plot width: *)## _
ListPlot[data, PlotStyle -> {PointSize[0.03]}]|| || || || ||
||[[# scatter-plot-matrix]][[image http://cdn.hyperpolyglot.org/images/scatter-plot-matrix.jpg]] _
[#scatter-plot-matrix-note scatter plot matrix]||Needs["StatisticalPlots@@`@@"] _
 _
X = NormalDistribution[0, 1] _
x = RandomReal[X, 50] _
y = RandomReal[X, 50] _
z = x + 3 * y _
w = y + RandomReal[X, 50] _
PairwiseScatterPlot[Transpose[{x, y, z, w}]]|| ||load(distrib); _
 _
x: makelist(random_normal(0, 1), i, 1, 50); _
y: makelist(random_normal(0, 1), i, 1, 50); _
z: x + 3 * y; _
w: y + makelist(random_normal(0, 1), i, 1, 50); _
wxscatterplot(transpose(matrix(x, y, z, w)));|| || ||
||[[# scatter-plot-3d]][[image http://cdn.hyperpolyglot.org/images/scatter-plot-3d.jpg]] _
[#scatter-plot-3d-note 3d scatter plot]||X = NormalDistribution[0, 1] _
data = RandomReal[X, {50, 3}] _
ListPointPlot3D[data]||with(Statistics): _
 _
X := RandomVariable(Normal(0, 1)); _
ScatterPlot3D([[Sample(X, 50)], [Sample(X, 50)], _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@[Sample(X, 50)]]);||##gray|//none//##|| || ||
||[[# bubble-chart]][[image http://cdn.hyperpolyglot.org/images/bubble-chart.jpg]] _
[#bubble-chart-note bubble chart]||X = NormalDistribution[0, 1] _
data = RandomReal[X, {50, 3}] _
BubbleChart[data]||with(Statistics); _
 _
X := RandomVariable(Normal(0, 1)); _
Z := RandomVariable(DiscreteUniform(1, 10)); _
##gray|# appears to ignore the 3rd argument and _
# make a scatter plot:## _
BubblePlot(Sample(X, 50), Sample(X, 50), _
@<&nbsp;&nbsp;>@Sample(Z, 50));|| || || ||
||[[# linear-regression-line]][[image http://cdn.hyperpolyglot.org/images/linear-regression-line.jpg]] _
[#linear-regression-line-note linear regression line]||data = Table[{i, 2 * i + RandomReal[{-5, 5}]}, _
@<&nbsp;&nbsp;>@{i, 0, 20}] _
model = LinearModelFit[data, x, x] _
Show[ListPlot[data], _
@<&nbsp;&nbsp;>@Plot[model["BestFit"], _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@{x, 0, 20}]]||with(Statistics); _
 _
X := RandomVariable(Normal(0, 1)); _
x := [i$i = 1 .. 100]; _
y := x +~ 10 * Sample(X, 100); _
ScatterPlot(x, y, fit = [a*t+b, t]);||load(distrib); _
load(lsquares); _
 _
X: makelist(i, i, 50); _
Y: makelist(X[i] + random_normal(0, 1), i, 50); _
M: transpose(matrix(X, Y)); _
fit: lsquares_estimates(M, [x, y], y = A*x + B, _
@<&nbsp;&nbsp;>@[A, B]); _
A: second(fit[1][1]), numer; _
B: second(fit[1][2]), numer; _
Xhat: makelist(A*X[i] + B, i, 50); _
wxplot2d([[discrete, X, Y], [discrete, X, Xhat]], _
@<&nbsp;&nbsp;>@[style, points, lines], [color, black, red]);|| || ||
||[[# q-q-plot]][[image http://cdn.hyperpolyglot.org/images/q-q-plot.jpg]] _
[#q-q-plot-note quantile-quantile plot]||X = NormalDistribution[0, 1] _
data1 = RandomReal[1, 50] _
data2 = RandomReal[X, 50] _
QuantilePlot[data1, data2]||with(Statistics): _
 _
X := RandomVariable(Normal(0, 1)); _
Y := RandomVariable(Uniform(0, 1)); _
QuantilePlot(Sample(X, 200), Sample(Y, 200));||load(distrib); _
 _
x: makelist(random_continuous_uniform(0, 1), _
@<&nbsp;&nbsp;>@i, 200); _
y: makelist(random_normal(0, 1), i, 200); _
wxplot2d([discrete, sort(x), sort(y)], _
@<&nbsp;&nbsp;>@[style, points]);|| || ||
||||||||||||~ [[# line-charts]][#line-charts-note line charts]||
||~ ||~ mathematica||~ maple||~ maxima||~ sage||~ sympy||
||[[# polygonal-line-plot]][[image http://cdn.hyperpolyglot.org/images/polygonal-line-plot.jpg]] _
[#polygonal-line-plot-note polygonal line plot]||X = NormalDistribution[0, 1] _
rand = Function[RandomReal[X]] _
f = Function[i, {i, rand[]}] _
data = f /@ Range[1, 20] _
ListLinePlot[data]||with(Statistics): _
 _
X := RandomVariable(Normal(0, 1)); _
pts := Sample(X, 20); _
plot([i$i = 1 .. 20], pts);||load(distrib); _
 _
x: makelist(random_normal(0, 1), i, 1, 20); _
wxplot2d([discrete, makelist(i, i, 20), x]);|| || ||
||[[# additional-line]][[image http://cdn.hyperpolyglot.org/images/additional-line.jpg]] _
[#additional-line-note additional line]||X = NormalDistribution[0, 1] _
data1 = RandomReal[X, 20] _
data2 = RandomReal[X, 20] _
ListLinePlot[{data1, data2} _
@<&nbsp;&nbsp;>@PlotStyle->{Black, Red}]||with(Statistics): _
with(plots): _
 _
X := RandomVariable(Normal(0, 1)); _
p1 := plot([i$i = 1 .. 50], Sample(X, 50), _
@<&nbsp;&nbsp;>@color = black); _
p2 := plot([i$i = 1 .. 50], Sample(X, 50), _
@<&nbsp;&nbsp;>@color = red); _
display(p1, p2);||load(distrib); _
 _
x: makelist(random_normal(0, 1), i, 1, 20); _
y: makelist(random_normal(0, 1), i, 1, 20); _
wxplot2d([[discrete, makelist(i, i, 20), x], _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@[discrete, makelist(i, i, 20), y]], _
@<&nbsp;&nbsp;>@[color, black, red]);|| || ||
||[[# line-types]][#line-types-note line types]||ListLinePlot[data, PlotStyle -> Dashed] _
 _
##gray|(* PlotStyle values: _
 _
@<&nbsp;&nbsp;>@Dashed _
@<&nbsp;&nbsp;>@DotDashed _
@<&nbsp;&nbsp;>@Dotted _
*)##||with(Statistics): _
 _
X := RandomVariable(Normal(0, 1)); _
plot([i$i = 1 .. 50], Sample(X, 50), _
@<&nbsp;&nbsp;>@linestyle = dot); _
 _
##gray|(* linestyle values: _
 _
@<&nbsp;&nbsp;>@solid _
@<&nbsp;&nbsp;>@dot _
@<&nbsp;&nbsp;>@dash _
@<&nbsp;&nbsp;>@dashdot _
@<&nbsp;&nbsp;>@longdash _
@<&nbsp;&nbsp;>@spacedash _
@<&nbsp;&nbsp;>@spacedot _
*)##||##gray|//none//##|| || ||
||[[# line-thickness]][#line-thickness-note line thickness]||X = NormalDistribution[0, 1] _
data1 = RandomReal[X, 20] _
data2 = RandomReal[X, 20] _
##gray|(* thickness is fraction of plot width: *)## _
ListLinePlot[{data1, data2}, _
@<&nbsp;&nbsp;>@PlotStyle -> {Thickness[0.01], Thickness[0.02]}]||with(Statistics); _
with(plots); _
 _
X := RandomVariable(Normal(0, 1)); _
p1 := plot([i$i = 1 .. 50], Sample(X, 50), _
@<&nbsp;&nbsp;>@thickness = 1); _
p2 := plot([i$i = 1 .. 50], Sample(X, 50), _
@<&nbsp;&nbsp;>@thickness = 3); _
display(p1, p2)|| || || ||
||[[# function-plot]][[image http://cdn.hyperpolyglot.org/images/function-plot.jpg]] _
[#function-plot-note function plot]||Plot[Sin[x], {x, -4, 4}]||plot(sin(x), x = -4 .. 4);||wxplot2d(sin(x), [x, -4, 4]);|| || ||
||[[# parametric-plot]][[image http://cdn.hyperpolyglot.org/images/parametric-plot.jpg]] _
[#parametric-plot-note parametric plot]||ParametricPlot[{Sin[u], Sin[2 * u]}, _
@<&nbsp;&nbsp;>@{u, 0, 2 * Pi}]||plot([sin(t), sin(2*t), t = 0 .. 2*Pi]);||wxplot2d([parametric, sin(t), sin(2*t), _
@<&nbsp;&nbsp;>@[t, 0, 2*%pi]]);|| || ||
||[[# implicit-plot]][[image http://cdn.hyperpolyglot.org/images/implicit-plot.jpg]] _
[#implicit-plot-note implicit plot]||ContourPlot[x^2 + y^2 == 1, {x, -1, 1}, _
@<&nbsp;&nbsp;>@{y, -1, 1}]||with(plots, implicitplot); _
 _
implicitplot(x^2+y^2 = 1, x = -1 .. 1, _
@<&nbsp;&nbsp;>@y = -1 .. 1);||load(implicit_plot); _
 _
wximplicit_plot(x^2 + y^2 = 1, [x, -1, 1], _
@<&nbsp;&nbsp;>@[y, -1, 1]);|| || ||
||[[# polar-plot]][[image http://cdn.hyperpolyglot.org/images/polar-plot.jpg]] _
[#polar-plot-note polar plot]||PolarPlot[Sin[3 * t], {t, 0, Pi}]||with(plots): _
 _
polarplot(sin(3*u), u = 0 .. Pi);||f(x) := sin(3 * x); _
wxplot2d([parametric, cos(t)*f(t), sin(t)*f(t), _
@<&nbsp;&nbsp;>@[t, 0, %pi]]);|| || ||
||[[# cubic-spline]][[image http://cdn.hyperpolyglot.org/images/cubic-spline.jpg]] _
[#cubic-spline-note cubic spline]||X = NormalDistribution[0, 1] _
data = Table[{i, RandomReal[X]}, _
@<&nbsp;&nbsp;>@{i, 0, 20}] _
f = Interpolation[data, _
@<&nbsp;&nbsp;>@InterpolationOrder -> 3] _
Show[ListPlot[data], _
@<&nbsp;&nbsp;>@Plot[f[x], {x, 0, 20}]]||with(CurveFitting): _
with(Statistics): _
 _
X := RandomVariable(Normal(0, 1)); _
x := [i$i = 1 .. 20]; _
y := convert(Sample(X, 20), list); _
plot(Spline(zip(@@`[]`@@, x, y), z), z = 0 .. 21);||load(interpol); _
load(distrib); _
load(draw); _
 _
data: makelist([i, random_normal(0, 1)], i, 20); _
cspline(data); _
f(x):=@@''@@%; _
wxdraw2d(explicit(f(x),x,0,20));|| || ||
||[[# area-chart]][[image http://cdn.hyperpolyglot.org/images/area-chart.jpg width="75px"]] _
[#area-chart-note area chart]||data = @@{{@@7, 1, 3, 2, 8}, {1, 5, 3, 5, 1@@}}@@ _
stacked = {data[[1]], data[[1]] + data[[2]]} _
ListLinePlot[stacked, Filling -> _
@<&nbsp;&nbsp;>@{1 -> {Axis, LightBlue}, _
@<&nbsp;&nbsp;&nbsp;>@2 -> @@{{@@1}, LightRed}}]||with(Statistics): _
 _
AreaChart([[7, 1, 3, 2, 8], [1, 5, 3, 5, 1]], _
@<&nbsp;&nbsp;>@format = stacked);|| || || ||
||||||||||||~ [[# surface-charts]][#surface-charts-note surface charts]||
||~ ||~ mathematica||~ maple||~ maxima||~ sage||~ sympy||
||[[# contour-plot]][[image http://cdn.hyperpolyglot.org/images/contour-plot.jpg]] _
[#contour-plot-note contour plot]||##gray|(* of function: *)## _
ContourPlot[x * (y - 1), {x, 0, 10}, _
@<&nbsp;&nbsp;>@{y, 0, 10}] _
 _
##gray|(* of data: *)## _
X = NormalDistribution[0, 1] _
rand = Function[RandomReal[X]] _
data = Table[x * (y - 1) + 5 * rand[], _
@<&nbsp;&nbsp;>@{x, 0, 10}, {y, 0, 10}] _
ListContourPlot[data]||with(plots): _
 _
contourplot(x*(y-1), x = 0 .. 10, y = 0 .. 10);||wxcontour_plot(x * (y-1), [x, 0, 10], _
@<&nbsp;&nbsp;>@[y, 0, 10]);|| || ||
||[[# heat-map]][[image http://cdn.hyperpolyglot.org/images/heat-map.jpg]] _
[#heat-map-note heat map]||##gray|(* of function: *)## _
DensityPlot[Sin[x] * Sin[y], _
@<&nbsp;&nbsp;>@{x, -4, 4}, _
@<&nbsp;&nbsp;>@{y, -4, 4}] _
 _
##gray|(* of data: *)## _
X = NormalDistribution[0, 1] _
rand = Function[RandomReal[X]] _
data = Table[x * y + 10 * rand[], _
@<&nbsp;&nbsp;>@{x, 1, 10}, _
@<&nbsp;&nbsp;>@{y, 1, 10}] _
ListDensityPlot[data]||with(plots): _
 _
densityplot(sin(x)*sin(y), x = -4..4, y = -4..4);||wxplot3d (sin(x) * sin(y), [x,-4,4], [y,-4,4], _
@<&nbsp;&nbsp;>@[elevation, 0], [azimuth, 0], _
@<&nbsp;&nbsp;>@[grid, 100, 100], [mesh_lines_color, false]);|| || ||
||[[# shaded-surface-plot]][[image http://cdn.hyperpolyglot.org/images/shaded-surface-plot.jpg]] _
[#shaded-surface-plot-note shaded surface plot]||Plot3D[Exp[-(x^2 + y^2)], {x, -2, 2}, _
@<&nbsp;&nbsp;>@{y, -2, 2}, MeshStyle -> None]||plot3d(exp(-x^2-y^2), x = -2 .. 2, _
@<&nbsp;&nbsp;>@y = -2 .. 2, style = surface);|| || || ||
||[[# light-source]][#light-source-note light source]||lot3D[Exp[-(x^2 + y^2)], _
@<&nbsp;&nbsp;>@{x, -2, 2}, {y, -2, 2}, _
@<&nbsp;&nbsp;>@MeshStyle -> None,  _
@<&nbsp;&nbsp;>@Lighting -> @@{{"Point", White, {5, -5, 5}}}@@]|| || || || ||
||[[# mesh-surface-plot]][[image http://cdn.hyperpolyglot.org/images/mesh-surface-plot.jpg]] _
[#mesh-surface-plot-note mesh surface plot]||Plot3D[Exp[-(x^2 + y^2)], {x, -2, 2}, _
@<&nbsp;&nbsp;>@{y, -2, 2},  Lighting -> {White}, _
@<&nbsp;&nbsp;>@PlotStyle -> White]||plot3d(exp(-x^2-y^2), x = -2 .. 2, _
@<&nbsp;&nbsp;>@y = -2 .. 2, style = wireframe)||wxplot3d(exp(-(x^2 + y^2)), _
@<&nbsp;&nbsp;>@[x, -2, 2], [y, -2, 2], _
@<&nbsp;&nbsp;>@[palette, false], [color, black]);|| || ||
||[[# view-point]][#view-point-note view point]||##gray|(* (x, y, z) coordinates; _
@<&nbsp;&nbsp;&nbsp;>@(0, 0, 3) is from above: *)## _
Plot3D[Exp[-(x^2 + y^2)], _
@<&nbsp;&nbsp;>@{x, -2, 2}, {y, -2, 2}, _
@<&nbsp;&nbsp;>@MeshStyle -> None, _
@<&nbsp;&nbsp;>@ViewPoint -> {0, 0, 3}]|| || || || ||
||[[# vector-field-plot]][[image http://cdn.hyperpolyglot.org/images/vector-field-plot.jpg]] _
[#vector-field-plot-note vector field plot]||StreamPlot[{x^2 + y, 1 + x - y^2}, {x, -4, 4}, {y, -4, 4}]||with(plots): _
 _
fieldplot([x^2 + y, y^2 + x + 1], _
@<&nbsp;&nbsp;>@x = -4 .. 4, y = -4 .. 4);||plotdf([x^2 + y, 1 + x - y^2], [x, -4, 4], _
@<&nbsp;&nbsp;>@[y, -4, 4]);|| || ||
||||||||||||~ [[# chart-options]][#chart-options-note chart options]||
||~ ||~ mathematica||~ maple||~ maxima||~ sage||~ sympy||
||[[# chart-title]][#chart-title-note chart title]||##gray|(* title on top by default *)## _
Plot[Sin[x], {x, -4, 4}, _
@<&nbsp;&nbsp;>@PlotLabel -> "title example"]||##gray|# title on top; caption on bottom## _
 _
plot(sin(x), title = "title example", _
@<&nbsp;&nbsp;>@caption = "caption example")||wxplot2d(sin(x), [x, -4, 4], _
@<&nbsp;&nbsp;>@[title, "title example"]); _
 _
data: 1, 1, 2, 2, 3, 3, 3, 3, 4]; _
wxboxplot(data, title="title example"); _
 _
##gray|/* title on top by default */##|| || ||
||[[# axis-label]][#axis-label-note axis label]||data = Table[{i, i^2}, {i, 1, 20}] _
ListLinePlot[data, AxesLabel -> {x, x^2}]||plot([i$i = 1 .. 20], [i*i$i = 1 .. 20], _
@<&nbsp;&nbsp;>@labels = [x, x^2]);||x: makelist(i, i, 20); _
y: makelist(i^2, i, 20); _
wxplot2d([discrete, x, y], _
@<&nbsp;&nbsp;>@[xlabel, "x"], [ylabel, "x^2"]);|| || ||
||[[# legend]][[image http://cdn.hyperpolyglot.org/images/legend.jpg]] _
[#legend-note legend]||X = NormalDistribution[0, 1] _
data1 = RandomReal[X, 20] _
data2 = RandomReal[X, 20] _
ListLinePlot[{data1, data2}, _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@PlotLegends -> {"first", "second"}]||with(Statistics); _
with(plots); _
 _
X := RandomVariable(Normal(0, 1)); _
p1 := plot([i$i = 1 .. 50], Sample(X, 50), _
@<&nbsp;&nbsp;>@color = black, legend = "first"); _
p2 := plot([i$i = 1 .. 50], Sample(X, 50), _
@<&nbsp;&nbsp;>@color = red, legend = "second"); _
display(p1, p2)||##gray|/* wxplot2d includes a legend by default. _
 _
Provide [legend, false] as argument to suppress it. */##|| || ||
||[[# data-label]][#data-label-note data label]||data = @@{{@@313, 3.7}, {62, .094}, {138, 6.6}, _
@<&nbsp;&nbsp;>@{113, 0.76}, {126, 0.15}} _
 _
##gray|(* The {0, -1} argument of Text[] centers the label above the data point. *)## _
Show[ListPlot[data, _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@AxesLabel -> {"pop", "area"}], _
@<&nbsp;&nbsp;>@Graphics[Text["USA", data[[1]], {0, -1}]], _
@<&nbsp;&nbsp;>@Graphics[Text["UK", data[[2]], {0, -1}]],  _
@<&nbsp;&nbsp;>@Graphics[Text["Russia", data[[3]], {0, -1}]],  _
@<&nbsp;&nbsp;>@Graphics[Text["Mexico", data[[4]], {0, -1}]], _
@<&nbsp;&nbsp;>@Graphics[Text["Japan", data[[5]], {0, -1}]]]|| || || || ||
||[[# named-colors]][#named-colors-note named colors]||White Gray Black Transparent _
 _
Blue Brown Cyan Green Magenta Orange Pink Purple Red Yellow _
 _
LightBlue LightBrown LightCyan LightGray LightGreen LightMagenta LightOrange LightPink LightPurple LightRed LightYellow||aquamarine black blue brown coral cyan gold gray green grey khaki magenta maroon navy orange pink plum red sienna tan turquoise violet wheat white yellow _
 _
White WhiteSmoke LightGray LightGrey DarkGray DarkGrey Gray Grey DimGray DimGrey Black _
 _
AliceBlue AntiqueWhite Aqua Aquamarine Azure Beige Bisque BlanchedAlmond Blue BlueViolet Brown Burlywood CadetBlue Chartreuse Chocolate Coral CornflowerBlue Cornsilk Crimson Cyan DeepPink DeepSkyBlue DodgerBlue Feldspar Firebrick FloralWhite ForestGreen Fuchsia Gainsboro GhostWhite Gold Goldenrod Green GreenYellow Honeydew HotPink IndianRed Indigo Ivory Khaki Lavender LavenderBlush LawnGreen LemonChiffon Lime LimeGreen Linen Magenta Maroon MediumAquamarine MediumBlue MediumOrchid MediumPurple MediumSeaGreen MediumSlateBlue MediumSpringGreen MediumTurquoise MediumVioletRed MidnightBlue MintCream MistyRose Moccasin NavajoWhite Navy NavyBlue OldLace Olive OliveDrab Orange OrangeRed Orchid PaleGoldenrod PaleGreen PaleTurquoise PaleVioletRed PapayaWhip PeachPuff Peru Pink Plum PowderBlue Purple Red RosyBrown RoyalBlue SaddleBrown Salmon SandyBrown SeaGreen Seashell Sienna Silver SkyBlue SlateBlue SlateGray SlateGrey Snow SpringGreen SteelBlue Tan Teal Thistle Tomato Turquoise Violet VioletRed Wheat Yellow YellowGreen _
 _
DarkBlue DarkCyan DarkGoldenrod DarkGray DarkGreen DarkGrey DarkKhaki DarkMagenta DarkOliveGreen DarkOrange DarkOrchid DarkRed DarkSalmon DarkSeaGreen DarkSlateBlue DarkSlateGray DarkSlateGrey DarkTurquoise DarkViolet _
 _
LightBlue LightCoral LightCyan LightGoldenrod LightGoldenrodYellow LightGray LightGreen LightGrey LightPink LightSalmon LightSeaGreen LightSkyBlue LightSlateBlue LightSlateGray LightSlateGrey LightSteelBlue LightYellow||white gray black _
 _
gray0 gray10 gray100 gray20 gray30 gray40 gray50 gray60 gray70 gray80 gray90 gray100 grey grey0 grey10 grey20 grey30 grey40 grey50 grey60 grey70 grey80 grey90 grey100 _
 _
aquamarine beige blue brown coral cyan forest_green gold goldenrod green khaki magenta medium_blue midnight_blue navy orange orange_red pink plum purple red royalblue salmon sea_green skyblue spring_green turquoise violet yellow _
 _
dark_blue dark_cyan dark_goldenrod dark_gray dark_green dark_grey dark_khaki dark_magenta dark_orange dark_pink dark_red dark_salmon dark_turquoise dark_violet dark_yellow _
 _
light_blue light_coral light_cyan light_goldenrod light_gray light_green light_grey light_magenta light_pink light_red light_salmon light_turquoise light_yellow|| || ||
||[[# rgb-color]][#rgb-color-note rgb color]||RGBColor[1, 0, 0] _
##gray|(* with opacity: *)## _
RGBColor[1, 0, 0, 0.5]||ColorTools:-Color([1, 0, 0])||[color, "#FF0000"]|| || ||
||[[# background-color]][#background-color-note background color]||Plot[Sin[x], {x, 0, 2 Pi}, _
@<&nbsp;&nbsp;>@Background -> Black, _
@<&nbsp;&nbsp;>@PlotStyle -> White, _
@<&nbsp;&nbsp;>@AxesStyle -> White, _
@<&nbsp;&nbsp;>@TicksStyle -> White, _
@<&nbsp;&nbsp;>@GridLines -> Automatic, _
@<&nbsp;&nbsp;>@GridLinesStyle -> White]||p1 := plot([1, -1], x = -4 .. 4, _
@<&nbsp;&nbsp;>@filled = true, _
@<&nbsp;&nbsp;>@color = black, _
@<&nbsp;&nbsp;>@axis = [color = white]); _
p2 := plot(sin(x), x = -4 .. 4, _
@<&nbsp;&nbsp;>@color = white, _
@<&nbsp;&nbsp;>@axis = [color = white]); _
display(p1, p2);|| || || ||
||[[# axis-limits]][#axis-limits-note axis limits]||Plot[x^2, {x, 0, 20}, _
@<&nbsp;&nbsp;>@PlotRange -> @@{{0, 20}, {-200, 500}}@@]||plot([i$i = 1 .. 20], [i*i$i = 1 .. 20], _
@<&nbsp;&nbsp;>@x = 0 .. 20, y = -200 .. 500);|| || || ||
||[[# logarithmic-y-axis]][#logarithmic-y-axis-note logarithmic y-axis]||LogPlot[{x^2, x^3, x^4, x^5}, _
@<&nbsp;&nbsp;>@{x, 0, 20}]||with(plots): _
 _
logplot([x^2, x^3, x^4, x^5], x = 0 .. 20);||x: makelist(i, i, 20); _
wxplot2d([ _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@[discrete, x, makelist(i^2, i, 20)], _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@[discrete, x, makelist(i^3, i, 20)]], _
@<&nbsp;&nbsp;>@[logy, true]);|| || ||
||[[# aspect-ratio]][#aspect-ratio-note aspect ratio]||##gray|(* aspect ratio is height divided by width: *)## _
Plot[Sin[x], {x, 0, 2 Pi}, AspectRatio -> 0.25] _
 _
##gray|(* In the notebook, dragging the corner of an image increases or decreases the size, but aspect ratio is preserved. *)##||##gray|# size is width and height in pixels:## _
plot(sin(x), size = [800, 200]); _
 _
##gray|# In the notebook, dragging the corner _
# of an image can change width and height _
# independently##||wxplot2d(sin(x), [x, -4, 4], _
@<&nbsp;&nbsp;>@[yx_ratio, 0.25]); _
 _
##gray|/* Image size can't be changed in notebook. */##|| || ||
||[[# ticks]][#ticks-note ticks]||Plot[Sin[x], {x, 0, 2 Pi}, Ticks -> None] _
 _
Plot[Sin[x], {x, 0, 2 Pi}, _
@<&nbsp;&nbsp;>@Ticks -> @@{{0, Pi, 2*Pi}, {-1, 0, 1}}@@]||##gray|# rm x and y ticks:## _
plot(sin(x), x = -4 .. 4, tickmarks = [0, 0]); _
 _
plot(sin(x), x = -4 .. 4, _
@<&nbsp;&nbsp;>@tickmarks = [[0, Pi, 2*Pi], [-1, 0, 1]])||wxplot2d(sin(x), [x, -4, 4], _
@<&nbsp;&nbsp;>@[xtics, -4, 2, 4], _
@<&nbsp;&nbsp;>@[ytics, -1, 0.5, 1]);|| || ||
||[[# grid-lines]][#grid-lines-note grid lines]||Plot[Sin[x], {x, 0, 2 Pi}, _
@<&nbsp;&nbsp;>@GridLines -> Automatic] _
 _
Plot[Sin[x], {x, 0, 2 Pi}, _
@<&nbsp;&nbsp;>@GridLines -> @@{{@@0, 1, 2, 3, 4, 5, 6}, _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@{-1, -0.5, 0, 0.5, 1}}]||plot(sin(x), x = -4 .. 4, gridlines);|| || || ||
||[[# grid-of-subplots]][[image http://cdn.hyperpolyglot.org/images/subplot-grid.jpg]] _
[#grid-of-subplots-note grid of subplots]||GraphicsGrid[Table[Table[ _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@Histogram[RandomReal[X, 100], 10], _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@{i, 1, 2}], _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@{j, 1, 2}]]||with(plots): with(Statistics): _
 _
A := Array(1 .. 2, 1 .. 2); _
X := RandomVariable(Normal(0, 1)); _
for i while i <= 2 do _
@<&nbsp;&nbsp;>@for j while j <= 2 do _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@A[i, j] := Histogram(Sample(X, 100)); _
@<&nbsp;&nbsp;>@end do; _
end do; _
Display(A);||load(distrib); _
 _
x: makelist(makelist(random_normal(0, 1), i, 50), _
@<&nbsp;&nbsp;>@j, 4); _
p: makelist(histogram_description(x[i]), i, 4); _
wxdraw(gr2d(p[1]), gr2d(p[2]), gr2d(p[3]), _
@<&nbsp;&nbsp;>@gr2d(p[4]), columns=2);|| || ||
||[[# save-plot-as-png]][#save-plot-as-png-note save plot as png]||Export["hist.png", _
@<&nbsp;&nbsp;>@Histogram[RandomReal[X, 100], 10]]||with(plottools): with(Statistics): _
 _
X := RandomVariable(Normal(0, 1)); _
plt := BoxPlot(Sample(X, 100)); _
exportplot("boxplot.png", plt);||##gray|//After creating a plot, run// gnuplot //on the// .gnuplot //file generated in the home directory://## _
 _
$ gnuplot maxout.gnuplot|| || ||
||~ ||~ ##EFEFEF|@@____________________________________________________@@##||~ ##EFEFEF|@@____________________________________________________@@##||~ ##EFEFEF|@@____________________________________________________@@##||~ ##EFEFEF|@@____________________________________________________@@##||~ ##EFEFEF|@@____________________________________________________@@##||


[[# version-used-note]]
++ [#version-used version used]

The version of software used to check the examples in the reference sheet.

[[# show-version-note]]
++ [#show-version show version]

How to determine the version of an installation.

[[# implicit-prologue-note]]
++ [#implicit-prologue implicit prologue]

Code assumed to have been executed by the examples in the sheet.

[[# grammar-invocation-note]]
+ [#grammar-invocation Grammar and Invocation]

[[# interpreter-note]]
++ [#interpreter interpreter]

How to execute a script.

**mathematica:**

The full path to MathKernel on Mac OS X:

[[code]]
/Applications/Mathematica.app/Contents/MacOS/MathKernel
[[/code]]

[[# repl-note]]
++ [#repl repl]

How to launch a command line read-eval-print loop for the language.

[[# block-delimiters-note]]
++ [#block-delimiters block delimiters]

How blocks are delimited.

[[# stmt-separator-note]]
++ [#stmt-separator statement separator]

How statements are separated.

[[# eol-comment-note]]
++ [#eol-comment end-of-line comment]

Character used to start a comment that goes to the end of the line.

[[# multiple-line-comment-note]]
++ [#multiple-line-comment multiple line comment]

The syntax for a delimited comment which can span lines.

[[# var-expr-note]]
+ [#var-expr Variables and Expressions]

[[# assignment-note]]
++ [#assignment assignment]

How to perform assignment.

Mathematica, Sympy, and Pari/GP support the chaining of assignments.  For example, in Mathematica one can assign the value 3 to {{x}} and {{y}} with:

[[code]]
x = y = 3
[[/code]]

In Mathematica and Pari/GP, assignments are expressions.  In Mathematica, the following code is legal and evaluates to 7:

[[code]]
(x = 3) + 4
[[/code]]

In Mathematica, the {{Set}} function behaves identically to assignment and can be nested:

[[code]]
Set[a, Set[b, 3]]
[[/code]]

[[# delayed-assignment-note]]
++ [#delayed-assignment delayed assignment]

How to assign an expression to a variable name.  The expression is re-evaluated each time the variable is used.

**mathematica:**

GNU make also supports assignment and delayed assignment, but {{=}} is used for delayed assignment and {{:=}} is used for immediate assignment.  This is the opposite of how Mathematica uses the symbols.

The POSIX standard for make only has {{=}} for delayed assignment.

[[# parallel-assignment-note]]
++ [#parallel-assignment parallel assignment]

How to assign values in parallel.

Parallel assignment can be used to swap the values held in two variables.

[[# compound-assignment-note]]
++ [#compound-assignment compound assignment]

The compound assignment operators.

[[# incr-decr-note]]
++ [#incr-decr increment and decrement]

Increment and decrement operators which can be used in expressions.

[[# non-referential-id-note]]
++ [#non-referential-id non-referential identifier]

An identifier which does not refer to a value.

A non-referential identifier will usually print as a string containing its name.

Expressions containing non-referential identifiers will not be evaluated, though they may be simplified.

Non-referential identifiers represent "unknowns" or "parameters" when performing algebraic derivations.

[[# id-as-val-note]]
++ [#id-as-val identifier as value]

How to get a value referring to an identifier.

The identifier may be the name of a variable containing a value.  But the value referring to the identifier is distinct from the value in the variable.

One may manipulate a value referring to an identifier even if it is not the name of a variable.

[[# global-var-note]]
++ [#global-var global variable]

How to declare a global variable.

[[# local-var-note]]
++ [#local-var local variable]

How to declare a local variable.

**pari/gp:**

There is {{my}} for declaring a local variable with lexical scope and {{local}} for declaring a variable with dynamic scope.

{{local}} can be used to change the value of a global as seen by any functions which are called while the local scope is in effect.

[[# null-note]]
++ [#null null]

The null literal.

[[# null-test-note]]
++ [#null-test null test]

How to test if a value is null.

[[# undef-var-note]]
++ [#undef-var undefined variable access]

What happens when an undefined variable is used in an expression.

[[# rm-var-binding-note]]
++ [#rm-var-binding remove variable binding]

How to remove a variable.  Subsequent references to the variable will be treated as if the variable were undefined.

[[# cond-expr-note]]
++ [#cond-expr conditional expression]

A conditional expression.
[[# arithmetic-logic-note]]
+ [#arithmetic-logic Arithmetic and Logic]

[[# true-false-note]]
++ [#true-false true and false]

The boolean literals.

[[# falsehoods-note]]
++ [#falsehoods falsehoods]

Values which evaluate to false in a conditional test.

**sympy:**

Note that the logical operators {{Not}}, {{And}} and {{Or}} do not treat empty collections or {{None}} as false.  This is different from the Python logical operators {{not}}, {{and}}, and {{or}}.

**pari/gp:**

A vector or matrix evaluates to false if all components evaluate to false.

[[# logical-op-note]]
++ [#logical-op logical operators]

The Boolean operators.

**sympy:**

In Python, {{&}}, {{|}}, and {{&}} are bit operators.  SymPy has defined {{@@__and__@@}}, {{@@__or__@@}}, and {{@@__invert__@@}} methods to make them Boolean operators for symbols, however.

[[# relational-op-note]]
++ [#relational-op relational operators]

The relational operators.

**sympy:**

The full SymPy names for the relational operators are:

[[code]]
sympy.Equality             # ==
sympy.Unequality           # !=
sympy.GreaterThan          # >=
sympy.LessThan             # <=
sympy.StrictGreaterThan    # >
sympy.StrictLessThan       # <
[[/code]]

The SymPy functions are attatched to the relational operators {{==}}, {{!=}}, for symbols ... using the methods {{@@__eq__@@}}, {{@@__ne__@@}}, {{@@__ge__@@}}, {{@@__le__@@}}, {{@@__gt__@@}}, {{@@__lt__@@}}.  The behavior they provide is similar to the default Python behavior, but when one of the arguments is a SymPy expression, a simplification will be attempted before the comparison is made.

[[# arith-op-note]]
++ [#arith-op arithmetic operators]

The arithmetic operators.

[[# int-div-note]]
++ [#int-div integer division]

How to compute the quotient of two integers.

[[# int-div-zero-note]]
++ [#int-div-zero integer division by zero]

The result of dividing an integer by zero.

[[# float-div-note]]
++ [#float-div float division]

How to perform float division, even if the arguments are integers.

[[# float-div-zero-note]]
++ [#float-div-zero float division by zero]

The result of dividing a float by zero.

[[# power-note]]
++ [#power power]

How to compute exponentiation.

Note that zero to a negative power is equivalent to division by zero, and negative numbers to a fractional power may have multiple complex solutions.

[[# sqrt-note]]
++ [#sqrt sqrt]

The square root function.

For positive arguments the positive square root is returned.

[[# sqrt-negative-one-note]]
++ [#sqrt-negative-one sqrt -1]

How the square root function handles negative arguments.

**mathematica:**

An uppercase {{I}} is used to enter the imaginary unit, but Mathematica displays it as a lowercase {{i}}.

[[# transcendental-func-note]]
++ [#transcendental-func transcendental functions]

The standard transcendental functions such as one might find on a scientific calculator.

The functions are the exponential (not to be confused with exponentiation), natural logarithm, sine, cosine, tangent, arcsine, arccosine, arctangent, and the two argument arctangent.

[[# transcendental-const-note]]
++ [#transcendental-const transcendental constants]

The transcendental constants //pi// and //e//.

The transcendental functions can used to computed to compute the transcendental constants:

[[code]]
pi = acos(-1)
pi = 4 * atan(1)
e = exp(1)
[[/code]]

[[# float-truncation-note]]
++ [#float-truncation float truncation]

Ways to convert a float to a nearby integer.

[[# absolute-val-note]]
++ [#absolute-val absolute value]

How to get the absolute value and signum of a number.

[[# int-overflow-note]]
++ [#int-overflow integer overflow]

What happens when the value of an integer expression cannot be stored in an integer.

The languages in this sheet all support arbitrary length integers so the situation does not happen.

[[# float-overflow-note]]
++ [#float-overflow float overflow]

What happens when the value of a floating point expression cannot be stored in a float.

[[# rational-construction-note]]
++ [#rational-construction rational construction]

How to construct a rational number.

[[# rational-decomposition-note]]
++ [#rational-decomposition rational decomposition]

How to extract the numerator and denominator from a rational number.

[[# decimal-approx-note]]
++ [#decimal-approx decimal approximation]

How to get a decimal approximation of an irrational number or repeating decimal rational.

[[# complex-construction-note]]
++ [#complex-construction complex construction]

How to construct a complex number.

[[# complex-decomposition-note]]
++ [#complex-decomposition complex decomposition]

How to extract the real and imaginary part from a complex number; how to extract the argument and modulus; how to get the complex conjugate.

[[# random-num-note]]
++ [#random-num random number]

How to generate a random integer or a random float.

**pari/gp:**

When the argument of {{random()}} is an integer {{n}}, it generates an integer in the range [[$ \{0, ..., n - 1\} $]].

When the argument is a arbitrary precision float, it generates a value in the range {{[0.0, 1.0]}}.  The precision of the argument determines the precision of the random number.

[[# random-seed-note]]
++ [#random-seed random seed]

How to set or get the random seed.

**mathematica:**

The seed is not set to the same value at start up.

[[# bit-op-note]]
++ [#bit-op bit operators]


[[# binary-octal-hex-literals-note]]
++ [#binary-octal-hex-literals binary, octal, and hex literals]

Binary, octal, and hex integer literals.

**mathematica:**

The notation works for any base from 2 to 36.

[[# radix-note]]
++ [#radix radix]

Convert a number to a representation using a given radix.

[[# to-array-of-digits-note]]
++ [#to-array-of-digits to array of digits]

Convert a number to an array of digits representing the number.

[[# strings-note]]
+ [#strings Strings]

[[# str-literal-note]]
++ [#str-literal string literal]

The syntax for a string literal.

[[# newline-in-str-literal-note]]
++ [#newline-in-str-literal newline in literal]

Are newlines permitted in string literals.

[[# str-literal-esc-note]]
++ [#str-literal-esc literal escapes]

Escape sequences for putting unusual characters in string literals.

[[# str-concat-note]]
++ [#str-concat concatenate]

How to concatenate strings.

[[# translate-case-note]]
++ [#translate-case translate case]

How to convert a string to all lower case letters or all upper case letters.

[[# trim-note]]
++ [#trim trim]

How to remove whitespace from the beginning or the end of string.

[[# num-to-str-note]]
++ [#num-to-str number to string]

How to convert a number to a string.

[[# str-to-num-note]]
++ [#str-to-num string to number]

How to parse a number from a string.

[[# str-join-note]]
++ [#str-join string join]

How to join an array of strings into a single string, possibly separated by a delimiter.

[[# split-note]]
++ [#split split]

How to split a string in to an array of strings.  How to specify the delimiter.

[[# str-subst-note]]
++ [#str-subst substitute]

How to substitute one or all occurrences of substring with another.

[[# str-len-note]]
++ [#str-len length]

How to get the length of a string in characters.

[[# index-substr-note]]
++ [#index-substr index of substring]

How to get the index of the first occurrence of a substring.

[[# extract-substr-note]]
++ [#extract-substr extract substring]

How to get a substring from a string using character indices.

[[# char-literal-note]]
++ [#char-literal character literal]

The syntax for a character literal.

[[# lookup-char-note]]
++ [#lookup-char character lookup]

How to get a character from a string by index.

[[# chr-ord-note]]
++ [#chr-ord chr and ord]

Convert a character code point to a character or a single character string.

Get the character code point for a character or single character string.

[[# delete-char-note]]
++ [#delete-char delete characters]

Delete all occurrences of a set of characters from a string.

[[# arrays-note]]
+ [#arrays Arrays]

||~ section||~ mathematica||~ maple||~ maxima||~ sympy||
||[#arrays arrays]||List||list||list||list||
||multidimensional arrays||List||Array||array||##gray|//none//##||
||[#vectors vectors]||List||Vector||list||Matrix||
||[#matrices matrices]||List||Matrix||matrix||Matrix||

[[# array-literal-note]]
++ [#array-literal literal]

The notation for an array literal.

[[# array-size-note]]
++ [#array-size size]

The number of elements in the array.

[[# array-lookup-note]]
++ [#array-lookup lookup]

How to access an array element by its index.

[[# array-update-note]]
++ [#array-update update]

How to change the value stored at an array index.

[[# array-out-of-bounds-note]]
++ [#array-out-of-bounds out-of-bounds behavior]

What happens when an attempt is made to access an element at an out-of-bounds index.

[[# array-element-index-note]]
++ [#array-element-index element index]

How to get the index of an element in an array.

[[# array-slice-note]]
++ [#array-slice slice]

How to extract a subset of the elements.  The indices for the elements must be contiguous.

[[# array-of-integers-as-index-note]]
++ [#array-of-integers-as-index array of integers as index]

[[# array-back-note]]
++ [#array-back manipulate back]

[[# array-front-note]]
++ [#array-front manipulate front]

[[# array-head-note]]
++ [#array-head head]

[[# array-tail-note]]
++ [#array-tail tail]

[[# array-cons-note]]
++ [#array-cons cons]

[[# array-concatenate-note]]
++ [#array-concatenate concatenate]

[[# array-replicate-note]]
++ [#array-replicate replicate]

[[# copy-array-note]]
++ [#copy-array copy]

How to copy an array.  Updating the copy will not alter the original.

[[# iterate-over-array-note]]
++ [#iterate-over-array iterate]

[[# reverse-array-note]]
++ [#reverse-array reverse]

[[# sort-array-note]]
++ [#sort-array sort]

[[# dedupe-array-note]]
++ [#dedupe-array dedupe]

[[# membership-note]]
++ [#membership membership]

How to test whether a value is an element of a list.

[[# intersection-note]]
++ [#intersection intersection]

How to to find the intersection of two lists.

[[# union-note]]
++ [#union union]

How to find the union of two lists.

[[# set-diff-note]]
++ [#set-diff relative complement, symmetric difference]

How to find all elements in one list which are not in another; how to find all elements which are in one of two lists but not both.

[[# map-note]]
++ [#map map]

[[# filter-note]]
++ [#filter filter]

[[# reduce-note]]
++ [#reduce reduce]

[[# universal-existential-test-note]]
++ [#universal-existential-test universal and existential tests]

[[# min-max-elem-note]]
++ [#min-max-elem min and max element]

[[# shuffle-sample-note]]
++ [#shuffle-sample shuffle and sample]

How to shuffle an array. How to extract a random sample from an array without replacement.

[[# flatten-note]]
++ [#flatten flatten]

[[# zip-note]]
++ [#zip zip]

How to interleave two arrays.

[[# cartesian-product-note]]
++ [#cartesian-product cartesian product]

[[# sets-note]]
+ [#sets Sets]

[[# arith-seq-note]]
+ [#arith-seq Arithmetic Sequences]

[[# dictionaries-note]]
+ [#dictionaries Dictionaries]

[[# record-literal]]
++ record literal


[[# record-access]]
++ record member access

[[# functions-note]]
+ [#functions Functions]

[[# definition]]
++ definition

[[# invocation]]
++ invocation

[[# function-value]]
++ function value

[[# execution-control-note]]
+ [#execution-control Execution Control]

[[# if]]
++ if

How to write a branch statement.

**mathematica:**

The 3rd argument (the else clause) of an //If// expression is optional.

[[# while]]
++ while

How to write a conditional loop.

**mathematica:**

//Do// can be used for a finite unconditional loop:

[[code]]
Do[Print[foo], {10}]
[[/code]]

[[# for]]
++ for

How to write a C-style for statement.

[[# break-continue]]
++ break/continue

How to break out of a loop.  How to jump to the next iteration of a loop.

[[# exceptions-note]]
+ [#exceptions Exceptions]

[[# raise-exc-note]]
++ [#raise-exc raise exception]

How to raise an exception.

[[# handle-exc-note]]
++ [#handle-exc handle exception]

How to handle an exception.

[[# uncaught-exc-note]]
++ [#uncaught-exc uncaught exception behavior]

**gap:**

Calling {{Error()}} invokes the GAP debugger, which is similar to a Lisp debugger.  In particular, all the commands available in the GAP REPL are still available.  Variables can be inspected and modified while in the debugger but any changes will be lost when the debugger is quitted.

One uses {{quit;}} or {{^D}} to exit the debugger.  These commands also cause the top-level GAP REPL exit if used while not in a debugger.

If {{Error()}} is invoked while in the GAP debugger, the  debugger will be invoked recursively.   One must use {{quit;}} for each level of debugger recursion to return to the top -level GAP REPL.

Use

[[code]]
brk> Where(4);
[[/code]]

to print the top four functions on the stack when the error occurred.  Use {{DownEnv()}} and {{UpEnv()}} to move down the stackâ€”i.e. from callee to callerâ€”and {{UpEnv()}} to move up the stack.  The commands take the number of levels to move down or up:

[[code]]
brk> DownEnv(2);
brk> UpEnv(2);
[[/code]]

When the debugger is invoked, it will print a message.  It may give the user the option of providing a value with the {{return}} statement so that a computation can be continued:

[[code]]
brk> return 17;
[[/code]]

[[# finally]]
++ finally block

How to write code that executes even if an exception is raised.

[[# streams-note]]
+ [#streams Streams]

[[# files-note]]
+ [#files Files]

[[# directories-note]]
+ [#directories Directories]

[[# libraries-namespaces-note]]
+ [#libraries-namespaces Libraries and Namespaces]

[[# reflection-note]]
+ [#reflection Reflection]

[[# function-documentation]]
++ function documentation

How to get the documentation for a function.

[[# symbolic-expr-note]]
+ [#symbolic-expr Symbolic Expressions]

A defining feature of computer algebra systems is //symbolic expressions//.

In most programming languages, evaluating an expression with an undefined variable results in an error.  Some languages assign a default value to variables so that such expressions can be evaluated.

In a CAS, undefined variables are treated as unknowns; expressions which contains them are //symbolic expressions//.  When evaluating them, if the unknowns cannot be eliminated, the expression cannot be reduced to a numeric value. The expression then evaluates to a possibly simplified or normalized version of itself.  Symbolic expressions are first class values; they can be stored in variables or passed to functions.  An application of symbolic expressions is a function which solves a system of equations.  Without symbolic expressions, it would be awkward for the caller to specify the equations to be solved.

[[# symbolic-expr-literal-note]]
++ [#symbolic-expr-literal literal]

How to create a symbolic expression.

In most CAS systems, any expression an undefined variables is automatically a a symbolic expression.

**sympy:**

In SymPy, unknowns must be declared.  This is a consequence of SymPy being implemented as a library in a language which throws exceptions when undefined variables are encountered.

[[# prevent-simplification-note]]
++ [#prevent-simplification prevent simplification]

[[# symbolic-expr-var-update-note]]
++ [#symbolic-expr-var-update variable update]

Do symbolic expressions "see" changes to the unknown variables they contain.

[[# symbolic-expr-subst-note]]
++ [#symbolic-expr-subst substitute]

[[# piecewise-symbolic-expr-note]]
++ [#piecewise-symbolic-expr piecewise-defined expression]

[[# simplify-note]]
++ [#simplify simplify]

[[# assumption-note]]
++ [#assumption assumption]

[[# assumption-predicates-note]]
++ [#assumption-predicates assumption predicates]

[[# list-assumptions-note]]
++ [#list-assumptions list assumptions]

[[# rm-assumption-note]]
++ [#rm-assumption remove assumption]

[[# calculus-note]]
+ [#calculus Calculus]

[[# limit-note]]
++ [#limit limit]

[[# limit-at-infinity-note]]
++ [#limit-at-infinity limit at infinity]

[[# one-sided-limit-note]]
++ [#one-sided-limit one-sided limit]

[[# derivative-note]]
++ [#derivative derivative]

[[# derivative-func-note]]
++ [#derivative-func derivative of a function]

[[# derivative-const-note]]
++ [#derivative-const constants]

[[# higher-order-derivative-note]]
++ [#higher-order-derivative higher order derivative]

[[# mixed-partial-derivative-note]]
++ [#mixed-partial-derivative mixed partial derivative]

[[# div-grad-curl-note]]
++ [#div-grad-curl div, grad, and curl]

[[# antiderivative-note]]
++ [#antiderivative antiderivative]

[[# definite-integral-note]]
++ [#definite-integral definite integral]

[[# improper-integral-note]]
++ [#improper-integral improper integral]

[[# double-integral-note]]
++ [#double-integral double integral]

[[# find-poles-note]]
++ [#find-poles find poles]

[[# residue-note]]
++ [#residue residue]

[[# sum-note]]
++ [#sum sum]

[[# series-sum-note]]
++ [#series-sum series sum]

[[# series-expansion-func-note]]
++ [#series-expansion-func series expansion of function]

[[# omitted-order-term-note]]
++ [#omitted-order-term omitted order term]

[[# product-note]]
++ [#product product]

[[# equations-unknowns-note]]
+ [#eqn Equations and Unknowns]

[[# solve-eqn-note]]
++ [#solve-eqn solve equation]

[[# solve-eqns-note]]
++ [#solve-eqns solve equations]

[[# differential-eqn-note]]
++ [#differential-eqn differential equation]

[[# differential-eqn-boundary-condition-note]]
++ [#differential-eqn-boundary-condition differential equation with boundary condition]

[[# differential-eqns-note]]
++ [#differential-eqns differential equations]

[[# recurrence-eqn-note]]
++ [#recurrence-eqn recurrence equation]

[[# optimization-note]]
+ [#optimization Optimization]

An optimization problem consists of a real-valued function called the //objective function//.

The objective function takes one or more //input variables//.  In the case of a maximization problem, the goal is to find the value for the input variables where the objective function achieves its maximum value.  Similarly for a minimization function one looks for the values for which the objective function achieves its minimum value.

[[# minimize-note]]
++ [#minimize minimize]

How to solve a minimization problem in one variable.

[[# maximize-note]]
++ [#maximize maximize]

How to solve a maximization problem.

We can use a function which solves minimization problems to solve maximization problems by negating the objective function.  The downside is we might forget the minimum value returned is the negation of the maximum value we seek.

[[# optimize-unknown-param-note]]
++ [#optimize-unknown-param objective with unknown parameter]

How to solve an optimization when the objective function contains unknown parameters.

[[# unbounded-behavior-note]]
++ [#unbounded-behavior unbounded behavior]

What happens when attempting to solve an unbounded optimization problem.

[[# optimize-multiple-var-note]]
++ [#optimize-multiple-var multiple variables]

How to solve an optimization problem with more than one input variable.

[[# optimize-constraints-note]]
++ [#optimize-constraints constraints]

How to solve an optimization with constraints on the input variable.  The constrains are represented by inequalities.

[[# infeasible-behavior-note]]
++ [#infeasible-behavior infeasible behavior]

What happens when attempting to solve an optimization problem when the solution set for the constraints is empty.

[[# optimize-int-var-note]]
++ [#optimize-int-var integer variables]

How to solve an optimization problem when the input variables are constrained to linear values.

[[# vectors-note]]
+ [#vectors Vectors]

[[# vec-literal-note]]
++ [#vec-literal vector literal]

The notation for a vector literal.

[[# const-vec-note]]
++ [#const-vec constant vector]

How to create a vector with components all the same.

[[# vec-coordinate-note]]
++ [#vec-coordinate vector coordinate]

How to get one of the coordinates of a vector.

[[# vec-dim-note]]
++ [#vec-dim vector dimension]

How to get the number of coordinates of a vector.

[[# vec-element-wise-note]]
++ [#vec-element-wise element-wise arithmetic operators]

How to perform an element-wise arithmetic operation on vectors.

[[# vec-length-mismatch-note]]
++ [#vec-length-mismatch vector length mismatch]

What happens when an element-wise arithmetic operation is performed on vectors of different dimension.

[[# vec-scalar-note]]
++ [#vec-scalar scalar multiplication]

How to multiply a scalar with a vector.

[[# vec-dot-note]]
++ [#vec-dot dot product]

How to compute the dot product of two vectors.

[[# vec-cross-note]]
++ [#vec-cross cross product]

How to compute the cross product of two three-dimensional vectors.

[[# vec-norms-note]]
++ [#vec-norms norms]

How to compute the norm of a vector.

[[# matrices-note]]
+ [#matrices Matrices]

[[# matrix-literal-ctor-note]]
++ [#matrix-literal-ctor literal or constructor]

Literal syntax or constructor for creating a matrix.

**mathematica:**

Matrices are represented as lists of lists.  No error is generated if one of the rows contains too many or two few elements.  The //MatrixQ// predicate can be used to test whether a list of lists is matrix: i.e. all of the sublists contain numbers and are of the same length.

Matrices are displayed by Mathematica using list notation.  To see a matrix as it would be displayed in mathematical notation, use the //MatrixForm// function.

[[# matrix-from-seq-note]]
++ [#matrix-from-seq construct from sequence]

[[# const-matrices-note]]
++ [#const-matrices constant matrices]

[[# diagonal-matrices-note]]
++ [#diagonal-matrices diagonal matrices]

[[# matrix-formula-note]]
++ [#matrix-formula matrix by formula]

[[# matrix-dim-note]]
++ [#matrix-dim dimensions]

How to get the number of rows and columns of a matrix.

[[# matrix-elem-lookup-note]]
++ [#matrix-elem-lookup element lookup]

How to access an element of a matrix.

The anguages described here follow the mathematical convention of putting the row index before the column index.

[[# extract-matrix-row-note]]
++ [#extract-matrix-row extract row]

How to access a row.

[[# extract-matrix-col-note]]
++ [#extract-matrix-col extract column]

How to access a column.

[[# extract-submatrix-note]]
++ [#extract-submatrix extract submatrix]

How to access a submatrix.

[[# matrix-scalar-mult-note]]
++ [#matrix-scalar-mult scalar multiplication]

How to multiply a matrix by a scalar.

[[# matrix-elem-wise-op-note]]
++ [#matrix-elem-wise-op element-wise operators]

Operators which act on two identically sized matrices element by element.  Note that element-wise multiplication of two matrices is used less frequently in mathematics than matrix multiplication.

[[# matrix-mult-note]]
++ [#matrix-mult product]

How to multiply matrices.  Matrix multiplication should not be confused with element-wise multiplication of matrices.  Matrix multiplication in non-commutative and only requires that the number of columns of the matrix on the left match the number of rows of the matrix.  Element-wise multiplication, by contrast, is commutative and requires that the dimensions of the two matrices be equal.

[[# matrix-power-note]]
++ [#matrix-power power]

[[# matrix-exponential-note]]
++ [#matrix-exponential exponential]

[[# matrix-log-note]]
++ [#matrix-log log]

[[# kronecker-prod-note]]
++ [#kronecker-prod kronecker product]

The [http://en.wikipedia.org/wiki/Kronecker_product Kronecker product] is a non-commutative operation defined on any two matrices.  If A is m x n and B is p x q, then the Kronecker product is a matrix with dimensions mp x nq.

[[# matrix-norms-note]]
++ [#matrix-norms norms]

How to compute the 1-norm, the 2-norm, the infinity norm, and the frobenius norm.

[[# matrix-transpose-note]]
++ [#matrix-transpose transpose]

[[# matrix-conjugate-transpose-note]]
++ [#matrix-conjugate-transpose conjugate transpose]

[[# matrix-inverse-note]]
++ [#matrix-inverse inverse]

[[# row-echelon-form-note]]
++ [#row-echelon-form row echelon form]

[[# pseudoinverse-note]]
++ [#pseudoinverse pseudoinverse]

[[# determinant-note]]
++ [#determinant determinant]

[[# trace-note]]
++ [#trace trace]

[[# characteristic-polynomial-note]]
++ [#characteristic-polynomial characteristic polynomial]

[[# minimal-polynomial-note]]
++ [#minimal-polynomial minimal polynomial]

[[# matrix-rank-note]]
++ [#matrix-rank rank]

[[# nullspace-basis-note]]
++ [#nullspace-basis nullspace basis]

[[# eigenval-note]]
++ [#eigenval eigenvalues]

[[# eigenvec-note]]
++ [#eigenvec eigenvectors]

[[# spectral-decomposition-note]]
++ [#spectral-decomposition spectral decomposition]

The spectral decomposition of a square matrix //A// is a factorization //P â‹…D â‹… P^^-1^^// where //P// is invertible and //D// is diagonal.

If a spectral decomposition exists, the matrix //A// is said to be //diagonalizable//.

If an invertiable matrix //P// exists such that //A = P â‹… B â‹… P^^-1^^//, then //A// and //B// are said to be //similar//.

According to the spectral theorem, and spectral decomposition exists when the matrix //A// is //normal//, which means it commutes with its conjugate transpose.

If a matrix //A// is symmetric, then a spectral decomposition //P â‹… D â‹… P^^-1^^// exists, and moreover //P// and //D// are real matrices.

The spectral decomposition is also called the //eigendecomposition//.  The values on the diagonal of //D// are eigenvalues of the original matrix //A//.

[[# lup-decomposition-note]]
++ [#lup-decomposition LUP decomposition]

Factor a square matrix //A// into a lower triangular matrix //L//, an upper triangular matrix //U//, and a permutation matrix //P//.

An LUP factorization of a square matrix always exists.  

[[# qr-decomposition-note]]
++ [#qr-decomposition QR decomposition]

[[# jordan-decomposition-note]]
++ [#jordan-decomposition jordan decomposition]

[[# svd-note]]
++ [#svd singular value decomposition]

[[# polar-decomposition-note]]
++ [#polar-decomposition polar decomposition]

[[# combinatorics-note]]
+ [#combinatorics Combinatorics]

Enumerative combinatorics is the study of the size of finite sets.  The sets are defined by some property, and we seek a formula for the size of the set so defined.

For some simple examples, let //A// and //B// be disjoint sets of size //n// and //m// respectively.  The size of the union //A âˆª B// is //n + m// and the size of the Cartesian product //A Ã— B// is //nm//.  The size of the power set of //A// is //2^^n^^//.

[[# factorial-note]]
++ [#factorial factorial]

The factorial function //n!// is the product of the first //n// positive integers //1 Ã— 2 Ã— ... Ã— n//.

It is also the number of permutations or bijective functions on a set of //n// elements.  It is the number of orderings that can be given to //n// elements.

See the section on permutations below for how to iterate through all //n!// permutations on a set of //n// elements.

As the factorial function grows rapidly with //n//, it is useful to be aware of this approximation:

[[math]]
\ln n! \approx n \ln n - n + \frac{1}{2} \ln 2 \pi n
[[/math]]

[[# binomial-coefficient-note]]
++ [#binomial-coefficient binomial coefficient]

The binomial coefficient can be defined using the factorial function:

[[math]]
{n \choose k} = \frac{n!}{(n-k)! k!}
[[/math]]

The binomial coefficient appears in the binomial theorem:

[[math]]
(x+y)^n = \sum_{k=0}^{n} {n \choose k} x^k y^{n-k}
[[/math]]

The binomial cofficient [[$ { n \choose k } $]] is the number of sets of size //k// which can be drawn from a set of size //n// without replacement.

[[# multinomial-coefficient-note]]
++ [#multinomial-coefficient multinomial coefficient]

[[# rising-falling-factorial-note]]
++ [#rising-falling-factorial rising and falling factorial]

[[# subfactorial-note]]
++ [#subfactorial subfactorial]

A //derangement// is a permutation on a set of //n// elements where every element moves to a new location.

The number of derangements is thus less than the number of permutations, //n!//, and the function for the number of derangements is called the //subfactorial// function.

Using a exclamation point as a prefix to denote the subfactorial, the following equations hold:

[[math]]
!n  = n \cdot [!(n-1)] + (-1)^n
[[/math]]

[[math]]
!n = n! \sum_{i=0}^n \frac{(-1)^i}{i!}
[[/math]]

[[math]]
lim_{n \rightarrow \infty} \frac{!n}{n!} = \frac{1}{e}
[[/math]]

[[# int-partitions-note]]
++ [#int-partitions integer partitions]

The number of multisets of positive integers which sum to a integer.

There are 5 integer partitions of 4:

[[code]]
    4
    3 + 1
    2 + 2
    2 + 1 + 1
    1 + 1 + 1 + 1
[[/code]]

[[# compositions-note]]
++ [#compositions compositions]

The number of sequences of positive integers which sum to an integer.

There are 8 compositions of 4:

[[code]]
    4
    3 + 1
    1 + 3
    2 + 2
    2 + 1 + 1
    1 + 2 + 1
    1 + 1 + 2
    1 + 1 + 1 + 1
[[/code]]

**mathematica:**

The {{NumberOfCompositions}} and {{Compositions}} functions use //weak compositions//, which include zero as a possible summation.

The number of weak compositions of an integer is infinite, since there is no limit on the number of times zero can appear as a summand.  The number of weak compositions of a fixed size is finite, however.

[[# set-partitions-note]]
++ [#set-partitions set partitions]

[[# bell-num-note]]
++ [#set-bell-num bell number]

[[# permutations-k-disjoint-cycles-note]]
++ [#permutations-k-disjoint-cycles permutations with k disjoint cycles]

[[# fibonacci-num-note]]
++ [#fibonacci-num fibonacci number]

[[# bernoulli-num-note]]
++ [#bernoulli-num bernoulli number]

[[# harmonic-num-note]]
++ [#harmonic-num harmonic number]

[[# catalan-num-note]]
++ [#catalan-num catalan number]

[[# number-theory-note]]
+ [#number-theory Number Theory]

[[# divisible-test-note]]
++ [#divisible-test divisible test]

A test whether an integer //a// is divisible by another integer //b//.

Equivalently, does there exists a third integer //m// such that //a = mb//.

[[# divisors-note]]
++ [#divisors divisors]

The list of divisors for an integer.

[[# pseudoprime-test-note]]
++ [#pseudoprime-test pseudoprime test]

A fast primality test.

An integer //p// is prime if for any factorization //p = ab//, where //a// and //b// are integers, either //a// or //b// are in the set {-1, 1}. 


A number of primality tests exists which give occasional false positives.  The simplest of these use Fermat's Little Theorem, in which for prime //p// and //a// in [[$ \{1, ..., p - 1\} $]]:

[[math]]
a^{p-1} \equiv 1 \;(\text{mod}\; p)
[[/math]]

The test for a candidate prime //p// is to randomly choose several values for //a// in  [[$ \{1, ..., p - 1\} $]] and evaluate

[[math]]
a^{p-1} \;(\text{mod}\; p)
[[/math]]

If any of them are not equivalent to 1, then the test shows that p is not prime.  Unfortunately, there are composite numbers //n//, the [https://oeis.org/A002997 Carmichael numbers], for which

[[math]]
a^{n-1} \equiv 1 \;(\text{mod}\; n)
[[/math]]

holds for all //a// in [[$ \{1, ..., n - 1\} $]].

A stronger test is the Miller-Rabin primality test.  Given a candidate prime //n//, we factor //n - 1// as 2^^r^^ â‹… //d// where //d// is odd.  If //n// is prime, then one of the following must be true:

[[math]]
a^d \equiv 1 \;(\text{mod}\;n)
[[/math]]

[[math]]
a^{2^r \cdot d} \equiv -1 \;(\text{mod}\;n)
[[/math]]

Thus, one checks the above two equations for a small number of primes.  If we use all primes p â‰¤ 41, then it is known that there are no false positives for n â‰¤ 3 Ã— 10^^24^^.

Since pseuodoprime tests are known which are correct for all integers up to a very large size, and since conclusively showing that a number is prime is a slow operation for larger integers, a true prime test is often not practical.

[[# prime-factors-note]]
++ [#prime-factors prime factors]

The list of prime factors for an integer, with their multiplicities.

[[# next-prime-note]]
++ [#next-prime next prime]

The smallest prime number greater than an integer.  Also the greatest prime number smaller than an integer.

[[# nth-prime-note]]
++ [#nth-prime nth prime]

The n-th prime number.

[[# prime-counting-func-note]]
++ [#prime-counting-func prime counting function]

The number of primes less than or equal to a value.

According to the prime number theorem:

[[math]]
\lim_{n \rightarrow \infty} \frac{\pi(n)}{n/\log n} = 1
[[/math]]

[[# divmod-note]]
++ [#divmod divmod]

The quotient and remainder.

If the divisor is positive, then the remainder is non-negative.

[[# gcd-note]]
++ [#gcd greatest common divisor]

The greatest common divisor of a pair of integers.  The divisor is always positive.

Two integers are relatively prime if their greatest common divisor is one.

[[# extended-euclidean-algorithm-note]]
++ [#extended-euclidean-algorithm extended euclidean algorithm]

How to express a greatest common divisor as a linear combination of the integers it is a GCD of.

The functions described return the GCD in addition to the coefficients.

[[# lcm-note]]
++ [#lcm least common multiple]

The least common multiple of a pair of integers.

The LCM can be calculated from the GCD using this formula:

[[math]]
\text{lcm}(m, n) = \frac{|m\cdot n|}{\text{gcd}(m, n)}
[[/math]]

[[# power-mod-note]]
++ [#power-mod power modulus]

Raise an integer to a integer power, modulo a third integer.

Euler's theorem can often be used to reduce the size of the exponent.

[[# int-residues-note]]
++ [#int-residues integer residues]

The integer residues or integers modulo //n// are the equivalence classes formed by the relation

[[math]]
a\;(\text{mod}\;n) = b\; (\text{mod}\;n)
[[/math]]

An element in of these equivalence classes is called a representative.  We can extend addition and multiplication to the residues by performing integer addition or multiplication on representatives.  This is well-defined in the sense that it does not depend on the representatives chosen.  Addition and multiplication defined this way turn the integer residues into commutative rings with identity.

[[# mult-inverse-note]]
++ [#mult-inverse multiplicative inverse]

How to get the multiplicative inverse for a residue.

If the representative for a residue is relatively prime to the modulus, then the residue has a multiplicative inverse.  For that matter, if the modulus //n// is a prime, then the ring of residues is a field.

Note that we cannot in general find the inverse using a representative, since the only units in the integers are -1 and 1.

By Euler's theorem, we can find a multiplicative inverse by raising it to the power [[$ \phi(n) - 1 $]]:

[[math]]
a^{\phi(n) - 1} \cdot a = a^{\phi(n)} \equiv 1 \;(\text{mod}\;n)
[[/math]]

When //a// doesn't have a multiplicative inverse, then we cannot cancel it from both sides of a congruence.  The following is true, however:

[[math]]
az \equiv az' \;(\text{mod}\; n) \iff z \equiv z' \;\left(\text{mod}\; \frac{n}{\text{gcd}(a, n)}\right)
[[/math]]

[[# chinese-remainder-thm-note]]
++ [#chinese-remainder-thm chinese remainder theorem]

A function which finds a solution to a system of congruences.

The Chinese remainder theorem asserts that there is a solution //x// to the system of  //k//  congruences

[[math]]
x \equiv a_i \;(\text{mod}\;n_i)
[[/math]]

provided that the //n,,i,,// are pairwise relatively prime.  In this case there are an infinite number of solutions, all which are equal modulo [[$ N = n_1 \cdots n_k $]].  For this reason the solution is returned as a residue modulo //N//.

[[# lift-int-residue-note]]
++ [#lift-int-residue lift integer residue]

How to get a representative from the equivalence class of integers modulo //n//.

Typically an integer in [[$ \{0, ..., n - 1\} $]] is chosen.  A centered lift chooses a representative //x// such that [[$ -n/2 < x \leq n/2 $]].

[[# euler-totient-note]]
++ [#euler-totient euler totient]

The Euler totient function is defined for any positive integer //n// as:

[[math]]
\phi(n) = n \prod_{p | n} \frac{p - 1}{p}
[[/math]]

Note that the product is over the primes that divide //n//.

The Euler totient is the number of integers in [[$ \{1, ..., n - 1\} $]] which are relatively prime to //n//.  It is thus the size of the multiplicative group of integers modulo //n//.

The Euler totient appears in Euler's theorem:

[[math]]
a^{\phi(n)} \equiv 1 \;(\text{mod}\;n)
[[/math]]

[[# carmichael-func-note]]
++ [#carmichael-func carmichael function]

The smallest number //k// such that //a^^k^^ â‰¡ 1 (//mod //n)// for all residues //a//.

By Euler's theorem, the Carmichael function Î»(n) is less that or equal to the Euler totient function Ï†(n).  The functions are equal when there are primitive roots modulo //n//.

[[# mult-order-note]]
++ [#mult-order multiplicative order]

The multiplicative order of a residue //a// is the smallest exponent //k// such that

[[math]]
a^k \equiv 1\;(\text{mod}\;n)
[[/math]]

In older literature, it is sometimes said that //a// belongs to the exponent //k// modulo //n//.

[[# primitive-roots-note]]
++ [#primitive-roots primitive roots]

A primitive root is a residue module //n// with multiplicative order //Ï†(n)//.

The multiplicative group is not necessarily cyclic, though it is when //n// is prime.  If it is not cyclic, then there are no primitive roots.

Any primitive root is a generator for the multiplicative group, so it can be used to find the other primitive roots.

[[# discrete-log-note]]
++ [#discrete-log discrete logarithm]

For a residue //x// and a base residue //b//, find a positive integer such that:

[[math]]
b^k \equiv x\;(\text{mod}\; n)
[[/math]]

[[# quadratic-residues-note]]
++ [#quadratic-residues quadratic residues]

A quadratic residue is a non-zero residue //a// which has a square root modulo //p//.  That is, there is //x// such that

[[math]]
x^2 \equiv a \;(\text{mod}\;p)
[[/math]]

If //a// is non-zero and doesn't have a square root, then it is a quadratic non-residue.

[[# discrete-sqrt-note]]
++ [#discrete-sqrt discrete square root]

How to find the square root of a quadratic residue.

[[# kronecker-symbol-note]]
++ [#kronecker-symbol kronecker symbol]

The Legendre symbol is used to indicate whether a number is a quadratic residue and is defined as follows:

[[math]]
\left( \frac{a}{p} \right)  = \begin{cases} \;\; 1 \;\;\; a \; \text{is a quadratic residue} \\ \;\; 0 \;\;\; p \mid a \\ -1 \;\;\; a \; \text{is a quadratic nonresidue} \end{cases}
[[/math]]

The Legendre symbol is only defined when //p// is an odd prime, but if //n// is an odd positive integer with prime factorization

[[math]]
p_1^{\alpha_1} \ldots p_n^{\alpha_n}
[[/math]]

then the Jacobi symbol is defined as

[[math]]
\left( \frac{a}{n} \right) = \left( \frac{a}{p_1} \right)^{\alpha_1} \ldots \left( \frac{a}{p_n} \right)^{\alpha_n}
[[/math]]

The Kronecker symbol is a generalization of the Jacobi symbol to all integers, but we omit the details.

[[# moebius-func-note]]
++ [#moebius-func moebius function]

The MÃ¶bius function //Î¼(n)// is 1, -1, or 0 depending upon when //n// is a square-free integer with an even number of prime factors, a square-free integer with an odd number of prime factors, or an integer which is divisible by //p^^2^^// for some prime //p//.

The MÃ¶bius function is multiplicative: when //a// and //b// are relatively prime, //Î¼(a)Î¼(b) = Î¼(ab)//.

The MÃ¶bius function appears in the MÃ¶bius inversion formula.  If //g// and //f// are possibly complex-valued functions defined on the natural numbers such that for all integers n â‰¥ 1:

[[math]]
g(n) = \sum_{d | n} f(d)
[[/math]]

then for all integers n â‰¥ 1:

[[math]]
f(n) = \sum_{d | n} \mu(d) g(n | d)
[[/math]]

[[# riemann-zeta-func-note]]
++ [#riemann-zeta-func riemann zeta function]

The Riemann zeta function is a complex-valued function defined as the analytic continuation of this series:

[[math]]
\zeta(s) = \sum_{n=1}^\infty \frac{1}{n^s}
[[/math]]

The function has zeros (called the trivial zeros) at -2, -4, ....  All other zeros must lie in the strip 0 â‰¤ â„œ(z) â‰¤ 1.  In 1859 Riemann conjectured that all non-trivial zeros are on the line â„œ(z) = 1/2.

[[# continued-fraction-note]]
++ [#continued-fraction continued fraction]

Convert a real number to a continued fraction.

A continued fraction is a sequence of integers //a,,0,,, a,,1,,, ..., a,,n,,// representing the fraction:

[[math]]
a_0 + \frac{1}{a_1 + \frac{1}{a_2 + \frac{1}{\ddots + {\frac{1}{a_n}}}}} 
[[/math]]

The sequence can even be infinite, in which case the fraction is the limit of the rational numbers defined by taking the first //n// digits in the sequence.

A continued fraction for a real number can be computed using the Euclidean algorithm.  In the case of a rational number, one starts with the numerator and the denominator.  In the case of a rational number, one can start with the number itself and 1.

A continued fraction is finite if and only if the number is a rational.

A continued fraction repeats if and only if it is a quadratic irrational.

[[# convergents-note]]
++ [#convergents convergents]

The first //n// digits of a continued fraction define a sequence of rational numbers called the //convergents//.    The rational numbers converge to the number defined by the continued fraction.

Each convergent //r/q// is the closest rational number to the continued fraction with denominator of size //q// or smaller.

[[# polynomials-note]]
+ [#polynomials Polynomials]

[[# polynomial-literal-note]]
++ [#polynomial-literal literal]

[[# extract-polynomial-coefficient-note]]
++ [#extract-polynomial-coefficient extract coefficient]

[[# extract-polynomial-coefficients-note]]
++ [#extract-polynomial-coefficients extract coefficients]

[[# polynomial-from-coefficient-array-note]]
++ [#polynomial-from-coefficient-array from array of coefficients]

[[# polynomial-degree-note]]
++ [#polynomial-degree degree]

[[# expand-polynomial-note]]
++ [#expand-polynomial expand]

[[# factor-polynomial-note]]
++ [#factor-polynomial factor]

[[ #collect-terms-note]]
++ [#collect-terms collect terms]

[[# polynomial-roots-note]]
++ [#polynomial-root roots]

[[# polynomial-quotient-remainder-note]]
++ [#polynomial-quotient-remainder quotient and remainder]

[[# polynomial-gcd-note]]
++ [#polynomial-gcd greatest common divisor]

++ extended euclidean algorithm

++ resultant

++ discriminant

++ groebner basis

++ specify ordering

++ elementary symmetric polynomial

++ symmetric reduction

[[# cyclotomic-polynomial-note]]
++ [#cyclotomic-polynomial cyclotomic polynomial]

[[# hermite-polynomial-note]]
++ [#hermite-polynomial hermite polynomial]

[[# chebyshev-polynomial-note]]
++ [#chebyshev-polynomial chebyshev polynomial]

++ interpolation polynomial

++ spline

[[# add-fractions-note]]
++ [#add-fractions add fractions]

[[# partial-fraction-decomposition-note]]
++ [#parial-fraction-decomposition partial fraction decomposition]

[[# pade-approximant-note]]
++ [#pade-approximant pade approximant]

[[# trigonometry-note]]
+ [#trigonometry Trigonometry]

[[# trig-eliminate-powers-products-note]]
++ [#trig-eliminate-powers-products eliminate powers and products of trigonometric functions]

[[# trig-eliminate-sums-multiples-note]]
++ [#trig-eliminate-sums-multiples eliminate sums and multiples inside trigonometric functions]

[[# trig-to-exp-note]]
++ [#trig-to-exp trigonometric to exponential]

[[# exp-to-trig-note]]
++ [#exp-to-trig exponential to trigonometric]

[[# fourier-expansion-note]]
++ [#fourier-expansion fourier expansion]

[[# periodic-func-note]]
++ [#periodic-func periodic functions on unit interval]

[[# fourier-transform-note]]
++ [#fourier-transform fourier transform]

[[# heaviside-step-func-note]]
++ [#heaviside-step-func heaviside step function]

[[# dirac-delta-note]]
++ [#dirac-delta dirac delta]

[[# special-functions-note]]
+ [#special-functions Special Functions]

[[# gamma-func-note]]
++ [#gamma-func gamma function]

The gamma function is defined for all complex numbers except the non-positive integers.

For positive integers, the following equation holds:

[[math]]
\Gamma(n) = (n-1)!
[[/math]]

If the real part of //t// is positive, then

[[math]]
\Gamma(t) = \int_0^\infty x^{t-1} e^{-x} dx
[[/math]]

[[# err-func-note]]
++ [#err-func error function]

The error function is function from â„ to [-1, 1] defined by:

[[math]]
\mathrm{erf}(x) = \frac{2}{\sqrt(\pi)} \int_0^x e^{-t^2} dt
[[/math]]

The complementary error function is

[[math]]
\mathrm{erfc}(x) = 1 - erf(x)
[[/math]]

The cumulative distribution of the standard normal distribution is related to the error function by scaling:

[[math]]
\Phi(x) = \frac{1}{2} + \frac{1}{2} \mathrm{erf}(\frac{x}{\sqrt(2)}) = \frac{1}{2} \mathrm{erfc}(\frac{-x}{\sqrt(2)})
[[/math]]


[[# hyperbolic-func-note]]
++ [#hyperbolic-func hyperbolic functions]

Definitions of the hyperbolic functions:

[[math]]
\mathrm{sinh}\;x = \frac{e^x - e^{-x}}{2}
[[/math]]

[[math]]
\mathrm{cosh}\;x = \frac{e^x + e^{-x}}{2}
[[/math]]

[[math]]
\mathrm{tanh}\;x = \frac{\mathrm{sinh}\;x}{\mathrm{cosh}\;x}
[[/math]]

{{sinh}} and {{cosh}} are odd and even functions, respectively.  Like e^^x^^ and e^^-x^^, {{sinh}} and {{cosh}} span the linear space of solutions to {{y''(x) = y(x)}}.

[[# elliptic-func-note]]
++ [#elliptic-func elliptic functions]

[[# bessel-func-note]]
++ [#bessel-func bessel functions]

[[# permutations-note]]
+ [#permutations Permutations]

A permutation is a bijection on a set of //n// elements.

The notation that Mathematica uses assumes the set the permutation operates on is indexed by {1, .., n}.  The notation that SymPy uses assumes the set is indexed by {0, ..., n - 1}.

//Cayley two line notation//

//one line notation//

//cycle notation//

//inversions//

[[# permutation-from-disjoint-cycles-note]]
++ [#permutation-from-disjoint-cycles from disjoint cycles]

[[# permutation-to-disjoint-cycles-note]]
++ [#permutation-to-disjoint-cycles to disjoint cycles]

[[# permutation-from-array-note]]
++ [#permutation-from-array from array]

[[# permutation-from-two-arrays-note]]
++ [#permutation-from-two-arrays from two arrays with same elements]

[[# permutation-size-note]]
++ [#permutation-size size]

[[# permutation-support-note]]
++ [#permutation-support support]

[[# permutation-act-on-element-note]]
++ [#permutation-act-on-element act on element]

[[# permutation-act-on-list-note]]
++ [#permutation-act-on-list act on list]

[[# permutation-compose-note]]
++ [#permutation-compose compose]

[[# permutation-inverse-note]]
++ [#permutation-inverse inverse]

[[# permutation-power-note]]
++ [#permutation-power power]

[[# permutation-order-note]]
++ [#permutation-order order]

[[# permutation-num-inversions-note]]
++ [#permutation-num-inversions number of inversions]

[[# permutation-parity-note]]
++ [#permutation-parity parity]

Permutations are classified as even or odd based on the number of inversions.

The composition of two even permutations is even.

[[# permutation-to-inversion-vec-note]]
++ [#permutation-to-inversion-vec to inversion vector]

[[# permutation-from-inversion-vec-note]]
++ [#permutation-from-inversion-vec from inversion vector]

[[# permutation-list-note]]
++ [#permutation-list list permutations]

[[# permutation-random-note]]
++ [#permutation-random random permutation]

[[# descriptive-statistics-note]]
+ [#descriptive-statistics Descriptive Statistics]

[[# distributions-note]]
+ [#distributions Distributions]

[[# statistical-tests-note]]
+ [#statistical-tests Statistical Tests]

A selection of statistical tests.  For each test the null hypothesis of the test is stated in the left column.

In a null hypothesis test one considers the //p-value//, which is the chance of getting data which is as or more extreme than the observed data if the null hypothesis is true.  The null hypothesis is usually a supposition that the data is drawn from a distribution with certain parameters.

The extremeness of the data is determined by comparing the expected value of a parameter according to the null hypothesis to the estimated value from the data.  Usually the parameter is a mean or variance.  In a //one-tailed test// the p-value is the chance the difference is greater than the observed amount; in a //two-tailed test// the p-value is the chance the absolute value of the difference is greater than the observed amount. 

[[# wilcoxon-note]]
++ [#wilcoxon wilcoxon signed-rank test]

A non-parametric est whether a variable is drawn from a distribution that is symmetric about zero.

Often this test is used to test that the mean of the distribution is zero.

[[# kruskal-note]]
++ [#kruskal kruskal-wallis rank sum test]

A non-parametric test whether variables have the same mean.

For two variables, this test is the same as the Mann-Whitney test.

**maxima:**

The Maxima function only supports testing two variables.

[[# kolmogorov-smirnov-test-note]]
++ [#kolmogorov-smirnov-test kolmogorov-smirnov test]

Test whether two samples are drawn from the same distribution.

[[# one-sample-t-test-note]]
++ [#one-sample-t-test one-sample t-test]

Student's t-test determines whether a sample drawn from a normal distribution has mean zero.

The test can be used to test for a different mean value; just subtract the value from each value in the sample.

One may know in advance that the sample is drawn from a normal distribution.  For example, if the values in the sample are each means of large samples, then the distribution is normal by the central limit theorem.

The Shapiro-Wilk test can be applied to determine if the values come from a normal distribution.

If the distribution is not known to be normal, the Wilcoxon signed-rank test can be used instead.

The Student's t-test used the sample to estimate the variance, and as a result the test statistic has a t-distribution.

By way of contrast, the z-test assumes that the variance is known in advance, and simply scales the data to get a z-score, which has standard normal distribution.

[[# independent-two-sample-t-test-note]]
++ [#independent-two-sample-t-test independent two-sample t-test]

Test whether two normal variables have same mean.

[[# paired-sample-t-test-note]]
++ [#paired-t-test paired sample t-test]

A t-test used when the same individuals are measure twice.

[[# one-sample-binomial-test-note]]
++ [#one-sample-binomial-test one-sample binomial test]

[[# two-sample-binomial-test-note]]
++ [#two-sample-binomial-test two-sample binomial test]

[[# chi-squared-test-note]]
++ [#chi-squared-test chi-squared test]

[[# poisson-test-note]]
++ [#poisson-test poisson test]

[[# f-test-note]]
++ [#f-test F test]

[[# pearson-product-moment-test-note]]
++ [#pearson-product-moment-test pearson product moment test]

[[# spearman-rank-test-note]]
++ [#spearman-rank-test pearson spearman rank test]

[[# shapiro-wilk-test-note]]
++ [#shapiro-wilk-test shapiro-wilk test]

[[# bartletts-test-note]]
++ [#bartletts-test bartlett's test]

A test whether variables are drawn from normal distributions with the same variance.

[[# levene-test-note]]
++ [#levene-test levene's test]

A test whether variables are drawn from distributions with the same variance.

[[# one-way-anova-note]]
++ [#one-way-anova one-way anova]

[[# two-way-anova-note]]
++ [#two-way-anova two-way anova]

[[# bar-charts-note]]
+ [#bar-charts Bar Charts]

[[# vertical-bar-chart-note]]
++ [#vertical-bar-chart vertical bar chart]

A chart in which the height of bars is used to represent a list of numbers.

**maxima:**

Maxima plots the frequency of the values, and not the values themselves.  Non-positive values cannot be represented.

[[# horizontal-bar-chart-note]]
++ [#horizontal-bar-chart horizontal bar chart]

A bar chart in which zero is the y-axis and the bars extend to the right.

[[# grouped-bar-chart-note]]
++ [#grouped-bar-chart grouped bar chart]

[[# stacked-bar-chart-note]]
++ [#stacked-bar-chart stacked bar chart]

[[# pie-chart-note]]
++ [#pie-chart pie chart]

**maxima:**

Note that Maxima plots the frequency of the values, and not the values themselves.

[[# histogram-note]]
++ [#histogram histogram]

A histogram is a bar chart in which each bar represents the frequency of values in a data set within a range.  The width of the bars can be used to indicate the ranges.

[[# box-plot-note]]
++ [#box-plot box plot]

[[# scatter-plots-note]]
+ [#scatter-plots Scatter Plots]

[[# strip-chart-note]]
++ [#strip-chart strip chart]

A strip chart represents a list of values by points on a line. The values are converted to pairs by assigning the y-coordinate a constant value of zero.  Pairs are then displayed with a scatter plot.

[[# strip-chart-jitter-note]]
++ [#strip-chart-jitter strip chart with jitter]

A strip chart in which in which a random variable with small range is used to fill the y-coordinate. Jitter makes it easier to see how many values are in dense regions.

[[# scatter-plot-note]]
++ [#scatter-plot scatter plot]

How to plot a list of pairs of numbers by representing the pairs as points in the (x, y) plane.

[[# additional-point-set-note]]
++ [#additional-point-set additional point set]

How to add a second list of pairs of numbers to a scatter plot.  Color can be used to distinguish the two data sets.

[[# point-types-note]]
++ [#point-types point types]

How to select the symbols used to mark data points.  Choice of symbols can be use to distinguish data sets.

[[# point-size-note]]
++ [#point-size point size]

How to change the size of the symbols used to mark points.

[[# scatter-plot-matrix-note]]
++ [#scatter-plot-matrix scatter plot matrix]

A scatter plot matrix is a way of displaying a multivariate data set by means of a grid of scatter plots.  Off-diagonal plots are scatter plots of two of the variables.  On-diagonal plots can be used to to display the name or a histogram of one of the variables.

[[# scatter-plot-3d-note]]
++ [#scatter-plot-3d 3d scatter plot]

How to represent a list of triples of numbers by points in (x, y, z) space.

[[# bubble-chart-note]]
++ [#bubble-chart bubble chart]

How to represent a list of triples of numbers by position in the (x, y) plane and size of the point marker.

It is probably better to associate the 3rd component of each triple with the //area//, and not the //diameter// of the point marker, but in general bubble charts suffer from ambiguity.

[[# linear-regression-line-note]]
++ [#linear-regression-line linear regression line]

How to add a linear regression line to a scatter plot.

[[# q-q-plot-note]]
++ [#q-q-plot quantile-quantile plot]

[[# line-charts-note]]
+ [#line-charts Line Charts]

[[# polygonal-line-plot-note]]
++ [#polygonal-line-plot polygonal line plot]

[[# additional-line-note]]
++ [#additional-line additional line]

[[# line-types-note]]
++ [#line-types line types]

[[# line-thickness-note]]
++ [#line-thickness line thickness]

[[# function-plot-note]]
++ [#function-plot function plot]

[[# parametric-plot-note]]
++ [#parametric-plot parametric plot]

[[# implicit-plot-note]]
++ [#implicit-plot implicit plot]

[[# polar-plot-note]]
++ [#polar-plot polar plot]

[[# cubic-spline-note]]
++ [#cubic-spline cubic spline]

[[# area-chart-note]]
++ [#area-chart area chart]

[[# surface-charts-note]]
+ [#surface-charts Surface Charts]

[[# contour-plot-note]]
++ [#contour-plot contour plot]

[[# heat-map-note]]
++ [#heat-map heat map]

[[# shaded-surface-plot-note]]
++ [#shaded-surface-plot shaded surface plot]

[[# light-source-note]]
++ [#light-source light source]

[[# mesh-surface-plot-note]]
++ [#mesh-surface-plot mesh surface plot]

[[# view-point-note]]
++ [#view-point view point]

[[# vector-field-plot-note]]
++ [#vector-field-plot vector field plot]

[[# chart-options-note]]
+ [#chart-options Chart Options]

[[# chart-title-note]]
++ [#chart-title chart title]

[[# axis-label-note]]
++ [#axis-label axis label]

[[# legend-note]]
++ [#legend legend]

[[# data-label-note]]
++ [#data-label data label]

[[# named-colors-note]]
++ [#named-colors named colors]

[[# rgb-color-note]]
++ [#rgb-color rgb color]

[[# background-color-note]]
++ [#background-color background color]

[[# axis-limits-note]]
++ [#axis-limits axis limits]

[[# logarithmic-y-axis-note]]
++ [#logarithmic-y-axis logarithmic y-axis]

[[# aspect-ratio-note]]
++ [#aspect-ratio aspect ratio]

[[# ticks-note]]
++ [#ticks ticks]

[[# grid-lines-note]]
++ [#grid-lines grid lines]

[[# grid-of-subplots-note]]
++ [#grid-of-subplots grid of subplots]

[[# save-plot-as-png-note]]
++ [#save-plot-as-png save plot as png]

[[# mathematica]]
+ [#top Mathematica]

[http://reference.wolfram.com/mathematica/guide/Mathematica.html Mathematica Documentation Center]
[http://wolframalpha.com WolframAlpha]

[[# maple]]
+ [#top Maple]

http://www.maplesoft.com/support/help/

[[# maxima]]
+ [#top Maxima]

http://maxima.sourceforge.net/docs/manual/maxima.html

[[# sage]]
+ [#top Sage]

http://doc.sagemath.org/html/en/index.html

[[# sympy]]
+ [#top SymPy]

[http://docs.sympy.org/latest/index.html Welcome to SymPyâ€™s documentation!]