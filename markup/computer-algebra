//a side-by-side reference sheet//

[#grammar-invocation grammar and invocation] | [#var-expr variables and expressions] | [#arithmetic-logic arithmetic and logic] | [#strings strings] | [#arrays arrays] | [#sets sets] | [#arith-seq arithmetic sequences] | [#dictionaries dictionaries] | [#functions functions] | [#execution-control execution control] | [#exceptions exceptions] | [#streams streams] | [#files files] | [#directories directories] | [#libraries-namespaces libraries and namespaces] |  [#reflection reflection]
 
[#symbolic-expr symbolic expressions] | [#calculus calculus] | [#equations-unknowns equations and unknowns] | [#optimization optimization] | [#vectors vectors] | [#matrices matrices] | [#combinatorics combinatorics] | [#number-theory number theory] |  [#polynomials polynomials] | [#trigonometry trigonometry] | [#special-functions special functions] | [#permutations permutations] | [#groups groups] | [#subgroups subgroups] | [#group-homomorphisms group homomorphisms] | [#actions actions] | [#descriptive-statistics descriptive statistics] | [#distributions distributions] 

[#univariate-charts univariate charts] | [#bivariate-charts bivariate charts] | [#trivariate-charts trivariate charts]

||~ ||~ [#mathematica mathematica]||~ [#maple maple]||~ [#maxima maxima]||~ [#sympy sympy]||
||[[# version-used]][#version-used-note version used] _
@<&nbsp;>@||##gray|//10.0//##||##gray|//2016//##||##gray|//5.37//##||##gray|//Python 2.7; SymPy 0.7//##||
||[[# show-version]][#show-version-note show version] _
@<&nbsp;>@||##gray|//select// About Mathematica //in// Mathematica //menu//##||##gray|//select// About Maple //in// Maple //menu//##||$ maxima @@--@@version||@@sympy.__version__@@||
||[[# implicit-prologue]][#implicit-prologue-note implicit prologue]|| || || ||import sympy _
 _
##gray|# enable LaTeX rendering in Jupyter notebook:## _
sympy.init_printing() _
 _
##gray|# unknown variables must be declared:## _
x, y = sympy.symbols('x y')||
||||||||||~ [[# grammar-invocation]][#grammar-invocation-note grammar and invocation]||
||~ ||~ mathematica||~ maple||~ maxima||~ sympy||
||[[# interpreter]][#interpreter-note interpreter] _
@<&nbsp;>@||$ cat @@>>@@ hello.m _
Print["Hello, World!"] _
 _
$  MathKernel -script hello.m|| ||$ cat @@>>@@ hello.max _
print("Hello, world!"); _
 _
$ maxima -b hello.maxima||##gray|//if// foo.py //imports sympy://## _
$ python ##gray|//foo//##.py||
||[[# repl]][#repl-note repl] _
@<&nbsp;>@||$ MathKernel||$ maple||$ maxima||$ python _
@@>>>@@ import sympy||
||[[# block-delimiters]][#block-delimiters-note block delimiters] _
@<&nbsp;>@||( ##gray|//stmt//##; ##gray|//...//##)|| ||block([x: 3, y: 4], x + y); _
 _
##gray|/* Multiple stmts are separated by commas; a list of assignments can be used to set variables local to the block. */##||: ##gray|//and offside rule//##||
||[[# stmt-separator]][#stmt-separator-note statement separator]||; ##gray|//or sometimes newline//## _
 _
##gray|//A semicolon suppresses echoing value of previous expression.//##||; ##gray|//or//## : _
 _
##gray|//The colon// : //suppresses output.//## _
 _
##gray|//In the worksheet, typing// RETURN //causes a cell to be evaluated.  The expression in the cell does not have to end with a semicolon.  To enter a newline in a cell, use// SHIFT + RETURN. _
 _
//In the command line REPL, a statement is terminated by a semicolon.//##||; ##gray|//or//## $ _
 _
##gray|//The dollar sign// $ //suppresses output.//##||##gray|//newline or//## ; _
 _
##gray|//newlines not separators inside (), [], {}, triple quote literals, or after backslash: @@\@@//##||
||[[# eol-comment]][#eol-comment-note end-of-line comment] _
@<&nbsp;>@||##gray|//none//##||1 + 1; ##gray|# addition##|| ||1 + 1 ##gray|# addition##||
||[[# multiple-line-comment]][#multiple-line-comment-note multiple line comment] _
@<&nbsp;>@||1 + ##gray|(* addition *)## 1||1 + ##gray|(* addition *)## 1;||1 + ##gray|/* addition */## 1;||##gray|//none//##||
||||||||||~ [[# var-expr]][#var-expr-note variables and expressions]||
||~ ||~ mathematica||~ maple||~ maxima||~ sympy||
||[[# assignment]][#assignment-note assignment]||a = 3 _
Set[a, 3] _
 _
##gray|(* rhs evaluated each time a is accessed: *)## _
a := x + 3 _
SetDelayed[a, x + 3]||a := 3; _
 _
##gray|# rhs evaluated each time a is accessed:## _
a := 'x + 3';||a: 3;||a = 3||
||[[# parallel-assignment]][#parallel-assignment-note parallel assignment]||{a, b} = {3, 4} _
Set[{a, b}, {3, 4}]||a, b := 3, 4;||[a, b]: [3, 4]||a, b = 3, 4||
||[[# compound-assignment]][#compound-assignment-note compound assignment]||+= -= *= /= _
##gray|//corresponding functions://## _
AddTo SubtractFrom TimeBy DivideBy|| || ||+= -= *= /= @@//=@@ %= @@**=@@||
||[[# incr-decr]][#incr-decr-note increment and decrement]||++x @@--@@x _
PreIncrement[x] PreDecrement[x] _
x++ x@@--@@ _
Increment[x] Decrement[x]|| || ||##gray|//none//##||
||[[# non-referential-id]][#non-referential-id-note non-referential identifier]||##gray|//any unassigned identifier is non-referential//##||##gray|//any unassigned identifier is non-referential//##||##gray|//any unassigned identifier is non-referential//##||x, y, z, w = sympy.symbols('x y z w')||
||[[# id-as-val]][#id-as-val-note identifier as value]||x = 3 _
y = HoldForm[x]|| || || ||
||[[# global-var]][#global-var-note global variable]||##gray|//variables are global by default//##|| || ||g1, g2 = 7, 8 _
 _
def swap_globals(): _
@<&nbsp;&nbsp;>@global g1, g2 _
@<&nbsp;&nbsp;>@g1, g2 = g2, g1||
||[[# local-var]][#local-var-note local variable]||Module[{x = 3, y = 4}, Print[x + y]] _
 _
##gray|(* makes x and y read-only: *)## _
With[{x = 3, y = 4}, Print[x + y]] _
 _
##gray|(* Block[ ] declares dynamic scope *)##|| || ||##gray|//assignments inside functions are to local variables by default//##||
||[[# null]][#null-note null] _
@<&nbsp;>@||Null|| || ||None||
||[[# null-test]][#null-test-note null test] _
@<&nbsp;>@||x == Null|| || ||x is None||
||[[# undef-var]][#undef-var-note undefined variable access] _
@<&nbsp;>@||##gray|//treated as an unknown number//##||##gray|//treated as an unknown number//##||##gray|//treated as an unknown number//##||##gray|//raises// NameError##||
||[[# rm-var-binding]][#rm-var-binding-note remove variable binding]||Clear[x] _
Remove[x]||x := 'x'||kill(x);||del x||
||[[# cond-expr]][#cond-expr-note conditional expression] _
@<&nbsp;>@||If[x > 0, x, -x]||if x < 0 then -x else x end if;||if x < 0 then -x else x;||x if x > 0 else -x||
||||||||||~ [[# arithmetic-logic]][#arithmetic-logic-note arithmetic and logic]||
||~ ||~ mathematica||~ maple||~ maxima||~ sympy||
||[[# true-false]][#true-false-note true and false] _
@<&nbsp;>@||True False||true false||true false||True False||
||[[# falsehoods]][#falsehoods-note falsehoods] _
@<&nbsp;>@||False|| || ||False 0 0.0||
||[[# logical-op]][#logical-op-note logical operators]||! True @@||@@ (True && False) _
Or[Not[True], And[True, False]]||and or not||and or not||sympy.Or(sympy.Not(True), sympy.And(True, False)) _
 _
##gray|# when arguments are symbols:## _
@@~ x | (y & z)@@||
||[[# relational-expr]][#relational-expr-note relational expression]||1 < 2||evalb(1 < 2);||is(1 < 2);|| ||
||[[# relational-op]][#relational-op-note relational operators]||== != > < >= <= _
##gray|//corresponding functions://## _
Equal Unequal Greater Less GreaterEqual LessEqual||@@=@@ != > < >= <=||@@=@@ # > < >= <=||sympy.Eq sympy.Ne sympy.Gt sympy.Lt sympy.Ge sympy.Le _
 _
##gray|# when arguments are symbols:## _
== != > < >= <=||
||[[# arith-op]][#arith-op-note arithmetic operators]||+ - * / Quotient Mod _
##gray|//adjacent terms are multiplied, so * is not necessary.// Quotient //and// Mod //are functions, not binary infix operators.  These functions are also available://## _
Plus Subtract Times Divide||+ - * / iquo mod _
 _
##gray|iquo //and// mod //are functions//##||+ - * / quotitent() mod() _
 _
##gray|quotient //and// mod //are functions, not binary infix operators.//##||+ - * / ##gray|//??//## % _
 _
##gray|//if an expression contains a symbol, then the above operators are rewritten using the following classes://## _
sympy.Add sympy.Mul sympy.Pow sympy.Mod||
||[[# int-div]][#int-div-note integer division] _
@<&nbsp;>@||Quotient[a, b]||iquo(7, 3);||quotient(7, 3);|| ||
||[[# int-div-zero]][#int-div-zero-note integer division by zero]||##gray|//dividend is zero://## _
Indeterminate _
##gray|//otherwise://## _
ComplexInfinity||##gray|//error, numeric exception//##||##gray|//error//##|| ||
||[[# float-div]][#float-div-note float division]||##gray|//exact division://## _
a / b||##gray|# exact division:## _
a / b; _
 _
##gray|# float division:## _
a * 1.0 / b;||a / b|| ||
||[[# float-div-zero]][#float-div-zero-note float division by zero]||##gray|//dividend is zero://## _
Indeterminate _
##gray|//otherwise://## _
ComplexInfinity||float(infinity) _
float(undefined) _
-float(infinity)||##gray|//error//##|| ||
||[[# power]][#power-note power]||2 ^ 32 _
Power[2, 32]||2 ^ 32 _
 _
##gray|//The worksheet rewrites the expression using a superscript.  Do not put spaces around the operator.//##||2 ^ 32; _
2 @@**@@ 32;||2 @@**@@ 32 _
sympy.Pow(2, 32)||
||[[# sqrt]][#sqrt-note sqrt]||##gray|//returns symbolic expression://## _
Sqrt[2]||sqrt(2)||sqrt(2);||sympy.sqrt(2)||
||[[# sqrt-negative-one]][#sqrt-negative-one-note sqrt -1] _
@<&nbsp;>@||I||I||%i||sympy.I||
||[[# transcendental-func]][#transcendental-func-note transcendental functions]||Exp Log _
Sin Cos Tan _
ArcSin ArcCos ArcTan _
ArcTan _
##gray|ArcTan //accepts 1 or 2 arguments//##||exp log _
sin cos tan _
arcsin arccos _
arctan(##gray|//y//##, ##gray|//x//##)||exp log _
sin cos tan _
asin acos atan _
atan2||symp.exp sympy.log _
sympy.sin sympy.cos sympy.tan _
sympy.asin sympy.acos sympy.atan _
sympy.atan2||
||[[# transcendental-const]][#transcendental-const-note transcendental constants] _
##gray|//Ï€ and Euler's number//##||Pi E EulerGamma||Pi exp(1) gamma||%pi %e %gamma||sympy.pi sympy.E||
||[[# float-truncation]][#float-truncation-note float truncation] _
##gray|//round towards zero, round to nearest integer, round down, round up//##||IntegerPart Round Floor Ceiling||trunc round floor ceil||truncate _
round _
floor _
ceiling||sympy.floor _
sympy.ceiling||
||[[# absolute-val]][#absolute-val-note absolute value] _
##gray|//and signum//##||Abs Sign||abs sign||abs sign _
 _
##gray|sign //returns// pos, neg, //or// zero##||sympy.Abs sympy.sign||
||[[# int-overflow]][#int-overflow-note integer overflow] _
@<&nbsp;>@||##gray|//none, has arbitrary length integer type//##||##gray|//none, has arbitrary length integer type//##||##gray|//none, has arbitrary length integer type//##||##gray|//none, has arbitrary length integer type//##||
||[[# float-overflow]][#float-overflow-note float overflow] _
@<&nbsp;>@||##gray|//none//##|| ||##gray|//none//##|| ||
||[[# rational-construction]][#rational-construction-note rational construction]||2 / 7||2 / 7||2 / 7||sympy.Mul(2, sympy.Pow(7, -1))||
||[[# rational-decomposition]][#rational-decomposition-note rational decomposition] _
@<&nbsp;>@||Numerator[x/y] _
Denominator[x/y]||numer(2 / 7) _
denom(2 / 7)||num(2 / 7); _
denom(2 / 7);||numer, denom = sympy.fraction(x, y)||
||[[# decimal-approx]][#decimal-approx-note decimal approximation]||N[2 / 7] _
2 / 7 + 0. _
2 / 7 @@//@@ N _
N[2 / 7, 100]||evalf(2 / 7) _
2 / 7 + 0.0 _
evalf[100](2 / 7) _
 _
##gray|# use hardware floats:## _
evalhf(2 / 7);||2 / 7, numer;||sympy.N(sympy.Rational(2, 7)) _
sympy.N(sympy.Rational(2, 7), 100)||
||[[# complex-construction]][#complex-construction-note complex construction] _
@<&nbsp;>@||1 + 3I||1 + 3I||1 + 3 * %i;||1 + 3 * sympy.I||
||[[# complex-decomposition]][#complex-decomposition-note complex decomposition] _
##gray|//real and imaginary part, argument and modulus, conjugate//##||Re Im _
Arg Abs _
Conjugate||Re Im _
argument abs _
conjugate||realpart imagpart _
cabs carg _
conjugate||sympy.re sympy.im _
sympy.Abs sympy.arg _
sympy.conjugate||
||[[# random-num]][#random-num-note random number] _
##gray|//uniform integer, uniform float//##||RandomInteger[{0, 99}] _
RandomReal[]||rgen := rand(0..99); _
rgen(); _
 _
rgen := rand(0.0 .. 1.0); _
rgen();||random(100); _
random(1.0);|| ||
||[[# random-seed]][#random-seed-note random seed] _
##gray|//set, get//##||SeedRandom[17] _
##gray|//??//##|| ||set_random_state(make_random_state(17)); _
##gray|//??//##|| ||
||[[# bit-op]][#bit-op-note bit operators]||BitAnd[5, 1] _
BitOr[5, 1] _
BitXor[5, 1] _
BitNot[5] _
BitShiftLeft[5, 1] _
BitShiftRight[5, 1]||with(Bits): _
 _
And(5, 1) _
Or(5, 1) _
Xor(5, 1) _
Not(1, bits=32) _
Join([0, op(Split(5))]) _
Join(subsop(1 = NULL, Split(5)))|| || ||
||[[# binary-octal-hex-literals]][#binary-octal-hex-literals-note binary, octal, and hex literals]||2@@^^@@101010 _
8@@^^@@52 _
16@@^^@@2a|| || || ||
||[[# radix]][#radix-note radix]||BaseForm[42, 7] _
BaseForm[7^^60, 10]||##gray|# [0, 6]:## _
convert(42, base, 7)|| || ||
||[[# to-array-of-digits]][#to-array-of-digits-note to array of digits]||##gray|(* base 10: *)## _
IntegerDigits[1234] _
##gray|(* base 2: *)## _
IntegerDigits[1234, 2]||convert(1234, base, 10) _
convert(1234, base, 2)|| || ||
||||||||||~ [[# strings]][#strings-note strings]||
||~ ||~ mathematica||~ maple||~ maxima||~ sympy||
||[[# str-literal]][#str-literal-note string literal] _
@<&nbsp;>@||"don't say \"no\""||"don't say \"no\""||"don't say \"no\""||##gray|//use//## [[[scripting#strings|Python strings]]]||
||[[# newline-in-str-literal]][#newline-in-str-literal-note newline in literal] _
@<&nbsp;>@||##gray|//yes//##||##gray|//Yes.  String literals separated only by spaces or linebreaks are merged into a single literal.//##||##gray|//Newlines are inserted into strings by continuing the string on the next line.  However, if the last character on a line inside a string is a backslash, the backslash and the following newline are omitted.//##|| ||
||[[# str-literal-esc]][#str-literal-esc-note literal escapes]||\\ \" \b \f \n \r \t \##gray|//ooo//##|| ||\" \\|| ||
||[[# str-concat]][#str-concat-note concatenate] _
@<&nbsp;>@||"one " <> "two " <> "three"||"one "@@||@@"two "@@||@@"three"; _
cat("one ", "two ", "three");||concat("one ", "two ", "three");|| ||
||[[# translate-case]][#translate-case-note translate case]||ToUpperCase["foo"] _
ToLowerCase["FOO"]||with(StringTools): _
 _
UpperCase("foo"); _
LowerCase("FOO");||supcase("foo"); _
sdowncase("FOO");|| ||
||[[# trim]][#trim-note trim] _
@<&nbsp;>@||StringTrim[" foo "]||with(StringTools): _
 _
Trim(" foo ");||strim(" ", " foo ");|| ||
||[[# num-to-str]][#num-to-str-note number to string] _
@<&nbsp;>@||"value: " <> ToString[8]||cat("value: ", 8);||concat("value: ", 8);|| ||
||[[# str-to-num]][#str-to-num-note string to number]||7 + ToExpression["12"] _
73.9 + ToExpression[".037"]||7 + parse("12"); _
73.9 + parse(".037");||7 + parse_string("12"); _
73.9 + parse_string(".037"); _
 _
##gray|/* parse_string raises error if the string does _
not contain valid Maxima code.  Use numberp _
predicate to verify that the return value is _
numeric. */##|| ||
||[[# str-join]][#str-join-note string join]||StringJoin[Riffle[{"foo", "bar", "baz"}, ","]]||with(StringTools): _
 _
Join(["foo", "bar", "baz"], ",");||simplode(["foo", "bar", "baz"], ",");|| ||
||[[# split]][#split-note split] _
@<&nbsp;>@||StringSplit["foo,bar,baz", ","]||with(StringTools): _
 _
Split("foo,bar,baz", ",");||split("foo,bar,baz", ",");|| ||
||[[# str-subst]][#str-subst-note substitute] _
 _
##gray|//first occurrence, all occurences//## ||s = "do re mi mi" _
re = RegularExpression["mi"] _
 _
StringReplace[s, re -> "ma", 1] _
StringReplace[s, re -> "ma"]||with(StringTools): _
 _
Substitute("do re mi mi mi", "mi", "ma"); _
SubstituteAll("do re mi mi mi", "mi", "ma"); _
 _
##gray|# supports regexes:## _
RegSubs("mi"="ma", "do re mi mi mi");||ssubst("mi", "ma", "do re mi mi mi"); _
ssubstfirst("mi", "ma", "do re mi mi mi");|| ||
||[[# str-len]][#str-len-note length] _
@<&nbsp;>@||StringLength["hello"]||length("hello");||slength("hello");|| ||
||[[# index-substr]][#index-substr-note index of substring]||StringPosition["hello", "el"][[1]][[1]] _
 _
##gray|(* The index of the first character is 1.*)## _
 _
##gray|(* StringPosition returns an array of pairs, one for each occurrence of the substring.  Each pair contains the index of the first and last character of the occurrence. *)##||searchtext("el", "hello"); _
 _
##gray|# Index of first character is 1. _
# Returns 0 if not found.##||ssearch("el", "hello"); _
 _
##gray|/* 1 is index of first character; _
returns false if substring not found */## _|| ||
||[[# extract-substr]][#extract-substr-note extract substring]||##gray|(* "el": *)## _
StringTake["hello", {2, 3}]||substring("hello", 2..3);||substring("hello", 2, 4);|| ||
||[[# char-literal]][#char-literal-note character literal] _
@<&nbsp;>@||##gray|//none//##||##gray|//none//##||##gray|//none//##|| ||
||[[# lookup-char]][#lookup-char-note character lookup]||Characters["hello"][[1]]||##gray|# string of length 1:## _
"hello"[1]|| || ||
||[[# chr-ord]][#chr-ord-note chr and ord]||FromCharacterCode[{65}] _
ToCharacterCode["A"][[1]]||with(StringTools): _
 _
Char(65); _
Ord("A")||ascii(65); _
cint("A");|| ||
||[[# delete-char]][#delete-char-note delete characters]||rules = {"a" -> "", "e" -> "", "i" -> "", _
@<&nbsp;&nbsp;>@"o" -> "", "u" -> ""} _
StringReplace["disemvowel me", rules]||with(StringTools): _
 _
Remove(IsVowel, "disemvowel me");|| || ||
||||||||||~ [[# arrays]][#arrays-note arrays]||
||~ ||~ mathematica||~ maple||~ maxima||~ sympy||
||[[# array-literal]][#array-literal-note literal]||{1, 2, 3} _
 _
List[1, 2, 3]||a := [1, 2, 3];||[1, 2, 3];||##gray|//use//## [[[scripting#arrays|Python lists]]]||
||[[# array-size]][#array-size-note size] _
@<&nbsp;>@||Length[{1, 2, 3}]||numelems([1, 2, 3]);||length([1, 2, 3]);|| ||
||[[# array-lookup]][#array-lookup-note lookup]||##gray|(* access time is O(1) *)## _
##gray|(* indices start at one: *)## _
{1, 2, 3}[[1]] _
 _
Part[{1, 2, 3}, 1]||a := [6, 7, 8]; _
a[1];||a: [6, 7, 8]; _
a[1];|| ||
||[[# array-update]][#array-update-note update] _
@<&nbsp;>@||a[[1]] = 7||a[1] := 7;||a[1]: 7;|| ||
||[[# array-out-of-bounds]][#array-out-of-bounds-note out-of-bounds behavior]||##gray|//left as unevaluated// Part[] //expression//##||##gray|//Error for both lookup and update.//##||##gray|//Error for both lookup and update.//##|| ||
||[[# array-element-index]][#array-element-index-note element index]||##gray|(* Position returns list of all positions: *)## _
First /@ Position[{7, 8, 9, 9}, 9]||with(ListTools): _
 _
Search(9, [7, 8, 9]); _
 _
##gray|# SearchAll returns all positions##|| || ||
||[[# array-slice]][#array-slice-note slice] _
@<&nbsp;>@||{1, 2, 3}[[1 ;; 2]]|| || || ||
||[[# array-of-integers-as-index]][#array-of-integers-as-index-note array of integers as index]||##gray|(* evaluates to {7, 9, 9} *)## _
{7, 8, 9}[[{1, 3, 3}]]|| || || ||
||[[# array-back]][#array-back-note manipulate back]||a = {6,7,8} _
AppendTo[a, 9] _
elem = a[[Length[a]]] _
a = Delete[a, Length[a]] _
elem|| || || ||
||[[# array-front]][#array-front-note manipulate front]||a = {6,7,8} _
PrependTo[a, 5] _
elem = a[[1]] _
a = Delete[a, 1] _
elem|| || || ||
||[[# array-head]][#array-head-note head] _
@<&nbsp;>@||First[{1, 2, 3}]|| || || ||
||[[# array-tail]][#array-tail-note tail] _
@<&nbsp;>@||Rest[{1, 2, 3}]|| || || ||
||[[# array-cons]][#array-cons-note cons]||##gray|(* first arg must be an array *)## _
Prepend[{2, 3}, 1]|| || || ||
||[[# array-concatenate]][#array-concatenate-note concatenate] _
@<&nbsp;>@||Join[{1, 2, 3}, {4, 5, 6}]|| || || ||
||[[# array-replicate]][#array-replicate-note replicate] _
@<&nbsp;>@||ten_zeros = Table[0, {i, 0, 9}]|| || || ||
||[[# copy-array]][#copy-array-note copy] _
@<&nbsp;>@||a2 = a|| || || ||
||[[# iterate-over-array]][#iterate-over-array-note iterate] _
@<&nbsp;>@||Function[x, Print[x]] /@ {1, 2, 3}||for i in [1, 2, 3] do _
@<&nbsp;&nbsp;>@print(i); _
end do;||for i in [1, 2, 3] do print(i);|| ||
||[[# reverse-array]][#reverse-array-note reverse] _
@<&nbsp;>@||Reverse[{1, 2, 3}]||with(ListTools): _
 _
Reverse([1, 2, 3]);|| || ||
||[[# sort-array]][#sort-array-note sort]||##gray|(* original list not modified: *)## _
a = Sort[{3, 1, 4, 2}]||##gray|# original list not modified:## _
a := sort([3, 1, 4, 2]);|| || ||
||[[# dedupe-array]][#dedupe-array-note dedupe] _
@<&nbsp;>@||DeleteDuplicates[{1, 2, 2, 3}]||with(ListTools): _
 _
##gray|# original list not modified:## _
a := MakeUnique([1, 1, 2, 3]);|| || ||
||[[# membership]][#membership-note membership] _
@<&nbsp;>@||MemberQ[{1, 2, 3}, 2]||evalb(2 in [1, 2, 3]); _
member(2, [1, 2, 3]);||member(7, {1, 2, 3}); _
evalb(7 in {1, 2, 3});|| ||
||[[# intersection]][#intersection-note intersection] _
@<&nbsp;>@||Intersect[{1, 2}, {2, 3, 4}]|| || || ||
||[[# union]][#union-note union] _
@<&nbsp;>@||Union[{1, 2}, {2, 3, 4}]|| || || ||
||[[# set-diff]][#set-diff-note relative complement]||Complement[{1, 2, 3}, {2}]|| || || ||
||[[# map]][#map-note map]||Map[Function[x, x x], {1, 2, 3}] _
 _
Function[x, x x] /@ {1, 2, 3} _
 _
##gray|(* if function has Listable attribute, Map is unnecessary: *)## _
sqr[x_] := x * x _
SetAttributes[sqr, Listable] _
sqr[{1, 2, 3, 4}]|| || || ||
||[[# filter]][#filter-note filter] _
@<&nbsp;>@||Select[{1, 2, 3}, # > 2 &]|| || || ||
||[[# reduce]][#reduce-note reduce] _
@<&nbsp;>@||Fold[Plus, 0, {1, 2, 3}]|| || || ||
||[[# universal-existential-test]][#universal-existential-test-note universal and existential tests]||##gray|//none//##|| || || ||
||[[# min-max-elem]][#min-max-elem-note min and max element]||Min[{6, 7, 8}] _
Max[{6, 7, 8}]||with(ListTools): _
 _
FindMinimalElement([6, 7, 8]); _
FindMaximalElement([6, 7, 8]);|| || ||
||[[# shuffle-sample]][#shuffle-sample-note shuffle and sample]||x = {3, 7, 5, 12, 19, 8, 4} _
 _
RandomSample[x] _
RandomSample[x, 3]|| || || ||
||[[# flatten]][#flatten-note flatten] _
##gray|//one level, completely//##||Flatten[{1, {2, {3, 4}}}, 1] _
Flatten[{1, {2, {3, 4}}}]||with(ListTools): _
 _
FlattenOnce([1, [2, [3, 4]]]); _
Flatten([1, [2, [3, 4]]]);|| || ||
||[[# zip]][#zip-note zip]||##gray|(* list of six elements: *)## _
Riffle[{1, 2, 3}, {"a", "b", "c"}] _
 _
##gray|(* list of lists with two elements: *)## _
Inner[List, {1, 2, 3}, {"a", "b", "c"}, List] _
 _
##gray|(* same as Dot[{1, 2, 3}, {2, 3, 4}]: *)## _
Inner[Times, {1, 2, 3}, {2, 3, 4}, Plus]||with(ListTools): _
 _
##gray|# list of six elements:## _
Interleave([1, 2, 3], ["a", "b", "c"]); _
 _
##gray|# list of lists with two elements:## _
zip(@@`[]`@@, [1, 2, 3], ["a", "b", "c"]); _
 _
##gray|# same as DotProduct([1, 2, 3], [2, 3, 4]):## _
add(zip(@@`*`@@, [1, 2, 3], [2, 3, 4]))|| || ||
||[[# cartesian-product]][#cartesian-product-note cartesian product]||Outer[List, {1, 2, 3}, {"a", "b", "c"}]|| || || ||
||||||||||~ [[# sets]][#sets-note sets]||
||~ ||~ mathematica||~ maple||~ maxima||~ sympy||
||[[# set-literal]][#set-literal-note literal]|| ||{1, 2, 3};|| || ||
||[[# array-to-set]][#array-to-set-note array to set]|| ||{op([1, 2, 3])};|| || ||
||[[# set-to-array]][#set-to-array-note set to array]|| ||[op({1, 2, 3})];|| || ||
||[[# set-union]][#set-union-note union]|| ||{1, 2, 3} union {2, 3, 4};|| || ||
||[[# set-membership]][#set-membership-note membership] _
@<&nbsp;>@|| ||evalb(7 in {1, 2, 3}); _
member(7, {1, 2, 3});|| || ||
||[[# set-intersection]][#set-intersection-note intersection] _
@<&nbsp;>@|| ||{1, 2, 3} intersect {2, 3, 4};|| || ||
||[[# set-diff]][#set-diff-note relative complement]|| ||{1, 2, 3} minus {2, 3, 4};|| || ||
||||||||||~ [[# arith-seq]][#arith-seq-note arithmetic sequences]||
||~ ||~ mathematica||~ maple||~ maxima||~ sympy||
||[#range unit difference] _
@<&nbsp;>@||Range[1, 100]||i $ i = 1..100;||makelist(i, i, 1, 100);||range(1, 101)||
||[#arithmetic-sequence-integer difference of 10] _
@<&nbsp;>@||Range[1, 100, 10]||10 * i + 1 $ i = 1..9;||makelist(i, i, 1, 100, 10);||range(1, 100, 10)||
||[#airthmetic-sequence-float difference of 1/10] _
@<&nbsp;>@||Range[1, 100, 1/10]||1 + 1/10 * i $ i = 0..990||makelist(i, i, 1, 100, 1/10);|| ||
||||||||||~ [[# dictionaries]][#dictionaries-note dictionaries]||
||~ ||~ mathematica||~ maple||~ maxima||~ sympy||
||[[# dict-literal]][#dict-literal-note literal] _
@<&nbsp;>@||d = <|"t" -> 1, "f" -> 0|> _
 _
##gray|(* or convert list of rules: *)## _
d = Association[{"t" -> 1, "f" -> 0}] _
##gray|(* and back to list of rules: *)## _
Normal[d]||d := table(["t"=1, "f"=0]);|| ||##gray|//use//## [[[scripting#dictionaries|Python dictionaries]]]||
||[[# dict-size]][#dict-size-note size] _
@<&nbsp;>@||Length[Keys[d]]||numelems(d);|| || ||
||[[# dict-lookup]][#dict-lookup-note lookup] _
@<&nbsp;>@||d["t"]||d["t"]|| || ||
||[[# dict-update]][#dict-update-note update]||d["f"] = -1||d["f"] := -1;|| || ||
||[[# dict-missing-key]][#dict-missing-key-note missing key behavior] _
@<&nbsp;>@||##gray|//Returns a symbolic expression with head "Missing".  If the lookup key was "x", the expression is:// _
 _
@<&nbsp;&nbsp;>@Missing["KeyAbsent", "x"]##||##gray|//Returns unevaluated expression.//##|| || ||
||[[# dict-key-check]][#dict-key-check-note is key present] _
@<&nbsp;>@||KeyExistsQ[d, "t"]|| || || ||
||[[# dict-iter]][#dict-iter-note iterate] _
@<&nbsp;>@|| || || || ||
||[[# dict-key-val]][#dict-key-val-note keys and values as arrays]||Keys[d] _
Values[d]||with(ListTools): _
 _
FlattenOnce(indices(d)); _
FlattenOnce(entries(d));|| || ||
||[[# dict-sort-values]][#dict-sort-values-note sort by values]||Sort[d]|| || || ||
||||||||||~ [[# functions]][#functions-note functions]||
||~ ||~ mathematica||~ maple||~ maxima||~ sympy||
||[#function-definition define function]||Add[a_, b_] := a + b _
 _
##gray|(* alternate syntax: *)## _
Add = Function[{a, b}, a + b]||add2 := (a, b) -> a + b _
 _
add2 := proc(a, b) _
@<&nbsp;&nbsp;>@a + b _
end proc;||add(a, b) := a + b;|| ||
||[#function-invocation invoke function]||Add[3, 7] _
 _
Add @<@@>@ {3, 7} _
 _
##gray|(* syntax for unary functions: *)## _
2 @@//@@ Log||add2(3, 7)||add(3, 7);|| ||
||[[# boolean-func-attr]][#boolean-func-attr-note boolean function attributes] _
##gray|//list, set, clear//##||Attributes[add] _
SetAttributes[add, {Orderless, Flat, Listable}] _
ClearAtttibutes[add, Listable]|| || || ||
||[[# undef-func]][#undef-func-note undefine function]||Clear[Add]||add2 := 'add2';|| || ||
||[[# redefine-func]][#redefine-func-note redefine function]||Add[a_, b_] := b + a||add2 := (a, b) -> b + a;|| || ||
||[[# overload-func]][#overload-func-note overload function]|| || || || ||
||[[# missing-func]][#missing-func-note missing function behavior]||##gray|//The expression is left unevaluated.  The head is the function name as a symbol, and the parts are the arguments.//##||##gray|//The expression is left unevaluated.//##|| || ||
||[[# missing-arg]][#missing-arg-note missing argument behavior]||##gray|//The expression is left unevaluated.  The head is the function name as a symbol, and the parts are the arguments.//##||##gray|//Invalid input error.//##|| || ||
||[[# extra-arg]][#extra-arg-note extra argument behavior]||##gray|//The expression is left unevaluated.  The head is the function name as a symbol, and the parts are the arguments.//##||##gray|//Extra arguments are ignored.//##|| || ||
||[[# default-arg]][#default-arg-note default argument]||Options[myLog] = {base -> 10} _
myLog[x_, OptionsPattern[]] := _
@<&nbsp;&nbsp;>@N[Log[x]/Log[OptionValue[base]]] _
 _
##gray|(* call using default: *)## _
myLog[100] _
 _
##gray|(* override default: *)## _
myLog[100, base -> E]|| || || ||
||[[# retval]][#retval-note return value]||##gray|//last expression evaluated, or argument of// Return[]##|| || || ||
||[#anonymous-function anonymous function]||Function[{a, b}, a + b] _
 _
(#1 + #2) &|| || || ||
||[#variable-number-arguments variable number of arguments]||##gray|(* one or more arguments: *)## _
add[a@@__@@] := Plus[a] _
 _
##gray|(* zero or more arguments: *)## _
add[a@@___@@] := Plus[a]|| || || ||
||[[# expand-array]][#expand-array-note pass array elements as separate arguments]||Apply[f, {a, b, c}] _
 _
f @<@@>@ {x, y, z}|| || ||a = [x, y, z] _
f(*a)||
||||||||||~ [[# execution-control]][#execution-control-note execution control]||
||~ ||~ mathematica||~ maple||~ maxima||~ sympy||
||[#if if]||If[x > 0, _
@<&nbsp;&nbsp;>@Print["positive"], _
@<&nbsp;&nbsp;>@If[x < 0, _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@Print["negative"], _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@Print["zero"]]]||if x > 0 then _
@<&nbsp;&nbsp;>@print("positive"); _
elif x < 0 then _
@<&nbsp;&nbsp;>@print("negative"); _
else _
@<&nbsp;&nbsp;>@print("zero"); _
end if||if x > 0 _
@<&nbsp;&nbsp;>@then print("positive") _
@<&nbsp;&nbsp;>@else if x < 0 _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@then print("negative") _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@else print("zero");||##gray|//use//## [http://hyperpolyglot.org/scripting#execution-control Python execution control]||
||[#while while]||i = 0 _
While[i < 10, Print[i]; i++]|| ||for i: 0 step 1 while i < 10 do print(i);|| ||
||[#for for]||For[i = 0, i < 10, i++, Print[i]]||for i from 1 by 1 while i < 10 do _
@<&nbsp;&nbsp;>@print(i); _
end do;||for i: 1 step 1 thru 10 do print(i);|| ||
||[#break break]||Break[]|| || || ||
||[#continue continue]||Continue[]|| || || ||
||||||||||~ [[# exceptions]][#exceptions-note exceptions]||
||~ ||~ mathematica||~ maple||~ maxima||~ sympy||
||[[# raise-exc]][#raise-exc-note raise exception]||Throw["failed"]||error "failed";||error("failed");||##gray|//use//## [http://hyperpolyglot.org/scripting#exceptions Python exceptions]||
||[[# handle-exc]][#handle-exc-note handle exception]||Print[Catch[Throw["failed"]]]|| ||errcatch(error("failed"));|| ||
||[[# uncaught-exc]][#uncaught-exc-note uncaught exception behavior]|| || || || ||
||||||||||~ [[# streams]][#streams-note streams]||
||~ ||~ mathematica||~ maple||~ maxima||~ sympy||
||[[# std-file-handles]][#std-file-handles-note standard file handles]||Streams["stdout"] _
Streams["stderr"] _
 _
##gray|(* all open file handles: *)## _
Streams[]|| || || ||
||[[# write-line-stdout]][#write-line-stdout-note write line to stdout]||Print["hello"]|| || || ||
||[[# open-file]][#open-file-note open file for reading]||f  = OpenRead["/etc/hosts"]|| || || ||
||[[# open-file-write]][#open-file-write-note open file for writing]||f = OpenWrite["/tmp/test"]|| || || ||
||[[# open-file-append]][#open-file-append-note open file for appending]||f = OpenAppend["/tmp/test"]|| || || ||
||[[# close-file]][#close-file-note close file]||Close[f]|| || || ||
||[[# read-file-str]][#read-file-str-note read file into string]||s = ReadString[f]|| || || ||
||[[# write-str]][#write-str-note write string]||WriteString[f, "lorem ipsum"]|| || || ||
||[#read-file-string-array read file into array of strings]||s = Import["/etc/hosts"] _
a = StringSplit[s, "\n"]|| || || ||
||[[# seek]][#seek-note file handle position] _
 _
##gray|//get, set//##||f = StringToStream["foo bar baz"] _
 _
StreamPosition[f] _
 _
##gray|(* beginning of stream: *)## _
SetStreamPosition[f, 0] _
##gray|(# end of stream: *)## _
SetStreamPosition[f, Infinity]|| || || ||
||[[# tmp-file]][#tmp-file-note open temporary file]||f = OpenWrite[] _
path = Part[f, 1]|| || || ||
||||||||||~ [[# files]][#files-note files]||
||~ ||~ mathematica||~ maple||~ maxima||~ sympy||
||[[# file-test]][#file-test-note file exists test, regular file test]||FileExistsQ["/etc/hosts"] _
FileType["/etc/hosts"] == File|| || || ||
||[[# file-size]][#file-size-note file size]||FileByteCount["/etc/hosts"]|| || || ||
||[[# readable-writeable-executable]][#readable-writable-executable-note is file readable, writable, executable]|| ||with(FileTools): _
 _
isReadable("/etc/hosts"); _
IsWritable("/etc/hosts"); _
IsExecutable("/etc/hosts");|| || ||
||[[# last-modification-time]][#last-modification-time-note last modification time]||FileDate["/etc/hosts"]|| || || ||
||[[# file-cp-rm-mv]][#file-cp-rm-mv-note copy file, remove file, rename file]||CopyFile["/tmp/foo", "/tmp/bar"] _
DeleteFile["/tmp/foo"] _
RenameFile["/tmp/bar", "/tmp/foo"]|| || || ||
||||||||||~ [[# directories]][#directories-note directories]||
||~ ||~ mathematica||~ maple||~ maxima||~ sympy||
||[[# working-dir]][#working-dir-note working directory]||dir = Directory[] _
 _
SetDirectory["/tmp"]||dir := currentdir(); _
 _
currentdir("/tmp");|| || ||
||[[# build-pathname]][#build-pathname-note build pathname]||FileNameJoin[{"/etc", "hosts"}]||with(FileTools): _
 _
JoinPath(["/etc", "hosts"]);|| || ||
||[[# dirname-basename]][#dirname-basename-note dirname and basename]||DirectoryName["/etc/hosts"] _
FileBaseName["/etc/hosts"]||with(FileTools): _
 _
ParentDirectory("/etc/hosts"); _
Filename("/etc/hosts");|| || ||
||[[# absolute-pathname]][#absolute-pathname-note absolute pathname]||##gray|(* file must exist; _
@<&nbsp;&nbsp;&nbsp;>@symbolic links are resolved: *)## _
AbsoluteFileName["foo"] _
AbsoluteFileName["/foo"] _
AbsoluteFileName["../foo"] _
AbsoluteFileName["./foo"] _
AbsoluteFileName["~/foo"]|| || || ||
||[[# glob]][#glob-note glob paths]||Function[x, Print[x]] /@ FileNames["/tmp/*"]|| || || ||
||[[# mkdir]][#mkdir-note make directory]||CreateDirectory["/tmp/foo.d"]||mkdir("/tmp/foo.d");|| || ||
||[[# recursive-cp]][#recursive-cp-note recursive copy]||CopyDirectory["/tmp/foo.d", "/tmp/baz.d"]|| || || ||
||[[# rmdir]][#rm-dir-note remove empty directory]||DeleteDirectory["/tmp/foo.d"]||rmdir("/tmp/foo.d");|| || ||
||[[# rm-rf]][#rm-rf-note remove directory and contents]||DeleteDirectory["/tmp/foo.d", _
@<&nbsp;&nbsp;>@DeleteContents -> True]|| || || ||
||[[# dir-test]][#dir-test-note directory test]||DirectoryQ["/etc"]||isdir("/etc");|| || ||
||||||||||~ [[# libraries-namespaces]][#libraries-namespaces-note libraries and namespaces]||
||~ ||~ mathematica||~ maple||~ maxima||~ sympy||
||[[# load-lib]][#load-lib-note load library]||Get["foo.m"]|| || || ||
||||||||||~ [[# reflection]][#reflection-note reflection]||
||~ ||~ mathematica||~ maple||~ maxima||~ sympy||
||[#function-documentation get function documentation]||?Tan _
Information[Tan]||Describe(solve);||describe(solve);||print(sympy.solve.@@__doc__@@) _
 _
##gray|# in IPython:## _
sympy.solve? _
help(sympy.solve)||
||list function options||Options[Solve] _
Options[Plot]|| || || ||
||[#data-type query data type]||Head[x]||whattype(x);|| || ||
||[#list-variables list variables in scope]||Names[$Context <> "*"]|| || || ||
||||||||||~ [[# symbolic-expr]][#symbolic-expr-note symbolic expressions]||
||~ ||~ mathematica||~ maple||~ maxima||~ sympy||
||[[# symbolic-expr-literal]][#symbolic-expr-literal-note literal]||expr = 1 + x + x^2||expr := 1 + x + x^2;||expr = 1 + x + x^2;||x = sympy.symbols('x') _
 _
expr = 1 + x + x^2||
||[[# prevent-simplification]][#prevent-simplification-note prevent simplification]||HoldForm[x + x] _
x + x @@//@@ HoldForm|| || || ||
||[[# symbolic-expr-var-update]][#symbolic-expr-var-update-note variable update]||expr = 1 + x _
x = 3 _
##gray|(* 4: *)## _
expr||expr := 1 + x; _
x := 3; _
##gray|# 4:## _
expr;||expr: 1 + x; _
x: 3; _
##gray|/* 1 + x: */## _
expr;||x = sympy.symbols('x') _
expr = 1 + x _
x = 3 _
##gray|# 1 + x:## _
expr||
||[[# symbolic-expr-subst]][#symbolic-expr-subst-note substitute]||##gray|(* {3, 3}: *)## _
ReplaceAll[{x, x}, x -> 3] _
 _
##gray|(* {3, 3}: *)## _
{x, x} /. x -> 3||##gray|# [3, 3]:## _
subs(x = 3, [x, x]);||##gray|/* [3, 3]: */## _
subst(3, x, [x, x]);||sympy.Matrix([x, x]).subs(x, 3)||
||[[# piecewise-symbolic-expr]][#piecewise-symbolic-expr-note piecewise-defined expression]||Piecewise[{{x, x >= 0}, {-x, x < 0}}] _
 _
##gray|(* otherwise case: *)## _
Piecewise[{{-x, x < 0}}, x]||piecewise(x < 0, -x, x >= 0, x); _
 _
##gray|# otherwise case:## _
piecewise(x < 0, -x, x);||if x < 0 then -x else x;||sympy.Piecewise((-x, x < 0), (x, x >= 0)) _
 _
##gray|# otherwise case:## _
sympy.Piecewise((-x, x < 0), (x, True))||
||[[# simplify]][#simplify-note simplify]||Simplify[Cos[x]^2 + Sin[x]^2] _
 _
##gray|(* perform more simplications: *)## _
FullSimplify[-(1/2) I E^(-I x) (-1 + E^(2 I x))]||simplify(cos(x)^2 + sin(x)^2);|| ||sympy.simplify(sympy.cos(x)@@**@@2 + sympy.sin(x)@@**@@2)||
||[[# assumption]][#assumption-note assumption]||Simplify[Sqrt[x^2], Assumptions -> x >= 0] _
Simplify[(-1)^(n * (n + 1)), _
@<&nbsp;&nbsp;>@Assumptions -> Element[n, Integers]] _
 _
##gray|(* perform fewer simplications: *)## _
Refine[Sqrt[x^2], Assumptions -> x >= 0] _
Refine[(-1)^(n * (n + 1)), Element[n, Integers]]||assume(x > 0); _
##gray|# Maple puts a tilde after an unknown with _
# an assumption; e.g: x~:## _
sqrt(x^2); _
 _
##gray|# expression-local assumption:## _
sqrt(x^2) assuming(x > 0); _
 _
simplify((-1)^(n * (n + 1))) assuming(n, integer);||assume(x > 0); _
sqrt(x^2); _
 _
##gray|/* There is no assumption predicate for _
@<&nbsp;&nbsp;&nbsp;>@integer variables. */##||x = sympy.symbols('x', positive=True) _
sympy.sqrt(x ** 2) _
 _
n = sympy.symbols('n', integer=True) _
(-1)**((n) * (n + 1))||
||[[# assumption-predicates]][#assumption-predicates-note assumption predicates]||Element[x, Complexes] _
Element[x, Reals] _
Element[x, Algebraics] _
Element[x, Rationals] _
Element[x, Integers] _
Element[x, Primes] _
Element[x, Integers] && Mod[x, 5] == 0 _
Element[x, Booleans] _
 _
##gray|(* assumptions can use inequalities and logical operators: *)## _
x > 0 @@||@@ x < 0||##gray|# a partial list:## _
complex _
real _
rational _
integer _
prime _
odd _
even _
positive _
nonnegative _
negative||##gray|//Assumptions can only be created using relational operators.//##||##gray|# a partial list:## _
complex _
real _
algebraic _
rational _
integer _
positive _
nonpositive _
negative _
nonnegative _
nonzero _
prime _
odd _
even||
||[[# rm-assumption]][#rm-assumption-note remove assumption]||##gray|//None.  Assumptions are always local.//##||##gray|# removes all assumptions about x:## _
x := 'x';||forget(x > 0);||##gray|# removes all assumptions about x:## _
x = sympy.symbols('x')||
||||||||||~ [[# calculus]][#calculus-note calculus]||
||~ ||~ mathematica||~ maple||~ maxima||~ sympy||
||[[# limit]][#limit-note limit] _
@<&nbsp;>@||Limit[Sin[x]/x, x -> 0]||limit(sin(x) / x, x = 0);||limit(sin(x)/x, x, 0);||sympy.limit(sympy.sin(x)/x, x, 0)||
||[[# limit-at-infinity]][#limit-at-infinity-note limit at infinity] _
@<&nbsp;>@||Limit[1/x, x -> Infinity]||limit(1 / x, x = infinity);||limit(1/x, x, inf);||sympy.limit(1/x, x, sympy.oo)||
||[[# one-sided-limit]][#one-sided-limit-note one-sided limit] _
 _
##gray|//from left, from right//##||Limit[1/x, x -> 0, Direction -> 1] _
Limit[1/x, x -> 0, Direction -> -1]||limit( 1/ x, x = 0, left); _
limit( 1/ x, x = 0, right);||limit(1/x, x, 0, minus); _
limit(1/x, x, 0, plus);||sympy.limit(1/x, x, 0, '-') _
sympy.limit(1/x, x, 0, '+')||
||[[# derivative]][#derivative-note derivative]||D[x^3 + x + 3, x] _
 _
D[x^3 + x + 3, x] /. x -> 2||diff(x^3 + x + 3, x);||diff(x^3 + x + 3, x); _
 _
at(diff(x^3 + x + 3, x), [x=2]);||sympy.diff(x@@**@@3 + x + 3, x) _
 _
sympy.diff(x@@**@@3 + x + 3, x).subs(x, 2)||
||[[# derivative-func]][#derivative-func-note derivative of a function]||f[x_] = x^3 + x + 3 _
 _
##gray|(* returns expression: *)## _
D[f[x, x] _
 _
##gray|(* return functions: *)## _
f' _
Derivative[1][f] _
 _
##gray|(* evaluating derivative at a point: *)## _
f'[2] _
Derivative[1][f][2]||f := (x) -> x^3 + x + 3; _
 _
##gray|# returns expression:## _
diff(f(x), x); _
 _
##gray|# returns function:## _
D(f); _
 _
##gray|# evaluating derivative at a point:## _
D(f)(2);|| || ||
||[[# derivative-const]][#derivative-const-note constants]||##gray|(* a depends on x; b does not: *)## _
D[a x + b, x,  NonConstants -> {a}] _
 _
Dt[a x + b, x, Constants -> {b}]|| ||##gray|/* symbols constant unless declared with depends: */## _
depends(a, x); _
diff(a * x + b, x); _
 _
##gray|/* makes a constant again: */## _
remove(a, dependency);|| ||
||[[# higher-order-derivative]][#higher-order-derivative-note higher order derivative]||D[Log[x], {x, 3}] _
Log'''[x] _
Derivative[3][Log][x]||diff(log(x), [x$3]);||diff(log(x), x, 3);||sympy.diff(sympy.log(x), x, 3)||
||[[# mixed-partial-derivative]][#mixed-partial-derivative-note mixed partial derivative]||D[x^9 * y^8, x, y, y] _
D[x^9 * y^8, x, {y, 2}]||diff(x^9*y^8, x, y, y); _
diff(x^9 * y^8, x, [y$2]);||diff(x^9 * y^8, x, 1, y, 2);||sympy.diff(x@@**@@9 * y@@**@@8, x, y, y)||
||[[# div-grad-curl]][#div-grad-curl-note div, grad, and curl]||Div[{x^2, x y, x y z}, {x, y, z}] _
 _
Grad[2 x y z^2, {x, y, z}] _
 _
Curl[{x y z, y^2, 0}, {x, y, z}]||with(VectorCalculus): _
SetCoordinates('cartesian'[x, y, z]); _
 _
Divergence(VectorField(<x^2, x*y, x*y*z>))); _
Gradient(2*x*y*z^2, [x, y, z]); _
Curl(VectorField(<x*y*z, y^2, 0>));|| || ||
||[[# antiderivative]][#antiderivative-note antiderivative] _
@<&nbsp;>@||Integrate[x^3 + x + 3, x]||integrate(x^3 + x + 3, x)||integrate(x^3 + x + 3, x);||sympy.integrate(x@@**@@3 + x + 3, x)||
||[[# definite-integral]][#definite-integral-note definite integral] _
@<&nbsp;>@||Integrate[x^3 + x + 3, {x, 0, 1}]||integrate(x^3 + x + 3, [x = 0 .. 1]);||integrate(x^3 + x + 3, x, 0, 1);||sympy.integrate(x@@**@@3 + x + 3, [x, 0, 1])||
||[[# improper-integral]][#improper-integral-note improper integral] _
@<&nbsp;>@||Integrate[Exp[-x], {x, 0, Infinity}]||integrate(exp(-x), [x = 0 .. infinity]);||integrate(exp(-x), x, 0, inf);||sympy.integrate(sympy.exp(-x), (x, 0, sympy.oo))||
||[[# double-integral]][#double-integral-note double integral]||##gray|(* integrates over y first: *)## _
Integrate[x^2 + y^2, {x, 0, 1}, {y, 0, x}]||##gray|# integrates over y first:## _
integrate(x^2 + y^2, [y = 0 .. x, x = 0 .. 1]);||integrate(integrate(x^2+y^2, y, 0, x), x, 0, 1);||f = sympy.integrate(@@x**2 + y**2@@, (y, 0, x)) _
sympy.integrate(f, (x, 0, 1))||
||[[# residue]][#residue-note residue] _
@<&nbsp;>@||Residue[1/(z - I), {z, I}]||residue(1/(z-I), z = I);||residue(1 / (z - %i), z, %i);||sympy.residue(1/(z-sympy.I), z, sympy.I)||
||[[# sum]][#sum-note sum] _
@<&nbsp;>@||Sum[2^i, {i, 1, 10}]||sum(2^i, i = 1 .. 10);||sum(2^i, i, 1, 10);||sympy.Sum(2**i, (i, 1, 10)).doit()||
||[[# series-sum]][#series-sum-note series sum] _
@<&nbsp;>@||Sum[2^-n, {n, 1, Infinity}]||sum(2^(-n), n = 1 .. infinity);||sum(2^-n, n, 1, inf), simpsum;||sympy.Sum(2@@**@@(-n), (n, 1, sympy.oo)).doit()||
||[[# series-expansion-func]][#series-expansion-func-note series expansion of function]||Series[Cos[x], {x, 0, 10}]||series(cos(x), x = 0, 10);||taylor(cos(x), [x, 0, 10]);||sympy.series(sympy.cos(x), x, n=11)||
||[[# omitted-order-term]][#omitted-order-term-note omitted order term]||expr = 1 + x + x/2 + x^2/6 + O[x]^3 _
 _
##gray|(* remove omitted order term: *)## _
Normal[expr]|| || || ||
||||||||||~ [[# equations-unknowns]][#equations-unknowns-note equations and unknowns]||
||~ ||~ mathematica||~ maple||~ maxima||~ sympy||
||[[# solve-eqn]][#solve-eqn-note solve equation] _
@<&nbsp;>@||Solve[x^3 + x + 3 == 0, x]||solve(x^3 + x + 3 = 0, x);||solve(x^3 + x + 3 = 0, x);||sympy.solve(x@@**@@3 + x + 3, x)||
||[[# solve-eqns]][#solve-eqns-note solve equations]||Solve[x + y == 3 &&  x == 2 * y, _
@<&nbsp;&nbsp;>@{x, y}] _
 _
##gray|(* or: *)## _
Solve[{x + y == 3, x == 2 * y}, {x, y}]||solve({x = 2 * y, x + y = 3}, {x, y});||solve([x + y = 3, x = 2*y], [x, y]);||sympy.solve([x + y - 3, 3*x - 2*y], [x, y])||
||[[# differential-eqn]][#differential-eqn-note differential equation]||DSolve[y'[x] == y[x], y[x], x]||dsolve(diff(y(x), x) = y(x), y(x));||desolve([diff(y(x), x) = y(x)], [y(x)]);||from sympy import Derivative _
y = sympy.Function('y') _
 _
sympy.dsolve(Derivative(y(x), x) - y(x), y(x))||
||[[# differential-eqn-boundary-condition]][#differential-eqn-boundary-condition-note differential equation with boundary condition]||DSolve[{y'[x] == y[x], y[0] == 1}, y[x], x]||dsolve({diff(y(x), x) = y(x), y(0) = 1}, y(x));||atvalue(y(x), x=0, 1); _
desolve([diff(y(x), x) = y(x)], [y(x)]);||##gray|//support for boundary conditions is limited//##||
||[[# differential-eqns]][#differential-eqns-note differential equations]||eqn1 = x'[t] == x[t] - x[t] * y[t] _
eqn2 = y'[t] == x[t] * y[t] - y[t] _
DSolve[{eqn1, eqn2}, {x[t], y[t]}, t]||eqn1 := diff(x(t), t) = x(t)-x(t)*y(t); _
eqn2 := diff(y(t), t) = x(t)*y(t)-y(t); _
dsolve([eqn1, eqn2], [x(t), y(t)]);||eqn1: diff(x(t), t) = x(t) - x(t) * y(t); _
eqn2: diff(y(t), t) = x(t) * y(t) - y(t); _
desolve([eqn1, eqn2], [x(t), y(t)]);|| ||
||[[# recurrence-eqn]][#recurrence-eqn-note recurrence equation]||eqns = {a[n + 2] == a[n + 1] + a[n], _
@<&nbsp;&nbsp;>@a[0] == 0, _
@<&nbsp;&nbsp;>@a[1] == 1} _
 _
RSolve[eqns, a[n], n] _
 _
##gray|(* remove Fibonacci[] from solution: *)## _
FunctionExpand[RSolve[eqns, a[n], n]]||eqns := {a(0) = 0, _
@<&nbsp;&nbsp;>@a(1) = 1, _
@<&nbsp;&nbsp;>@a(n+2) = a(n+1)+a(n)}; _
 _
rsolve(eqns, a);||solve_rec(a[n]=a[n-1]+a[n-2], a[n], a[0] = 0, a[1] = 1);||n = sympy.symbols('n') _
a = sympy.Function('a') _
eqn = a(n+2) - a(n+1) - a(n) _
 _
sympy.rsolve(eqn, a(n), {a(0): 0, a(1): 1})||
||||||||||~ [[# optimization]][#optimization-note optimization]||
||~ ||~ mathematica||~ maple||~ maxima||~ sympy||
||[[# minimize]][#minimize-note minimize]||##gray|(* returns list of two items: min value and rule _
@<&nbsp;&nbsp;&nbsp;>@transforming x to argmin *)## _
Minimize[x^2 + 1, x] _
 _
##gray|(* 2 ways to get min value: *)## _
Minimize[x^2 + 1, x][[1]] _
MinValue(x^2 + 1, x] _
 _
##gray|(* 2 ways to get argmin: *)## _
x /. Minimize[x^2 + 1, x][[2]] _
ArgMin[x^2 + 1, x]||##gray|# 1:## _
minimize(x^2 + 1, x); _
 _
##gray|# 1, {[{x = 0}, 1]}:## _
minimize(x^2+1, x, location);|| || ||
||[[# maximize]][#maximize-note maximize]||Maximize[-x^4 + 3 x^3, x] _
 _
Maxvalue[-x^4 + 3 x^3, x] _
ArgMax[-x^4 + 3 x^3, x]||##gray|# 2187/256:## _
maximize(-x^4+3*x^3, x); _
 _
##gray|# 2187/256, {[{x = 9/4}, 2187/256]}:## _
maximize(-x^4+3*x^3, x, location);|| || ||
||[[# optimize-unknown-param]][#optimize-unknown-param-note objective with unknown parameter]||##gray|(* minval and argmin are expressions _
@<&nbsp;&nbsp;&nbsp;>@containing a: *)## _
Minimize[(x - a)^2 + x, x]||##gray|//Doesn't work; returns expression unevaluated.//##|| || ||
||[[# unbounded-behavior]][#unbounded-behavior-note unbounded behavior]||##gray|(* MaxValue will be Infinity; MinValue will be _
@<&nbsp;&nbsp;&nbsp;>@-Infinity *)##||##gray|# minimize will return -infinity; _
# maximize will return infinity##|| || ||
||[[# optimize-multiple-var]][#optimize-multiple-var-note multiple variables]||##gray|(* returns one solution: *)## _
Minimize[x^4 - 2 x^2 + 2 y^4 - 3 y^2, {x, y}]||expr := x^4+2*y^4-2*x^2-3*y^2; _
##gray|# returns all four solutions:## _
minimize(expr, [x, y], location);|| || ||
||[[# optimize-constraints]][#optimize-constraints-note constraints]||Minimize[{-x - 2 y^2, y^2 <= 17, 2 x + y <= 5}, _
@<&nbsp;&nbsp;>@{x, y}]||##gray|//none//##|| || ||
||[[# infeasible-behavior]][#infeasible-behavior-note infeasible behavior]||##gray|(* MaxValue will be -Infinity; MinValue will be _
@<&nbsp;&nbsp;&nbsp;>@Infinity; ArgMax or ArgMin will be _
@<&nbsp;&nbsp;&nbsp;>@Indeterminate *)##||##gray|//no infeasible expressions//##|| || ||
||[[# optimize-int-var]][#optimize-int-var-note integer variables]||Maximize[{x^2 + 2*y, _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@x >= 0, y >= 0, _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@2 x + Pi * y <= 4}, _
@<&nbsp;&nbsp;>@{x, y}, Integers]|| || || ||
||[[# numerical-opt]][#numerical-opt-note numerical optimization]||NMinimize[(x^2 - 3)^2, x _
@<&nbsp;&nbsp;>@MaxIterations -> 100, _
@<&nbsp;&nbsp;>@AccuracyGoal -> 16, _
@<&nbsp;&nbsp;>@PrecisionGoal -> 8, _
@<&nbsp;&nbsp;>@Method -> "NelderMead"] _
 _
##gray|(* precision: total significant digits _
@<&nbsp;&nbsp;&nbsp;>@accuracy: digits right of decimal point *)## _
 _
##gray|(* other methods: "DifferentialEvolution", _
@<&nbsp;&nbsp;&nbsp;>@"SimulatedAnnealing", "RandomSearch" *)##|| || || ||
||[[# local-opt-near-point]][#local-opt-near-point-note local optimum near point]||FindMinimum[x Cos[x], {x, 2} _
@<&nbsp;&nbsp;>@AccuracyGoal -> 16, _
@<&nbsp;&nbsp;>@PrecisionGoal -> 8, _
@<&nbsp;&nbsp;>@Method -> "ConjugateGradient"] _
 _
##gray|(* other method: "PrincipalAxis*)##|| || || ||
||||||||||~ [[# vectors]][#vectors-note vectors]||
||~ ||~ mathematica||~ maple||~ maxima||~ sympy||
||[[# vec-literal]][#vec-literal-note vector literal]||##gray|(* row vector is same as array: *)## _
{1, 2, 3}||Vector(3, [1, 2, 3]);||##gray|/* row vector is same as array: */## _
[1, 2, 3];||##gray|# column vector:## _
sympy.Matrix([1, 2, 3])||
||[[# const-vec]][#const-vec-note constant vector] _
 _
##gray|//all zeros, all ones//##||Table[0, {i, 1, 100}] _
Table[1, {i, 1, 100}]||Vector(100, fill=0); _
Vector(100, fill=1);||makelist(0, 100); _
makelist(1, 100);|| ||
||[[# vec-coordinate]][#vec-coordinate-note vector coordinate]||##gray|(* indices start at one: *)## _
{6, 7, 8}[[1]]||Vector(3, [6, 7, 8])[1];||[6, 7, 8][1];|| ||
||[[# vec-dim]][#vec-dim-note vector dimension] _
@<&nbsp;>@||Length[{1, 2, 3}]||nops(Vector(3, [1, 2, 3]));||length([1, 2, 3]);|| ||
||[[# vec-element-wise]][#vec-element-wise-note element-wise arithmetic operators]||+ - * / _
##gray|//adjacent lists are multiplied element-wise//##||+ - *~ /~|| + - * /|| ||
||[[# vec-length-mismatch]][#vec-length-mismatch-note vector length mismatch] _
@<&nbsp;>@||##gray|//error//##||##gray|//dimensions do not match error//##||##gray|//error//##|| ||
||[[# vec-scalar]][#vec-scalar-note scalar multiplication]||3 {1, 2, 3} _
{1, 2, 3} 3 _
##gray|//* may also be used//##||3 * Vector(3, [1, 2, 3]); _
Vector(3, [1, 2, 3]) * 3;||3 * [1, 2, 3]; _
[1, 2, 3] * 3;|| ||
||[[# vec-dot]][#vec-dot-note dot product]||{1, 1, 1} . {2, 2, 2} _
Dot[{1, 1, 1}, {2, 2, 2}]||Vector(3, [1, 1, 1]) . Vector(3, [2, 2, 2]);||[1, 1, 1] . [2, 2, 2];||v1 = sympy.Matrix([1, 1, 1]) _
v2 = sympy.Matrix([2, 2, 2]) _
v1.dot(v2)||
||[[# vec-cross]][#vec-cross-note cross product]||Cross[{1, 0, 0}, {0, 1, 0}]||with(LinearAlgebra): _
 _
e1 := Vector(3, [1, 0, 0]); _
e2 := Vector(3, [0, 1, 0]); _
CrossProduct(e1, e2); _
e1 &x e2;|| ||e1 = sympy.Matrix([1, 0, 0]) _
e2 = sympy.Matrix([0, 1, 0]) _
e1.cross(e2)||
||[[# vec-norms]][#vec-norms-note norms]||Norm[{1, 2, 3}, 1] _
Norm[{1, 2, 3}] _
Norm[{1, 2, 3}, Infinity]||with(LinearAlgebra): _
 _
v := Vector(3, [1, 2, 3]); _
VectorNorm(v, 1); _
VectorNorm(v, 2); _
VectorNorm(v, infinity);|| ||vec = sympy.Matrix([1, 2, 3]) _
 _
vec.norm(1) _
vec.norm() _
vec.norm(inf)||
||[[# orthonormal-basis]][#orthonormal-basis-note orthonormal basis]||Orthogonalize[@@{{1, 0, 1}, {1, 1, 1}}@@]|| ||load(eigen); _
 _
gramschmidt([[1, 0, 1], [1, 1, 1]]);|| ||
||||||||||~ [[# matrices]][#matrices-note matrices]||
||~ ||~ mathematica||~ maple||~ maxima||~ sympy||
||[[# matrix-literal-ctor]][#matrix-literal-ctor-note literal or constructor]||##gray|(* used a nested array for each row: *)## _
@@{{@@1, 2}, {3, 4@@}}@@ _
 _
##gray|(* display as grid with aligned columns: *)## _
MatrixForm[@@{{@@1, 2}, {3, 4@@}}@@]||A := <1, 2; 3, 4>;||matrix([1, 2], [3, 4]);||sympy.Matrix([[1, 2], [3, 4]])||
||[[# matrix-from-seq]][#matrix-from-seq-note construct from sequence]||ArrayReshape[{1, 2, 3, 4, 5, 6}, {2, 3}]||Matrix(2, 3, [1, 2, 3, 4, 5, 6])|| ||sympy.Matrix(2, 3, [1, 2, 3, 4, 5, 6])||
||[[# const-matrices]][#const-matrices-note constant matrices] _
 _
##gray|//all zeros, all ones//##||Table[0, {i, 3}, {j, 3}] _
Table[1, {i, 3}, {j, 3}]||Matrix(3, 3, fill=0); _
Matrix(3, 3, fill=1);||zeromatrix(3, 3); _
 _
f[i, j] := 1; _
genmatrix(f, 3, 3);||sympy.zeros(3, 3) _
sympy.ones(3, 3)||
||[[# diagonal-matrices]][#diagonal-matrices-note diagonal matrices] _
##gray|//and identity//##||DiagonalMatrix[{1, 2, 3}] _
IdentityMatrix[3]||with(LinearAlgebra): _
 _
IdentityMatrix(3); _
DiagonalMatrix([1, 2, 3]);||ident(3) * [1, 2, 3]; _
ident(3);||sympy.diag(*[1, 2, 3]) _
sympy.eye(3)||
||[[# matrix-formula]][#matrix-formula-note matrix by formula]||Table[1/(i + j - 1), {i, 1, 3}, {j, 1, 3}]||h := (i, j) -> 1/(i+j-1); _
Matrix(3, 3, h);||h2[i, j] := 1/(i + j -1); _
genmatrix(h2, 3, 3);|| ||
||[[# matrix-dim]][#matrix-dim-note dimensions]||##gray|(* returns {3, 2}: *)## _
Dimensions[@@{{1, 2}, {3, 4}, {5, 6}}@@]||with(LinearAlgebra): _
 _
A := Matrix(3, 2, [1, 2, 3, 4, 5, 6]); _
r, c := Dimension(A);||A: matrix([1, 2, 3], [4, 5, 6]); _
matrix_size(A);||A = sympy.matrix([[1, 2], [3, 4], [5, 6]]) _
 _
##gray|# returns (3, 2):## _
A.shape||
||[[# matrix-elem-lookup]][#matrix-elem-lookup-note element lookup]||##gray|(* top left corner: *)## _
@@{{1, 2}, {3, 4}}@@[[1, 1]]||<1, 2; 3, 4>[1][1]; _
<1, 2; 3, 4>[1, 1];||A: matrix([1, 2], [3, 4]); _
 _
A[1, 1]; _
A[1][1];||A = sympy.Matrix([[1, 2], [3, 4]]) _
 _
##gray|# top left corner:## _
A[0, 0]||
||[[# extract-matrix-row]][#extract-matrix-row-note extract row]||##gray|(* first row: *)## _
@@{{1, 2}, {3, 4}}@@[[1]]||<1, 2; 3, 4>[1];||row(matrix([1, 2], [3, 4]), 1); _
matrix([1, 2], [3, 4])[1];||##gray|# first row:## _
A[0, :]||
||[[# extract-matrix-col]][#extract-matrix-col-note extract column]||##gray|(* first column as array: *)## _
@@{{1, 2}, {3, 4}}@@[[All, 1]]||with(LinearAlgebra): _
 _
Column(<1, 2; 3, 4>, 1);||col(matrix([1, 2], [3, 4]), 1);||##gray|# first column as 1x2 matrix:## _
A[:, 0]||
||[[# extract-submatrix]][#extract-submatrix-note extract submatrix]||A = @@{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}@@ _
A[[1;;2, 1;;2]]||A := <1, 2, 3; 4, 5, 6; 7, 8, 9>; _
A[1..2, 1..2];|| ||rows = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] _
A = sympy.Matrix(rows) _
A[0:2, 0:2]||
||[[# matrix-scalar-mult]][#matrix-scalar-mult-note scalar multiplication]||3 * @@{{1, 2}, {3, 4}}@@ _
@@{{1, 2}, {3, 4}}@@ * 3||3 * <1, 2; 3, 4>; _
<1, 2; 3, 4> * 3;||3 * matrix([1, 2], [3, 4]); _
matrix([1, 2], [3, 4]) * 3;||3 * sympy.Matrix([[1, 2], [3, 4]]) _
sympy.Matrix([[1, 2], [3, 4]]) * 3||
||[[# matrix-elem-wise-op]][#matrix-elem-wise-op-note element-wise operators]||+ - * / _
##gray|//adjacent matrices are multiplied element-wise//##||+ - *~||+ - * /||+ - _
 _
##gray|# for Hadamard product:## _
A.multiply_elementwise(B)||
||[[# matrix-mult]][#matrix-mult-note product]||A = @@{{1, 2}, {3, 4}}@@ _
B = @@{{4, 3}, {2, 1}}@@ _
Dot[A, B] _
##gray|(* or use period: *)## _
A . B||A := <1, 2; 3, 4>; _
B := <4, 3; 2, 1>; _
A . B;||A: matrix([1, 2], [3, 4]); _
B: matrix([4, 3], [2, 1]); _
A . B;||A = sympy.matrix([[1, 2], [3, 4]]) _
B = sympy.matrix([[4, 3], [2, 1]]) _
A * B||
||[[# matrix-power]][#matrix-power-note power]||MatrixPower[@@{{1, 2}, {3, 4}}@@, 3] _
 _
##gray|(* element-wise operator: *)## _
A ^ 3||with(LinearAlgebra): _
 _
MatrixPower(<1, 2; 3, 4>, 3);||matrix([1, 2], [3, 4]) @@^^@@ 3;||A ** 3||
||[[# matrix-exponential]][#matrix-exponential-note exponential]||MatrixExp[@@{{1, 2}, {3, 4}}@@]||with(LinearAlgebra): _
 _
MatrixExponential(<1, 2; 3, 4>);|| || ||
||[[# matrix-log]][#matrix-log-note log]||MatrixLog[@@{{1, 2}, {3, 4}}@@]|| || || ||
||[[# kronecker-prod]][#kronecker-prod-note kronecker product]||A = @@{{1, 2}, {3, 4}}@@ _
B = @@{{4, 3}, {2, 1}}@@ _
KroneckerProduct[A, B]||with(LinearAlgebra): _
 _
A := <1, 2; 3, 4>; _
B := <4, 3; 2, 1>; _
KroneckerProduct(A, B);||A: matrix([1, 2], [3, 4]); _
B: matrix([4, 3], [2, 1]); _
kronecker_product(A, B);|| ||
||[[# matrix-norms]][#matrix-norms-note norms]||A = @@{{1, 2}, {3, 4}}@@ _
 _
Norm[A, 1] _
Norm[A, 2] _
Norm[A, Infinity] _
Norm[A, "Frobenius"]||with(LinearAlgebra): _
 _
A := <1, 2; 3, 4>; _
 _
Norm(A, 1); _
Norm(A, 2); _
Norm(A, infinity); _
Norm(A, Frobenius);||A: matrix([1, 2], [3, 4]); _
 _
mat_norm(A, 1); _
##gray|/* none */## _
mat_norm(A, inf); _
mat_norm(A, frobenius);|| ||
||[[# matrix-transpose]][#matrix-transpose-note transpose]||Transpose[@@{{1, 2}, {3, 4}}@@] _
 _
##gray|(* or ESC tr ESC for T exponent notation *)##||with(LinearAlgebra): _
 _
Transpose(<1, 2; 3, 4>);||transpose(A);||A.T||
||[[# matrix-conjugate-transpose]][#matrix-conjugate-transpose-note conjugate transpose]||A = @@{{1, I}, {2, -I}}@@ _
ConjugateTranspose[A] _
 _
##gray|(* or ESC ct ESC for dagger exponent notation *)##||with(LinearAlgebra): _
 _
A := <1, I; 2, -I>; _
HermitianTranspose(A);||ctranspose(matrix([1, %i], [2, -%i]));||M = sympy.Matrix([[1, sympy.I], [2, -sympy.I]]) _
M.adjoint()||
||[[# matrix-inverse]][#matrix-inverse-note inverse]||Inverse[@@{{1, 2}, {3, 4}}@@] _
 _
##gray|(* expression left unevaluated: *)## _
Inverse[@@{{1, 0}, {0, 0}}@@]||with(LinearAlgebra): _
 _
MatrixInverse(<1, 2; 3, 4>); _
 _
##gray|# error:## _
MatrixInverse(<1, 0; 0, 0>);||invert(A); _
A @@^^@@ -1; _
 _
##gray|/* error: */## _
invert(matrix([1, 0], [0, 0]));||A.inv() _
 _
##gray|# raises ValueError:## _
sympy.Matrix([[1, 0], [0, 0]]).inv()||
||[[# row-echelon-form]][#row-echelon-form-note row echelon form]||RowReduce[@@{{1, 1}, {1, 1}}@@]||with(LinearAlgebra): _
 _
ReducedRowEchelonForm(<1, 1; 1, 1>);||echelon(matrix([1, 1], [1, 1]));|| ||
||[[# pseudoinverse]][#pseudoinverse-note pseudoinverse]||PseudoInverse[@@{{1, 0}, {3, 0}}@@]|| || || ||
||[[# determinant]][#determinant-note determinant]||Det[@@{{1, 2}, {3, 4}}@@]||with(LinearAlgebra): _
 _
Determinant(<1, 2; 3, 4>);||determinant(A);||A.det()||
||[[# trace]][#trace-note trace]||Tr[@@{{1, 2}, {3, 4}}@@]||with(LinearAlgebra): _
 _
Trace(<1, 2; 3, 4>);||load("nchrpl"); _
 _
mattrace(matrix([1, 2], [3, 4]));|| ||
||[[# matrix-rank]][#matrix-rank-note rank]||MatrixRank[@@{{1, 1}, {0, 0}}@@]||with(LinearAlgebra): _
 _
Rank(<1, 1; 0, 0>);||rank(matrix([1, 1], [0, 0]));|| ||
||[[# nullspace-basis]][#nullspace-basis-note nullspace basis]||NullSpace[@@{{1, 1}, {0, 0}}@@]||with(LinearAlgebra): _
 _
NullSpace(<1, 1; 0, 0>);||nullspace(matrix([1, 1], [0, 0]));|| ||
||[[# eigenval]][#eigenval-note eigenvalues]||Eigenvalues[@@{{1, 2}, {3, 4}}@@]||with(LinearAlgebra): _
 _
Eigenvalues(<1, 2; 3, 4>);||##gray|/* returns list of two lists: _
@<&nbsp;&nbsp;&nbsp;>@first is the eigenvalues, _
@<&nbsp;&nbsp;&nbsp;>@second is their multiplicities */## _
eigenvalues(A);||A.eigenvals()||
||[[# eigenvec]][#eigenvec-note eigenvectors]||Eigenvectors[@@{{1, 2}, {3, 4}}@@]||Eigenvectors(<1, 2; 3, 4>);||##gray|/* returns list of two lists.  The first item is the return value of eigenvalues().  The second item is a list containing a list of eigenvectors for each eigenvalue. */## _
eigenvectors(A);||A.eigenvects()||
||[[# spectral-decomposition]][#spectral-decomposition-note spectral decomposition]||A = @@{{1, 2}, {2, 1}}@@ _
z :=  Eigensystem[A] _
d := DiagonalMatrix[z[[1]]] _
P := Transpose[z[[2]]] _
 _
P . d . Inverse[P] == A|| || || ||
||[[# lup-decomposition]][#lup-decomposition-note LUP decomposition]||{lu, p, c} = LUDecomposition[@@{{1, 2}, {3, 4}}@@] _
L = LowerTriangularize[lu] _
U = UpperTriangularize[lu] _
P = Permute[IdentityMatrix[2], p]||L, U, P := LUDecomposition(<1, 2; 3, 4>);|| || ||
||[[# qr-decomposition]][#qr-decomposition-note QR decomposition]||A := @@{{1, 2}, {3, 4}}@@ _
{Q, R} = QRDecomposition[A] _
A == Q . R|| || || ||
||[[# jordan-decomposition]][#jordan-decomposition-note jordan decomposition]||A := {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}} _
z := JordanDecomposition[A] _
P := z[[1]] _
J := z[[2]] _
A . P == P . J|| || || ||
||[[# svd]][#svd-note singular value decomposition]||A := @@{{1, 2}, {3, 4}}@@ _
z := SingularValueDecomposition[A] _
U := z[[1]] _
S := z[[2]] _
V := z[[3]] _
 _
N[A] == N[U . S . ConjugateTranspose[V]]|| || || ||
||[[# polar-decomposition]][#polar-decomposition-note polar decomposition]||A := @@{{1, 2}, {3, 4}}@@ _
{u, s, v} := SingularValueDecomposition[A] _
vt :=  ConjugateTranspose[v] _
 _
U := u * vt _
P =  v * s * vt|| || || ||
||||||||||~ [[# combinatorics]][#combinatorics-note combinatorics]||
||~ ||~ mathematica||~ maple||~ maxima||~ sympy||
||[[# factorial]][#factorial-note factorial]||5! _
Factorial[5] _
 _
Permutations[Range[1, 5]]||5! _
factorial(5)||5! _
factorial(5);||sympy.factorial(5)||
||[[# binomial-coefficient]][#binomial-coefficient-note binomial coefficient]||Binomial[10, 3]||binomial(10, 3)||binomial(10, 3);||sympy.binomial(10, 3)||
||[[# multinomial-coefficient]][#multinomial-coefficient-note multinomial coefficient]||Multinomial[3, 4, 5]||with(combinat): _
 _
multinomial(12, 3, 4, 5);||multinomial(12, [3, 4, 5]);|| ||
||[[# int-partitions]][#int-partitions-note integer partitions]||PartitionsP[10] _
 _
##gray|(* the partitions as an array: *)## _
IntegerPartitions[10]||with(combinat): _
 _
numbpart(10); _
 _
##gray|# the partitions as an array:## _
partition(10);||length(integer_partitions(10)); _
 _
##gray|/* the partitions as an array: */## _
integer_partitions(10); _
 _
||from sympy.utilities.iterables import partitions _
 _
len(list(partitions(10))) _
 _
[p.copy() for p in partitions(10)]||
||[[# compositions]][#compositions-note compositions]||needs["Combinatorica`"] _
 _
NumberOfCompositions[10, 3] _
Compositions[10, 3]||with(combinat): _
 _
numbcomp(10, 3); _
composition(10, 3);|| || ||
||[[# set-partitions]][#set-partitions-note set partitions]||StirlingS2[10, 3] _
 _
needs["Combinatorica`"] _
 _
KSetPartitions[10, 3] _
SetPartititions[10]||Stirling2(10, 3);||stirling2(10, 3);|| ||
||[[# bell-num]][#bell-num-note bell number]||BellB[10]||with(combinat): _
 _
bell(10);|| ||sympy.bell(10)||
||[[# permutations-k-disjoint-cycles]][#permutations-k-disjoint-cyclces permutations with k disjoint cycles]||Abs[StirlingS1[10, 3]]||abs(Stirling1(10, 3));||abs(stirling1(10, 3));|| ||
||[[# fibonacci-num]][#fibonacci-num-note fibonacci number] _
 _
##gray|//and lucas number//##||Fibonacci[10] _
LucasL[10]||with(combinat): _
 _
fibonacci(10);||fib(10); _
lucas(10);||sympy.fibonacci(10) _
sympy.lucas(10)||
||[[# bernoulli-num]][#bernoulli-num-note bernoulli number]||BernoulliB[100]||bernoulli(100);||bern(100);||sympy.bernoulli(100)||
||[[# harmonic-num]][#harmonic-num-note harmonic number]||HarmonicNumber[100]||sum(1/n, n = 1 .. 100);|| ||sympy.harmonic(100)||
||[[# catalan-num]][#catalan-num-note catalan number]||CatalanNumber[10]|| || ||sympy.catalan(10)||
||||||||||~ [[# number-theory]][#number-theory-note number theory]||
||~ ||~ mathematica||~ maple||~ maxima||~ sympy||
||[[# pseudoprime-test]][#pseudoprime-test-note pseudoprime test]||PrimeQ[7]||isprime(7);||primep(7);||sympy.ntheory.primetest.isprime(7) _
sympy.ntheory.primetest.mr(7, [2, 3])||
||[[# divisors]][#divisors-note divisors]||##gray|(* {1, 2, 4, 5, 10, 20, 25, 50, 100}: *)## _
Divisors[100]||with(NumberTheory): _
 _
Divisors(100);||divisors(100);||sympy.ntheory.divisors(100)||
||[[# prime-factors]][#prime-factors prime factors]||##gray|(* returns @<{{>@2, 2}, {3, 1}, {7, 1}} *)## _
FactorInteger[84]||##gray|# [1, [[2, 2], [3, 1], [7, 1]]]:## _
ifactors(84);||##gray|/* 2^2 3 7: */## _
factor(84); _
 _
##gray|/* [[2,2],[3,1],[7,1]]: */## _
ifactors(84);||##gray|# {2: 2, 3: 1, 7: 1}:## _
sympy.ntheory.factorint(84)||
||[[# next-prime]][#next-prime-note next prime] _
 _
##gray|//and preceding//##||NextPrime[1000] _
NextPrime[1000, -1]||nextprime(1000); _
prevprime(1000);||next_prime(1000); _
prev_prime(1000);||sympy.ntheory.generate.nextprime(1000) _
sympy.ntheory.generate.prevprime(1000)||
||[[# nth-prime]][#nth-prime-note nth prime]||##gray|(* 541: *)## _
Prime[100]||ithprime(100);|| ||sympy.ntheory.generate.prime(100)||
||[[# prime-counting-func]][#prime-counting-func-note prime counting function]||##gray|(* 25: *)## _
PrimePi[100]||with(NumberTheory): _
 _
pi(100);|| ||sympy.ntheory.generate.primepi(100)||
||[[# divmod]][#divmod-note divmod] _
@<&nbsp;>@||QuotientRemainder[7, 3]|| ||divide(7, 3);||divmod(7, 3)||
||[[# gcd]][#gcd-note greatest common divisor] _
 _
##gray|//and relatively prime test//##||GCD[14, 21] _
GCD[14, 21, 777] _
 _
CoprimeQ[14, 21]||igcd(14, 21); _
igcd(14, 21, 777); _
 _
with(NumberTheory): _
 _
AreCoprime(14, 21);||gcd(14, 21); _
gcd(gcd(14, 21), 777);||sympy.gcd(14, 21) _
sympy.gcd(sympy.gcd(14, 21), 777)||
||[[# extended-euclidean-algorithm]][#extended-euclidean-algorithm-note extended euclidean algorithm]||##gray|(* {1, {2, -1}}: *)## _
ExtendedGCD[3, 5]||##gray|# Returns 1; _
# sets a and b to 2 and -1:## _
igcdex(3, 5, 'a', 'b')||##gray|/* [2,-1,1]: */## _
gcdex(3, 5);||import sympy.ntheory.modular _
 _
##gray|# (2, -1, 1):## _
sympy.ntheory.modular.igcdex(3, 5)||
||[[# lcm]][#lcm-note least common multiple]||LCM[14, 21]||ilcm(14, 21);||lcm(14, 21);||sympy.lcm(14, 21)||
||[[# mult-inverse]][#mult-inverse-note multiplicative inverse]||##gray|(* inverse of 2 mod 7: *)## _
PowerMod[2, -1, 7] _
 _
##gray|(* left unevaluated: *)## _
PowerMod[2, -1, 4]|| || || ||
||[[# chinese-remainder-thm]][#chinese-remainder-thm-note chinese remainder theorem]||##gray|(* returns 173, which is equal to 3 mod 17 and 8 mod 11: *)## _
ChineseRemainder[{3, 8}, {17, 11}]||##gray|# 173:## _
chrem([3, 8], [17, 11]);||##gray|/* 173: */## _
chinese([3, 8], [17, 11]);|| ||
||[[# euler-totient]][#euler-totient-note euler totient] _
@<&nbsp;>@||EulerPhi[256]||with(NumberTheory): _
 _
Totient(256);||totient(256);||sympy.ntheory.totient(256)||
||[[# mult-order]][#mult-order-note multiplicative order]||MultiplicativeOrder[7, 108]||with(NumberTheory): _
 _
MultiplicativeOrder(7, 108);|| || ||
||[[# primitive-roots]][#primitive-roots-note primitive roots]||PrimitiveRoot[11] _
 _
##gray|(* all primitive roots: *)## _
PrimitiveRootList[11]||with(NumberTheory): _
 _
PrimitiveRoot(11);|| || ||
||[[# discrete-log]][#discrete-log-note discrete logarithm]|| ||ModularLog(10, 2, 11);|| || ||
||[[# carmichael-func]][#carmichael-func-note carmichael function]||CarmichaelLambda[561]||with(NumberTheory): _
 _
CarmichaelLambda(561);|| || ||
||[[# kronecker-symbol]][#kronecker-symbol-note kronecker symbol] _
 _
##gray|//and jacobi symbol//##||KroneckerSymbol[3, 5] _
JacobiSymbol[3, 5]||with(NumberTheory): _
 _
KroneckerSymbol(3, 5); _
JacobiSymbol(3, 5);||##gray|//??//## _
jacobi(3, 5);|| ||
||[[# moebius-func]][#moebius-func-note moebius function]||MoebiusMu[11]||with(NumberTheory): _
 _
Moebius(11);||moebius(11);|| ||
||[[# riemann-zeta-func]][#riemann-zeta-func-note riemann zeta function]||Zeta[2]||Zeta(2);||zeta(2);||sympy.mpmath.zeta(2)||
||[[# mangoldt-lambda]][#mangoldt-lambda-note mangoldt lambda]||MangoldtLambda[11]|| || || ||
||[[# dirichlet-char]][#dirichlet-char-note dirichlet character]||Table[DirichletCharacter[2, 1, i], {i, 100}]|| || || ||
||to continued fraction||cf = ContinuedFraction[Pi, 100]|| || || ||
||from continued fraction||##gray|(* rational approx. of Ï€: *)## _
FromContinuedFraction[cf]|| || || ||
||||||||||~ [[# polynomials]][#polynomials-note polynomials]||
||~ ||~ mathematica||~ maple||~ maxima||~ sympy||
||from expression with indeterminates||(x - 1) (x - 2) _
 _
(x + 1)^2 (y + 2)^3|| || || ||
||from coefficient array||coeff = {1, -3, 2} _
Plus @@ Table[coeff[[i]] * x^(3 - i), {i, 1, 3}]|| || || ||
||to coefficient array||CoefficientList[(x + 1)^10, x]|| || || ||
||lookup coefficient||Coefficient[(1 + x)^10, x, 3]|| || || ||
||substitute indeterminate|| || || || ||
||degree||Exponent[(x + 1)^10, x]|| || || ||
||operations||+ - * /|| || || ||
||division and remainder||PolynomialReduce[x^10 - 1, x - 1, {x}] _
PolynomialReduce[x^10 - y^10, x - y, {x, y}]|| || || ||
||[#expand-polynomial expand polynomial]||Expand[(1 + x)^5]|| || ||sympy.expand((1+x)@@**@@5)||
||[#factor-polynomial factor polynomial]||Factor[3 + 10 x + 9 x^2 + 2 x^3]|| || ||sympy.factor(3 + 10*x + 9*x@@**@@2 + 2*x@@**@@3)||
||collect terms||##gray|(* write as polynomial in x: *)## _
Collect[(1 + x + y)^3, x]|| || ||sympy.collect(sympy.expand((x+y+1)**3), x)||
||factor||Factor[x^10 - y^10]|| || || ||
||roots||Solve[x^3 + 3 x^2 + 2 x - 1 == 0, x]|| || || ||
||greatest common divisor||p1 = -2 - x + 2 x^2 + x^3 _
p2 = 6 - 7 x + x^3 _
PolynomialGCD[p1, p2]|| || || ||
||resultant||Resultant[(x-1)(x-2), (x-3)(x-3), x]|| || || ||
||discriminant||Discriminant[(x + 1) (x - 2), x]|| || || ||
||groebner basis||p1 = x^2 + y + z - 1 _
p2 = x + y^2 + z - 1 _
p3 = x + y + z^2 - 1 _
 _
##gray|(* uses lexographic order by default: *)## _
GroebnerBasis[{p1, p2, p3}, {x, y, z}]|| || || ||
||specify ordering|| || || || ||
||symmetric polynomial||SymmetricPolynomial[3, {x1, x2, x3, x4}]|| || || ||
||cyclotomic polynomial||Cyclotomic[10, x]|| || || ||
||hermite polynomial||HermiteH[4, x]|| || || ||
||chebyshev polynomial _
 _
##gray|//first and second kind//##||ChebyshevT[4, x] _
ChebyshevU[4, x]|| || || ||
||interpolation polynomial||pts = Inner[List, {1, 2, 3}, {2, 4, 7}, List] _
InterpolatingPolynomial[pts, x]|| || || ||
||characteristic polynomial||CharacteristicPolynomial[@@{{1, 2}, {3, 4}}@@, x]|| || || ||
||minimal polynomial|| || || || ||
||piecewise polynomial|| || || || ||
||rational function||(x - 1) / (x - 2)^2|| || || ||
||[#add-fractions add fractions]||Together[a/b + c/d]|| || ||sympy.together(x/y + z/w)||
||[#partial-fraction-decomposition partial fraction decomposition]||Apart[(b c + a d)/(b d)]|| || ||##gray|# only one symbol allowed in denominator:## _
sympy.apart((3*x+2) / (x*(x+1)))||
||||||||||~ [[# trigonometry]][#trigonometry-note trigonometry]||
||~ ||~ mathematica||~ maple||~ maxima||~ sympy||
||eliminate sums and multiples inside trig functions||TrigExpand[Sin[2 x + y]]|| || || ||
||eliminate powers of trig functions||TrigReduce[Sin[x]^2]|| || || ||
||trig to complex exponential|| || || || ||
||complex exponential to trig|| || || || ||
||fourier expansion||##gray|(* integrals are over [-Ï€, Ï€] *)## _
f[x_] = Piecewise[@@{{@@0, 0 <= x @@&&@@ x < Pi}, _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@{1, -Pi <= x @@&&@@ x < 0@@}}@@] _
 _
##gray|(* in sin and cos: *)## _
FourierTrigSeries[f[x], x, 10] _
 _
##gray|(* in complex exponentials: *)## _
FourierSeries[f[x], x, 10]|| || || ||
||fourier transform||f[Ï‰_] = FourierTransform[ Sin[t], t, Ï‰] _
 _
InverseFourierTransform[f[Ï‰], Ï‰, t]|| || || ||
||||||||||~ [[# special-functions]][#special-functions-note special functions]||
||~ ||~ mathematica||~ maple||~ maxima||~ sympy||
||gamma||Gamma[1/2]||GAMMA(1/2);s|| || ||
||hyperbolic||Sinh Cosh Tanh _
ArcSinh ArcCosh ArcTanh||sinh cosh tanh _
arcsinh arccosh arctanh|| || ||
||elliptic integerals||EllipticK EllipticF _
EllipticE _
EllipticPi||EllipticK EllipticF _
EllipticE _
EllipticPi|| || ||
||bessel functions||BesselJ _
BesselY _
BesselI _
BesselK||BesselJ _
BesselY _
BesselI _
BesselK|| || ||
||||||||||~ [[# permutations]][#permutations-note permutations]||
||~ ||~ mathematica||~ maple||~ maxima||~ sympy||
||permutation from disjoint cycles||p = Cycles[@@{{1, 2}, {3, 4}}@@]|| || ||import sympy.combinatorics as combinatorics _
 _
p = combinatorics.Permutation(0, 1)(2, 3)||
||permutation from list||p = PermutationCycles[{2, 1, 4, 3}]|| || ||import sympy.combinatorics as combinatorics _
 _
p = combinatorics.Permutation([1, 0, 3, 2])||
||permutation from two lists||FindPermutation[{a, b, c}, {b, c, a}]|| || || ||
||act on element||p = Cycles[@@{{1, 2}, {3, 4}}@@] _
 _
PermutationReplace[1, p]|| || ||p(0)||
||act on list||##gray|(* if list is too big, extra elements retain _
@<&nbsp;&nbsp;&nbsp;>@their positions; if list is too small, _
@<&nbsp;&nbsp;&nbsp;>@expression is left unevaluated. *)## _
Permute[{a, b, c, d}, p12n34]|| || ||a, b, c, d = sympy.symbols('a b c d') _
  _
p = combinatorics.Permutation(0, 1)(2, 3) _
p([a, b, c, d])||
||compose||p1 = Cycles[@@{{1, 2}, {3, 4}}@@] _
p2 = Cycles[@@{{1, 3}}@@] _
PermutationProduct[p1, p2]|| || ||p1 = combinatorics.Permutation(0, 1)(2, 3) _
p2 = combinatorics.Permutation(0, 2) _
 _
p1 * p2||
||invert||InversePermutation[Cycles[@@{{1, 2, 3}}@@]]|| || ||p = combinatorics.Permutation(0, 1, 2) _
 _
p ** -1||
||power||PermutationPower[Cycles[@@{{1, 2, 3, 4, 5}}@@], 3]|| || ||p = combinatorics.Permutation(0, 1, 2, 3, 4) _
 _
p ** 3||
||order||PermutationOrder[Cycles[@@{{1, 2, 3, 4, 5}}@@]]|| || ||combinatorics.Permutation(0, 1, 2, 3, 4).order()||
||support||PermutationSupport[Cycles[@@{{1, 3, 5}, {7, 8}}@@]]|| || ||p = combinatorics.Permutation(0, 2, 4)(6, 7) _
 _
p.support()||
||number of inversions|| || || ||Permutation(0, 2, 1).inversions()||
||parity|| || || ||Permutation(0, 2, 1).parity()||
||to inversion vector|| || || ||Permutation(0, 2, 1).inversion_vector()||
||from inversion vector|| || || ||Permutation.from_inversion_vector([2, 0])||
||all permutations||GroupElements[SymmetricGroup[4]] _
 _
##gray|(* of a list: *)## _
Permutations[{a, b, c, d}]|| || || ||
||random permutation||RandomPermutation[10]|| || ||Permutation.random(10)||
||||||||||~ [[# groups]][#groups-note groups]||
||~ ||~ mathematica||~ maple||~ maxima||~ sympy||
||group from permutation generators||e1 = Cycles[@@{{1, 3, 5, 2}}@@] _
e2 = Cycles[@@{{1, 2}}@@] _
g := PermutationGroup[{e1, e2}]|| || ||from sympy.combinatorics import * _
 _
p1 = Permutation(0, 2, 4, 1) _
p2 = Permutation(0, 1) _
g = PermutationGroup(p1, p2)||
||named groups _
 _
##gray|//symmetric, alternating, cyclic, dihedral//##||s4 = SymmetricGroup[4] _
a4 = AlternatingGroup[4] _
z5 = CyclicGroup[5] _
d10 = DihedralGroup[10]|| || ||from sympy.combinatorics import * _
 _
s4 = SymmetricGroup(4) _
a4 = AlternatingGroup(4) _
z5 = CyclicGroup(5) _
d10 = DihedralGroup(10)||
||groups by size|| || || || ||
||direct product|| || || ||from sympy.combinatorics import * _
 _
z3 = CyclicGroup(3) _
a4 = AlternatingGroup(4) _
g = DirectProduct(z3, a4)||
||free product|| || || || ||
||free group|| || || || ||
||all elements||GroupElements[DihedralGroup[10]]|| || || ||
||identity element||Cycles[{}]|| || || ||
||random element||RandomSample[GroupElements[g], 1][[1]]|| || ||g.random()||
||group operation||e1 := RandomSample[GroupElements[g], 1][[1]] _
e2 := RandomSample[GroupElements[g], 1][[1]] _
PermutationProduct[e1, e2]|| || ||e1 = g.random() _
e2 = g.random() _
e1 * e2||
||inverse element|| || || ||e1**-1||
||commutator|| || || ||##gray|# e2 ** -1 * e1 ** -1 * e2 * e1:## _
e1.commutator(e2)||
||generators|| || || ||g.generators||
||express element using generators|| || || || ||
||number of elements by generator word length|| || || || ||
||group from finite presentation|| || || || ||
||order of group element|| || || || ||
||order||GroupOrder[g]|| || ||g.order()||
||cyclic test|| || || || ||
||abelian test|| || || ||g.is_abelian||
||identify|| || || || ||
||cosets|| || || || ||
||||||||||~ [[# subgroups]][#subgroups-note subgroups]||
||~ ||~ mathematica||~ maple||~ maxima||~ sympy||
||all subgroups|| || || || ||
||subgroup lattice|| || || || ||
||maximal subgroups|| || || || ||
||frattini subgroup|| || || || ||
||subgroup from generators|| || || || ||
||normal subgroups|| || || || ||
||center|| || || ||g.center()||
||centralizer|| || || || ||
||normalizer|| || || || ||
||commutator subgroup|| || || || ||
||subgroup test|| || || || ||
||subgroup index|| || || || ||
||normal test|| || || || ||
||subnormal test|| || || || ||
||nonabelian simple groups|| || || || ||
||simple test|| || || || ||
||solvable test|| || || ||g.is_solvable||
||derived series|| || || ||g.derived_series()||
||characteristic test|| || || || ||
||semidirect product|| || || || ||
||||||||||~ [[# group-homomorphisms]][#group-homomorphisms-note group homomorphisms]||
||~ ||~ mathematica||~ maple||~ maxima||~ sympy||
||all homomorphisms|| || || || ||
||all homomorphims classes|| || || || ||
||endomorphisms and automorphisms|| || || || ||
||homomorphism from generator images|| || || || ||
||surjective test|| || || || ||
||injective test|| || || || ||
||bijective test|| || || || ||
||kernel|| || || || ||
||image|| || || || ||
||||||||||~ [[# actions]][#actions-note actions]||
||~ ||~ mathematica||~ maple||~ maxima||~ sympy||
||conjugate element|| || || || ||
||conjugate set|| || || || ||
||conjugacy class|| || || || ||
||conjugacy classes|| || || || ||
||stabilizer|| || || || ||
||orbit|| || || || ||
||transitive test|| || || || ||
||||||||||~ [[# descriptive-statistics]][#descriptive-statistics-note descriptive statistics]||
||~ ||~ mathematica||~ maple||~ maxima||~ sympy||
||[[# first-moment-stats]][#first-moment-stats-note first moment statistics]||vals = {1, 2, 3, 8, 12, 19} _
X = NormalDistribution[0, 1] _
 _
Mean[vals] _
Total[vals] _
Mean[X]|| || || ||
||[[# second-moment-stats]][#second-moment-stats-note second moment statistics]||Variance[X] _
StandardDeviation[X]|| || || ||
||[[# second-moment-stats-sample]][#seond-moment-stats-sample-note second moment statistics for samples]||Variance[vals] _
StandardDeviation[vals]|| || || ||
||[[# skewness]][#skewness-note skewness]||Skewness[vals] _
Skewness[X]|| || || ||
||[[# kurtosis]][#kurtosis-note kurtosis]||Kurtosis[vals] _
Kurtosis[X]|| || || ||
||[[# nth-moment]][#nth-moment-note nth moment and nth central moment]||Moment[vals, 5] _
CentralMoment[vals, 5] _
Moment[X, 5] _
CentralMoment[X, 5] _
 _
MomentGeneratingFunction[X, t]|| || || ||
||[[# cumulant]][#cumulant-note cumulant]||Cumulant[vals, 1] _
Cumulant[X, 1] _
 _
CumulantGeneratingFunction[X, t]|| || || ||
||[[# entropy]][#entropy-note entropy]||Entropy[vals]|| || || ||
||[[# mode]][#mode-note mode]||Commonest[{1, 2, 2, 2, 3, 3, 8, 12}]|| || || ||
||[[# quantile-stats]][#quantile-stats-note quantile statistics]||Min[vals] _
Median[vals] _
Max[vals] _
InterquartileRange[vals] _
Quantile[vals, 9/10]|| || || ||
||[[# bivariate-stats]][#bivariate-stats-note bivariate statistiscs] _
##gray|//correlation, covariance//##||Correlation[{1, 2, 3}, {2, 4, 7}] _
Covariance[{1, 2, 3}, {2, 4, 7}]|| || || ||
||[[# freq-table]][#freq-table-note data set to frequency table]||data = {1, 2, 2, 2, 3, 3, 8, 12} _
##gray|(* list of pairs: *)## _
tab = Tally[data] _
##gray|(* dictionary: *)## _
dict = Counts[data]|| || || ||
||[[# invert-freq-table]][#invert-freq-table-note frequency table to data set]||f = Function[a, Table[a[[1]], {i, 1, a[[2]]}]] _
data = Flatten[Map[f, tab]]|| || || ||
||[[# bin]][#bin-note bin]||data = {1.1, 3.7, 8.9, 1.2, 1.9, 4.1} _
##gray|(* bins are [0, 3), [3, 6), and [6, 9): *)## _
bins = BinCounts[data, {{0, 3, 6, 9}}]|| || || ||
||||||||||~ [[# distributions]][#distributions-note distributions]||
||~ ||~ mathematica||~ maple||~ maxima||~ sympy||
||[[# binomial]][#binomial-note binomial] _
 _
##gray|//density, cumulative distribution, sample//##||X = BinomialDistribution[100, 1/2] _
 _
PDF[X][50] _
CDF[X][50] _
RandomVariate[X]|| || ||from sympy.stats import * _
 _
X = Binomial('X', 100, sympy.Rational(1, 2)) _
 _
density(Y).dict[sympy.Integer(50)] _
P(X < 50) _
sample(X)||
||[[# poisson]][#poisson-note poisson]||X = PoissonDistribution[1]|| || ||##gray|# P(X < 4) raises NotImplementedError:## _
X = Poisson('X', 1)||
||[[# discrete-uniform]][#discrete-uniform-note discrete uniform]||X = DiscreteUniformDistribution[{0, 99}]|| || ||X = DiscreteUniform('X', list(range(0, 100)))||
||[[# normal]][#normal-note normal] _
 _
##gray|//density, cumulative distribution, quantile, sample//##||X = NormalDistribution[0, 1] _
 _
PDF[X][0] _
CDF[X][0] _
InverseFunction[CDF[X]][1/2] _
RandomVariate[X]|| || ||from sympy.stats import * _
 _
X = Normal('X', 0, 1) _
 _
density(X)(0) _
P(X < 0) _
##gray|//??//## _
sample(X)||
||[[# gamma]][#gamma-note gamma]||X = GammaDistribution[1, 1]|| || ||X = Gamma('X', 1, 1)||
||[[# exponential]][#exponential-note exponential]||X = ExponentialDistribution[1]|| || ||X = Exponential('X', 1)||
||[[# chi-squared]][#chi-squared-note chi-squared]||X = ChiSquareDistribution[2]|| || ||X = ChiSquared('X', 2)||
||[[# beta]][#beta-note beta]||X = BetaDistribution[10, 90]|| || ||X = Beta('X', 10, 90)||
||[[# uniform]][#uniform-note uniform]||X = UniformDistribution[{0, 1}]|| || ||X = Uniform('X', 0, 1)||
||[[# students-t]][#students-t-note student's t]||X = StudentTDistribution[2]|| || ||X = StudentT('X', 2)||
||[[# snedecors-f]][#snedecors-f-note snedecor's F]||X = FRatioDistribution[1, 1]|| || ||X = FDistribution('X', 1, 1)||
||[[# empirical-density-func]][#empirical-density-func-note empirical density function]||X = NormalDistribution[0, 1] _
data = Table[RandomVariate[X], {i, 1, 30}] _
Y = EmpiricalDistribution[data] _
PDF[Y]|| || || ||
||[[# empirical-cumulative-distribution]][#empirical-cumulative-distribution-note empirical cumulative distribution]||X = NormalDistribution[0, 1] _
data = Table[RandomVariate[X], {i, 1, 30}] _
Y = EmpiricalDistribution[data] _
Plot[CDF[Y][x], {x, -4, 4}]|| || || ||
||||||||||~ [[# univariate-charts]][#univariate-chart-note univariate charts]||
||~ ||~ mathematica||~ maple||~ maxima||~ sympy||
||[[image http://farm5.static.flickr.com/4090/5039793334_f76edece33_m.jpg]] [#bar-chart vertical bar chart]||BarChart[{7, 3, 8, 5, 5}, _
@<&nbsp;&nbsp;>@ChartLegends-> _
@<&nbsp;&nbsp;&nbsp;&nbsp;>@{"a","b","c","d","e"}]|| || || ||
||[[image http://farm5.static.flickr.com/4092/5039776078_cc38a4ff5f_m.jpg]] _
[#horizontal-bar-chart horizontal bar chart]||BarChart[{7, 3, 8, 5, 5}, BarOrigin -> Left]|| || || ||
||[[image http://farm5.static.flickr.com/4145/5037819710_d932767cd5_m.jpg]] [#pie-chart pie chart]||PieChart[{7, 3, 8, 5, 5}]|| || || ||
||[[image http://farm5.static.flickr.com/4089/5037399669_13c8e585e0_m.jpg]] _
[#stem-and-leaf-plot stem-and-leaf plot]||Needs["StatisticalPlots@@`@@"] _
nd = NormalDistribution[0, 1] _
n100 = RandomVariate[nd, 100] _
StemLeafPlot[20 * n100]|| || || ||
||[[image http://farm5.static.flickr.com/4106/5037415497_4c6fbfcab2_m.jpg]] [#histogram histogram]||nd = NormalDistribution[0, 1] _
Histogram[RandomReal[nd, 100], 10]|| || || ||
||[[image http://farm5.static.flickr.com/4106/5037525393_7ac86e81c3_m.jpg]] [#box-and-whisker-plot box-and-whisker plot]||nd = NormalDistribution[0, 1] _
n100 = RandomVariate[nd, 100] _
BoxWhiskerChart[d] _
 _
ed = ExponentialDistribution[1] _
e100 = RandomVariate[ed, 100] _
u100 = RandomReal[1, 100] _
d = {n100, e100, u100} _
BoxWhiskerChart[d]|| || || ||
||[#univariate-title set chart title]||BoxWhiskerChart[data, _
@<&nbsp;&nbsp;>@PlotLabel -> "chart example"]|| || || ||
||[#chart-options chart options]||PlotLabel -> "an example" _
 _
AxisLabel -> {"time", "distance"}|| || || ||
||||||||||~ [[# bivariate-charts]][#bivariate-chart-note bivariate charts]||
||~ ||~ mathematica||~ maple||~ maxima||~ sympy||
||[[image http://farm5.static.flickr.com/4154/5039126187_e340b3f4aa_m.jpg]] _
[#stacked-bar-chart stacked bar chart]||d = @@{{@@7, 1}, {3, 2}, {8, 1}, _
@<&nbsp;&nbsp;>@{5, 3}, {5, 1}} _
BarChart[d, ChartLayout -> _
@<&nbsp;&nbsp;>@"Stacked"]|| || || ||
||[[image http://farm6.static.flickr.com/5044/5267212089_a7749bbe3e_s.jpg]] [#scatterplot scatter plot]||nd = NormalDistribution[0, 1] _
rn = Function[RandomReal[nd]] _
d = {rn[],rn[]} & /@ Range[1,50] _
ListPlot[d]|| || || ||
||[[image http://farm6.static.flickr.com/5089/5267975488_2216ae147e_s.jpg]][#linear-regression-line linear regression line]||d = Table[{i, _
@<&nbsp;&nbsp;>@2 i + RandomReal[{-5, 5}]}, _
@<&nbsp;&nbsp;>@{i, 0, 20}] _
model = LinearModelFit[d, x, x] _
Show[ListPlot[d], _
@<&nbsp;&nbsp;>@Plot[model["BestFit"], _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@{x, 0, 20}]]|| || || ||
||[[image http://farm6.static.flickr.com/5125/5267434941_f8537c9d26_s.jpg]] [#polygonal-plot polygonal line plot]||f = Function[i, {i, rn[]}] _
d = f /@ Range[1, 20] _
ListLinePlot[d]|| || || ||
||[[image http://farm6.static.flickr.com/5041/5268071368_75c3aee42e_t.jpg]] [#area-chart area chart]||d = @@{{@@7, 1, 3, 2, 8}, _
@<&nbsp;&nbsp;>@{1, 5, 3, 5, 1}} _
sd = {d[[1]], d[[1]] + d[[2]]} _
ListLinePlot[sd, Filling -> _
@<&nbsp;&nbsp;>@{1 -> {Axis, LightBlue}, _
@<&nbsp;&nbsp;&nbsp;>@2 -> @@{{@@1}, LightRed}}]|| || || ||
||[[image http://farm6.static.flickr.com/5049/5268229340_0b96b5e223_s.jpg]] [#cubic-spline cubic spline]||d = Table[{i, RandomReal[nd]}, _
@<&nbsp;&nbsp;>@{i, 0, 20}] _
f = Interpolation[d, _
@<&nbsp;&nbsp;>@InterpolationOrder -> 3] _
Show[ListPlot[d], _
@<&nbsp;&nbsp;>@Plot[f[x], {x, 0, 20}]]|| || || ||
||[[image http://farm6.static.flickr.com/5204/5268208606_b745646ea6_s.jpg]] [#function-plot function plot]||Plot[Sin[x], {x, -4, 4}]|| || || ||
||[[image http://farm6.static.flickr.com/5048/5267567389_27a19429e4_s.jpg]] [#qq-plot quantile-quantile plot]||nd = NormalDistribution[0, 1] _
d1 = RandomReal[1, 50] _
d2 = RandomReal[nd, 50] _
QuantilePlot[d1, d2]|| || || ||
||[#axis-label axis label]||d = Table[{i, i^2}, {i, 1, 20}] _
ListLinePlot[d, _
@<&nbsp;&nbsp;>@AxesLabel -> {x, x^2}]|| || || ||
||[[# axis-limits]][#axis-limits-note axis limits]||Plot[x^2, {x, 0, 20}, _
@<&nbsp;&nbsp;>@PlotRange -> @@{{0, 20}, {-200, 500}}@@]|| || || ||
||[#logarithmic-y-axis logarithmic y-axis]||LogPlot[{x^2, x^3, x^4, x^5}, _
@<&nbsp;&nbsp;>@{x, 0, 20}]|| || || ||
||||||||||~ [[# trivariate-charts]][#trivariate-chart-note trivariate charts]||
||~ ||~ mathematica||~ maple||~ maxima||~ sympy||
||[#3d-scatter-plot 3d scatter plot]||nd = NormalDistribution[0,1] _
d = RandomReal[nd, {50, 3}] _
ListPointPlot3D[d]|| || || ||
||[[image http://farm6.static.flickr.com/5245/5268191292_a75a367c39_s.jpg]] [#additional-data additional data set]||nd = NormalDistribution[0, 1] _
x1 = RandomReal[nd, 20] _
x2 = RandomReal[nd, 20] _
ListLinePlot[{x1, x2}]|| || || ||
||[#bubble-chart bubble chart]||nd = NormalDistribution[0,1] _
d = RandomReal[nd, {50, 3}] _
BubbleChart[d]|| || || ||
||[#surface-plot surface plot]||Plot3D[Sinc[Sqrt[x^2 + y^2]], _
@<&nbsp;&nbsp;>@{x, -25, 25}, _
@<&nbsp;&nbsp;>@{y, -25, 25}]|| || || ||
||~ ||~ ##EFEFEF|@@_______________________________________________________@@##||~ ##EFEFEF|@@_______________________________________________________@@##||~ ##EFEFEF|@@_______________________________________________________@@##||~ ##EFEFEF|@@_______________________________________________________@@##||



[[# version-used-note]]
++ [#version-used version used]

The version of software used to check the examples in the reference sheet.

[[# show-version-note]]
++ [#show-version show version]

How to determine the version of an installation.

[[# implicit-prologue-note]]
++ [#implicit-prologue implicit prologue]

Code assumed to have been executed by the examples in the sheet.

[[# grammar-invocation-note]]
+ [#grammar-invocation Grammar and Invocation]

[[# interpreter-note]]
++ [#interpreter interpreter]

How to execute a script.

**mathematica:**

The full path to MathKernel on Mac OS X:

[[code]]
/Applications/Mathematica.app/Contents/MacOS/MathKernel
[[/code]]

[[# repl-note]]
++ [#repl repl]

How to launch a command line read-eval-print loop for the language.

[[# block-delimiters-note]]
++ [#block-delimiters block delimiters]

How blocks are delimited.

[[# stmt-separator-note]]
++ [#stmt-separator statement separator]

How statements are separated.

[[# eol-comment-note]]
++ [#eol-comment end-of-line comment]

Character used to start a comment that goes to the end of the line.

[[# multiple-line-comment-note]]
++ [#multiple-line-comment multiple line comment]

The syntax for a delimited comment which can span lines.

[[# var-expr-note]]
+ [#var-expr Variables and Expressions]

[[# assignment-note]]
++ [#assignment assignment]

How to perform assignment.

Mathematica, Sympy, and Pari/GP support the chaining of assignments.  For example, in Mathematica one can assign the value 3 to {{x}} and {{y}} with:

[[code]]
x = y = 3
[[/code]]

In Mathematica and Pari/GP, assignments are expressions.  In Mathematica, the following code is legal and evaluates to 7:

[[code]]
(x = 3) + 4
[[/code]]

In Mathematica, the {{Set}} function behaves identically to assignment and can be nested:

[[code]]
Set[a, Set[b, 3]]
[[/code]]

[[# delayed-assignment-note]]
++ [#delayed-assignment delayed assignment]

How to assign an expression to a variable name.  The expression is re-evaluated each time the variable is used.

**mathematica:**

GNU make also supports assignment and delayed assignment, but {{=}} is used for delayed assignment and {{:=}} is used for immediate assignment.  This is the opposite of how Mathematica uses the symbols.

The POSIX standard for make only has {{=}} for delayed assignment.

[[# parallel-assignment-note]]
++ [#parallel-assignment parallel assignment]

How to assign values in parallel.

Parallel assignment can be used to swap the values held in two variables.

[[# compound-assignment-note]]
++ [#compound-assignment compound assignment]

The compound assignment operators.

[[# incr-decr-note]]
++ [#incr-decr increment and decrement]

Increment and decrement operators which can be used in expressions.

[[# non-referential-id-note]]
++ [#non-referential-id non-referential identifier]

An identifier which does not refer to a value.

A non-referential identifier will usually print as a string containing its name.

Expressions containing non-referential identifiers will not be evaluated, though they may be simplified.

Non-referential identifiers represent "unknowns" or "parameters" when performing algebraic derivations.

[[# id-as-val-note]]
++ [#id-as-val identifier as value]

How to get a value referring to an identifier.

The identifier may be the name of a variable containing a value.  But the value referring to the identifier is distinct from the value in the variable.

One may manipulate a value referring to an identifier even if it is not the name of a variable.

[[# global-var-note]]
++ [#global-var global variable]

How to declare a global variable.

[[# local-var-note]]
++ [#local-var local variable]

How to declare a local variable.

**pari/gp:**

There is {{my}} for declaring a local variable with lexical scope and {{local}} for declaring a variable with dynamic scope.

{{local}} can be used to change the value of a global as seen by any functions which are called while the local scope is in effect.

[[# null-note]]
++ [#null null]

The null literal.

[[# null-test-note]]
++ [#null-test null test]

How to test if a value is null.

[[# undef-var-note]]
++ [#undef-var undefined variable access]

What happens when an undefined variable is used in an expression.

[[# rm-var-binding-note]]
++ [#rm-var-binding remove variable binding]

How to remove a variable.  Subsequent references to the variable will be treated as if the variable were undefined.

[[# cond-expr-note]]
++ [#cond-expr conditional expression]

A conditional expression.
[[# arithmetic-logic-note]]
+ [#arithmetic-logic Arithmetic and Logic]

[[# true-false-note]]
++ [#true-false true and false]

The boolean literals.

[[# falsehoods-note]]
++ [#falsehoods falsehoods]

Values which evaluate to false in a conditional test.

**sympy:**

Note that the logical operators {{Not}}, {{And}} and {{Or}} do not treat empty collections or {{None}} as false.  This is different from the Python logical operators {{not}}, {{and}}, and {{or}}.

**pari/gp:**

A vector or matrix evaluates to false if all components evaluate to false.

[[# logical-op-note]]
++ [#logical-op logical operators]

The Boolean operators.

**sympy:**

In Python, {{&}}, {{|}}, and {{&}} are bit operators.  SymPy has defined {{@@__and__@@}}, {{@@__or__@@}}, and {{@@__invert__@@}} methods to make them Boolean operators for symbols, however.

[[# relational-op-note]]
++ [#relational-op relational operators]

The relational operators.

**sympy:**

The full SymPy names for the relational operators are:

[[code]]
sympy.Equality             # ==
sympy.Unequality           # !=
sympy.GreaterThan          # >=
sympy.LessThan             # <=
sympy.StrictGreaterThan    # >
sympy.StrictLessThan       # <
[[/code]]

The SymPy functions are attatched to the relational operators {{==}}, {{!=}}, for symbols ... using the methods {{@@__eq__@@}}, {{@@__ne__@@}}, {{@@__ge__@@}}, {{@@__le__@@}}, {{@@__gt__@@}}, {{@@__lt__@@}}.  The behavior they provide is similar to the default Python behavior, but when one of the arguments is a SymPy expression, a simplification will be attempted before the comparison is made.

[[# arith-op-note]]
++ [#arith-op arithmetic operators]

The arithmetic operators.

[[# int-div-note]]
++ [#int-div integer division]

How to compute the quotient of two integers.

[[# int-div-zero-note]]
++ [#int-div-zero integer division by zero]

The result of dividing an integer by zero.

[[# float-div-note]]
++ [#float-div float division]

How to perform float division, even if the arguments are integers.

[[# float-div-zero-note]]
++ [#float-div-zero float division by zero]

The result of dividing a float by zero.

[[# power-note]]
++ [#power power]

How to compute exponentiation.

Note that zero to a negative power is equivalent to division by zero, and negative numbers to a fractional power may have multiple complex solutions.

[[# sqrt-note]]
++ [#sqrt sqrt]

The square root function.

For positive arguments the positive square root is returned.

[[# sqrt-negative-one-note]]
++ [#sqrt-negative-one sqrt -1]

How the square root function handles negative arguments.

**mathematica:**

An uppercase {{I}} is used to enter the imaginary unit, but Mathematica displays it as a lowercase {{i}}.

[[# transcendental-func-note]]
++ [#transcendental-func transcendental functions]

The standard transcendental functions such as one might find on a scientific calculator.

The functions are the exponential (not to be confused with exponentiation), natural logarithm, sine, cosine, tangent, arcsine, arccosine, arctangent, and the two argument arctangent.

[[# transcendental-const-note]]
++ [#transcendental-const transcendental constants]

The transcendental constants //pi// and //e//.

The transcendental functions can used to computed to compute the transcendental constants:

[[code]]
pi = acos(-1)
pi = 4 * atan(1)
e = exp(1)
[[/code]]

[[# float-truncation-note]]
++ [#float-truncation float truncation]

Ways to convert a float to a nearby integer.

[[# absolute-val-note]]
++ [#absolute-val absolute value]

How to get the absolute value and signum of a number.

[[# int-overflow-note]]
++ [#int-overflow integer overflow]

What happens when the value of an integer expression cannot be stored in an integer.

The languages in this sheet all support arbitrary length integers so the situation does not happen.

[[# float-overflow-note]]
++ [#float-overflow float overflow]

What happens when the value of a floating point expression cannot be stored in a float.

[[# rational-construction-note]]
++ [#rational-construction rational construction]

How to construct a rational number.

[[# rational-decomposition-note]]
++ [#rational-decomposition rational decomposition]

How to extract the numerator and denominator from a rational number.

[[# decimal-approx-note]]
++ [#decimal-approx decimal approximation]

How to get a decimal approximation of an irrational number or repeating decimal rational.

[[# complex-construction-note]]
++ [#complex-construction complex construction]

How to construct a complex number.

[[# complex-decomposition-note]]
++ [#complex-decomposition complex decomposition]

How to extract the real and imaginary part from a complex number; how to extract the argument and modulus; how to get the complex conjugate.

[[# random-num-note]]
++ [#random-num random number]

How to generate a random integer or a random float.

**pari/gp:**

When the argument of {{random()}} is an integer {{n}}, it generates an integer in the range [[$ \{0, ..., n - 1\} $]].

When the argument is a arbitrary precision float, it generates a value in the range {{[0.0, 1.0]}}.  The precision of the argument determines the precision of the random number.

[[# random-seed-note]]
++ [#random-seed random seed]

How to set or get the random seed.

**mathematica:**

The seed is not set to the same value at start up.

[[# bit-op-note]]
++ [#bit-op bit operators]


[[# binary-octal-hex-literals-note]]
++ [#binary-octal-hex-literals binary, octal, and hex literals]

Binary, octal, and hex integer literals.

**mathematica:**

The notation works for any base from 2 to 36.

[[# radix-note]]
++ [#radix radix]

Convert a number to a representation using a given radix.

[[# to-array-of-digits-note]]
++ [#to-array-of-digits to array of digits]

Convert a number to an array of digits representing the number.

[[# strings-note]]
+ [#strings Strings]

[[# str-literal-note]]
++ [#str-literal string literal]

The syntax for a string literal.

[[# newline-in-str-literal-note]]
++ [#newline-in-str-literal newline in literal]

Are newlines permitted in string literals.

[[# str-literal-esc-note]]
++ [#str-literal-esc literal escapes]

Escape sequences for putting unusual characters in string literals.

[[# str-concat-note]]
++ [#str-concat concatenate]

How to concatenate strings.

[[# translate-case-note]]
++ [#translate-case translate case]

How to convert a string to all lower case letters or all upper case letters.

[[# trim-note]]
++ [#trim trim]

How to remove whitespace from the beginning or the end of string.

[[# num-to-str-note]]
++ [#num-to-str number to string]

How to convert a number to a string.

[[# str-to-num-note]]
++ [#str-to-num string to number]

How to parse a number from a string.

[[# str-join-note]]
++ [#str-join string join]

How to join an array of strings into a single string, possibly separated by a delimiter.

[[# split-note]]
++ [#split split]

How to split a string in to an array of strings.  How to specify the delimiter.

[[# str-subst-note]]
++ [#str-subst substitute]

How to substitute one or all occurrences of substring with another.

[[# str-len-note]]
++ [#str-len length]

How to get the length of a string in characters.

[[# index-substr-note]]
++ [#index-substr index of substring]

How to get the index of the first occurrence of a substring.

[[# extract-substr-note]]
++ [#extract-substr extract substring]

How to get a substring from a string using character indices.

[[# char-literal-note]]
++ [#char-literal character literal]

The syntax for a character literal.

[[# lookup-char-note]]
++ [#lookup-char character lookup]

How to get a character from a string by index.

[[# chr-ord-note]]
++ [#chr-ord chr and ord]

Convert a character code point to a character or a single character string.

Get the character code point for a character or single character string.

[[# delete-char-note]]
++ [#delete-char delete characters]

Delete all occurrences of a set of characters from a string.

[[# arrays-note]]
+ [#arrays Arrays]

[[# array-literal-note]]
++ [#array-literal literal]

The notation for an array literal.

[[# array-size-note]]
++ [#array-size size]

The number of elements in the array.

[[# array-lookup-note]]
++ [#array-lookup lookup]

How to access an array element by its index.

[[# array-update-note]]
++ [#array-update update]

How to change the value stored at an array index.

[[# array-out-of-bounds-note]]
++ [#array-out-of-bounds out-of-bounds behavior]

What happens when an attempt is made to access an element at an out-of-bounds index.

[[# array-element-index-note]]
++ [#array-element-index element index]

How to get the index of an element in an array.

[[# array-slice-note]]
++ [#array-slice slice]

How to extract a subset of the elements.  The indices for the elements must be contiguous.

[[# array-of-integers-as-index-note]]
++ [#array-of-integers-as-index array of integers as index]

[[# array-back-note]]
++ [#array-back manipulate back]

[[# array-front-note]]
++ [#array-front manipulate front]

[[# array-head-note]]
++ [#array-head head]

[[# array-tail-note]]
++ [#array-tail tail]

[[# array-cons-note]]
++ [#array-cons cons]

[[# array-concatenate-note]]
++ [#array-concatenate concatenate]

[[# array-replicate-note]]
++ [#array-replicate replicate]

[[# copy-array-note]]
++ [#copy-array copy]

How to copy an array.  Updating the copy will not alter the original.

[[# iterate-over-array-note]]
++ [#iterate-over-array iterate]

[[# reverse-array-note]]
++ [#reverse-array reverse]

[[# sort-array-note]]
++ [#sort-array sort]

[[# dedupe-array-note]]
++ [#dedupe-array dedupe]

[[# membership-note]]
++ [#membership membership]

How to test whether a value is an element of a list.

[[# intersection-note]]
++ [#intersection intersection]

How to to find the intersection of two lists.

[[# union-note]]
++ [#union union]

How to find the union of two lists.

[[# set-diff-note]]
++ [#set-diff relative complement, symmetric difference]

How to find all elements in one list which are not in another; how to find all elements which are in one of two lists but not both.

[[# map-note]]
++ [#map map]

[[# filter-note]]
++ [#filter filter]

[[# reduce-note]]
++ [#reduce reduce]

[[# universal-existential-test-note]]
++ [#universal-existential-test universal and existential tests]

[[# min-max-elem-note]]
++ [#min-max-elem min and max element]

[[# shuffle-sample-note]]
++ [#shuffle-sample shuffle and sample]

How to shuffle an array. How to extract a random sample from an array without replacement.

[[# flatten-note]]
++ [#flatten flatten]

[[# zip-note]]
++ [#zip zip]

How to interleave two arrays.

[[# cartesian-product-note]]
++ [#cartesian-product cartesian product]

[[# sets-note]]
+ [#sets Sets]

[[# arith-seq-note]]
+ [#arith-seq Arithmetic Sequences]

[[# dictionaries-note]]
+ [#dictionaries Dictionaries]

[[# record-literal]]
++ record literal


[[# record-access]]
++ record member access

[[# functions-note]]
+ [#functions Functions]

[[# definition]]
++ definition

[[# invocation]]
++ invocation

[[# function-value]]
++ function value

[[# execution-control-note]]
+ [#execution-control Execution Control]

[[# if]]
++ if

How to write a branch statement.

**mathematica:**

The 3rd argument (the else clause) of an //If// expression is optional.

[[# while]]
++ while

How to write a conditional loop.

**mathematica:**

//Do// can be used for a finite unconditional loop:

[[code]]
Do[Print[foo], {10}]
[[/code]]

[[# for]]
++ for

How to write a C-style for statement.

[[# break-continue]]
++ break/continue

How to break out of a loop.  How to jump to the next iteration of a loop.

[[# exceptions-note]]
+ [#exceptions Exceptions]

[[# raise-exc-note]]
++ [#raise-exc raise exception]

How to raise an exception.

[[# handle-exc-note]]
++ [#handle-exc handle exception]

How to handle an exception.

[[# uncaught-exc-note]]
++ [#uncaught-exc uncaught exception behavior]

**gap:**

Calling {{Error()}} invokes the GAP debugger, which is similar to a Lisp debugger.  In particular, all the commands available in the GAP REPL are still available.  Variables can be inspected and modified while in the debugger but any changes will be lost when the debugger is quitted.

One uses {{quit;}} or {{^D}} to exit the debugger.  These commands also cause the top-level GAP REPL exit if used while not in a debugger.

If {{Error()}} is invoked while in the GAP debugger, the  debugger will be invoked recursively.   One must use {{quit;}} for each level of debugger recursion to return to the top -level GAP REPL.

Use

[[code]]
brk> Where(4);
[[/code]]

to print the top four functions on the stack when the error occurred.  Use {{DownEnv()}} and {{UpEnv()}} to move down the stackâ€”i.e. from callee to callerâ€”and {{UpEnv()}} to move up the stack.  The commands take the number of levels to move down or up:

[[code]]
brk> DownEnv(2);
brk> UpEnv(2);
[[/code]]

When the debugger is invoked, it will print a message.  It may give the user the option of providing a value with the {{return}} statement so that a computation can be continued:

[[code]]
brk> return 17;
[[/code]]

[[# finally]]
++ finally block

How to write code that executes even if an exception is raised.

[[# streams-note]]
+ [#streams Streams]

[[# files-note]]
+ [#files Files]

[[# directories-note]]
+ [#directories Directories]

[[# libraries-namespaces-note]]
+ [#libraries-namespaces Libraries and Namespaces]

[[# reflection-note]]
+ [#reflection Reflection]

[[# function-documentation]]
++ function documentation

How to get the documentation for a function.

[[# symbolic-expr-note]]
+ [#symbolic-expr Symbolic Expressions]

A defining feature of computer algebra systems is //symbolic expressions//.

In most programming languages, evaluating an expression with an undefined variable results in an error.  Some languages assign a default value to variables so that such expressions can be evaluated.

In a CAS, undefined variables are treated as unknowns; expressions which contains them are //symbolic expressions//.  When evaluating them, if the unknowns cannot be eliminated, the expression cannot be reduced to a numeric value. The expression then evaluates to a possibly simplified or normalized version of itself.  Symbolic expressions are first class values; they can be stored in variables or passed to functions.  An application of symbolic expressions is a function which solves a system of equations.  Without symbolic expressions, it would be awkward for the caller to specify the equations to be solved.

[[# symbolic-expr-literal-note]]
++ [#symbolic-expr-literal literal]

How to create a symbolic expression.

In most CAS systems, any expression an undefined variables is automatically a a symbolic expression.

**sympy:**

In SymPy, unknowns must be declared.  This is a consequence of SymPy being implemented as a library in a language which throws exceptions when undefined variables are encountered.

[[# prevent-simplification-note]]
++ [#prevent-simplification prevent simplification]

[[# symbolic-expr-var-update-note]]
++ [#symbolic-expr-var-update variable update]

Do symbolic expressions "see" changes to the unknown variables they contain.

[[# symbolic-expr-subst-note]]
++ [#symbolic-expr-subst substitute]

[[# piecewise-symbolic-expr-note]]
++ [#piecewise-symbolic-expr piecewise-defined expression]

[[# simplify-note]]
++ [#simplify simplify]

[[# assumption-note]]
++ [#assumption assumption]

[[# assumption-predicates-note]]
++ [#assumption-predicates assumption predicates]

[[# rm-assumption-note]]
++ [#rm-assumption remove assumption]

[[# calculus-note]]
+ [#calculus Calculus]

[[# limit-note]]
++ [#limit limit]

[[# limit-at-infinity-note]]
++ [#limit-at-infinity limit at infinity]

[[# one-sided-limit-note]]
++ [#one-sided-limit one-sided limit]

[[# derivative-note]]
++ [#derivative derivative]

[[# derivative-func-note]]
++ [#derivative-func derivative of a function]

[[# derivative-const-note]]
++ [#derivative-const constants]

[[# higher-order-derivative-note]]
++ [#higher-order-derivative higher order derivative]

[[# mixed-partial-derivative-note]]
++ [#mixed-partial-derivative mixed partial derivative]

[[# div-grad-curl-note]]
++ [#div-grad-curl div, grad, and curl]

[[# antiderivative-note]]
++ [#antiderivative antiderivative]

[[# definite-integral-note]]
++ [#definite-integral definite integral]

[[# improper-integral-note]]
++ [#improper-integral improper integral]

[[# double-integral-note]]
++ [#double-integral double integral]

[[# residue-note]]
++ [#residue residue]

[[# sum-note]]
++ [#sum sum]

[[# series-sum-note]]
++ [#series-sum series sum]

[[# series-expansion-func-note]]
++ [#series-expansion-func series expansion of function]

[[# omitted-order-term-note]]
++ [#omitted-order-term omitted order term]

[[# equations-unknowns-note]]
+ [#eqn Equations and Unknowns]

[[# solve-eqn-note]]
++ [#solve-eqn solve equation]

[[# solve-eqns-note]]
++ [#solve-eqns solve equations]

[[# differential-eqn-note]]
++ [#differential-eqn differential equation]

[[# differential-eqn-boundary-condition-note]]
++ [#differential-eqn-boundary-condition differential equation with boundary condition]

[[# differential-eqns-note]]
++ [#differential-eqns differential equations]

[[# recurrence-eqn-note]]
++ [#recurrence-eqn recurrence equation]

[[# optimization-note]]
+ [#optimization Optimization]

An optimization problem consists of a real-valued function called the //objective function//.

The objective function takes one or more //input variables//.  In the case of a maximization problem, the goal is to find the value for the input variables where the objective function achieves its maximum value.  Similarly for a minimization function one looks for the values for which the objective function achieves its minimum value.

[[# minimize-note]]
++ [#minimize minimize]

How to solve a minimization problem in one variable.

[[# maximize-note]]
++ [#maximize maximize]

How to solve a maximization problem.

We can use a function which solves minimization problems to solve maximization problems by negating the objective function.  The downside is we might forget the minimum value returned is the negation of the maximum value we seek.

[[# optimize-unknown-param-note]]
++ [#optimize-unknown-param objective with unknown parameter]

How to solve an optimization when the objective function contains unknown parameters.

[[# unbounded-behavior-note]]
++ [#unbounded-behavior unbounded behavior]

What happens when attempting to solve an unbounded optimization problem.

[[# optimize-multiple-var-note]]
++ [#optimize-multiple-var multiple variables]

How to solve an optimization problem with more than one input variable.

[[# optimize-constraints-note]]
++ [#optimize-constraints constraints]

How to solve an optimization with constraints on the input variable.  The constrains are represented by inequalities.

[[# infeasible-behavior-note]]
++ [#infeasible-behavior infeasible behavior]

What happens when attempting to solve an optimization problem when the solution set for the constraints is empty.

[[# optimize-int-var-note]]
++ [#optimize-int-var integer variables]

How to solve an optimization problem when the input variables are constrained to linear values.

[[# numerical-opt-note]]
++ [#numerical-opt numerical optimization]

Alternatives for finding optima which use numerical methods instead of exact methods.

The techniques use heuristics for finding global optima which may not work in some cases.

[[# local-opt-near-point-note]]
++ [#local-opt-near-point local optimum near point]

Numerical methods for finding a local optima near a specified point.

[[# vectors-note]]
+ [#vectors Vectors]

[[# vec-literal-note]]
++ [#vec-literal vector literal]

The notation for a vector literal.

[[# const-vec-note]]
++ [#const-vec constant vector]

How to create a vector with components all the same.

[[# vec-coordinate-note]]
++ [#vec-coordinate vector coordinate]

How to get one of the coordinates of a vector.

[[# vec-dim-note]]
++ [#vec-dim vector dimension]

How to get the number of coordinates of a vector.

[[# vec-element-wise-note]]
++ [#vec-element-wise element-wise arithmetic operators]

How to perform an element-wise arithmetic operation on vectors.

[[# vec-length-mismatch-note]]
++ [#vec-length-mismatch vector length mismatch]

What happens when an element-wise arithmetic operation is performed on vectors of different dimension.

[[# vec-scalar-note]]
++ [#vec-scalar scalar multiplication]

How to multiply a scalar with a vector.

[[# vec-dot-note]]
++ [#vec-dot dot product]

How to compute the dot product of two vectors.

[[# vec-cross-note]]
++ [#vec-cross cross product]

How to compute the cross product of two three-dimensional vectors.

[[# vec-norms-note]]
++ [#vec-norms norms]

How to compute the norm of a vector.

[[# matrices-note]]
+ [#matrices Matrices]

[[# matrix-literal-ctor-note]]
++ [#matrix-literal-ctor literal or constructor]

Literal syntax or constructor for creating a matrix.

**mathematica:**

Matrices are represented as lists of lists.  No error is generated if one of the rows contains too many or two few elements.  The //MatrixQ// predicate can be used to test whether a list of lists is matrix: i.e. all of the sublists contain numbers and are of the same length.

Matrices are displayed by Mathematica using list notation.  To see a matrix as it would be displayed in mathematical notation, use the //MatrixForm// function.

[[# matrix-from-seq-note]]
++ [#matrix-from-seq construct from sequence]

[[# const-matrices-note]]
++ [#const-matrices constant matrices]

[[# diagonal-matrices-note]]
++ [#diagonal-matrices diagonal matrices]

[[# matrix-formula-note]]
++ [#matrix-formula matrix by formula]

[[# matrix-dim-note]]
++ [#matrix-dim dimensions]

How to get the number of rows and columns of a matrix.

[[# matrix-elem-lookup-note]]
++ [#matrix-elem-lookup element lookup]

How to access an element of a matrix.

The anguages described here follow the mathematical convention of putting the row index before the column index.

[[# extract-matrix-row-note]]
++ [#extract-matrix-row extract row]

How to access a row.

[[# extract-matrix-col-note]]
++ [#extract-matrix-col extract column]

How to access a column.

[[# extract-submatrix-note]]
++ [#extract-submatrix extract submatrix]

How to access a submatrix.

[[# matrix-scalar-mult-note]]
++ [#matrix-scalar-mult scalar multiplication]

How to multiply a matrix by a scalar.

[[# matrix-elem-wise-op-note]]
++ [#matrix-elem-wise-op element-wise operators]

Operators which act on two identically sized matrices element by element.  Note that element-wise multiplication of two matrices is used less frequently in mathematics than matrix multiplication.

[[# matrix-mult-note]]
++ [#matrix-mult product]

How to multiply matrices.  Matrix multiplication should not be confused with element-wise multiplication of matrices.  Matrix multiplication in non-commutative and only requires that the number of columns of the matrix on the left match the number of rows of the matrix.  Element-wise multiplication, by contrast, is commutative and requires that the dimensions of the two matrices be equal.

[[# matrix-power-note]]
++ [#matrix-power power]

[[# matrix-exponential-note]]
++ [#matrix-exponential exponential]

[[# matrix-log-note]]
++ [#matrix-log log]

[[# kronecker-prod-note]]
++ [#kronecker-prod kronecker product]

The [http://en.wikipedia.org/wiki/Kronecker_product Kronecker product] is a non-commutative operation defined on any two matrices.  If A is m x n and B is p x q, then the Kronecker product is a matrix with dimensions mp x nq.

[[# matrix-norms-note]]
++ [#matrix-norms norms]

How to compute the 1-norm, the 2-norm, the infinity norm, and the frobenius norm.

[[# matrix-transpose-note]]
++ [#matrix-transpose transpose]

[[# matrix-conjugate-transpose-note]]
++ [#matrix-conjugate-transpose conjugate transpose]

[[# matrix-inverse-note]]
++ [#matrix-inverse inverse]

[[# row-echelon-form-note]]
++ [#row-echelon-form row echelon form]

[[# pseudoinverse-note]]
++ [#pseudoinverse pseudoinverse]

[[# determinant-note]]
++ [#determinant determinant]

[[# trace-note]]
++ [#trace trace]

[[# matrix-rank-note]]
++ [#matrix-rank rank]

[[# nullspace-basis-note]]
++ [#nullspace-basis nullspace basis]

[[# eigenval-note]]
++ [#eigenval eigenvalues]

[[# eigenvec-note]]
++ [#eigenvec eigenvectors]

[[# spectral-decomposition-note]]
++ [#spectral-decomposition spectral decomposition]

The spectral decomposition of a square matrix //A// is a factorization //P â‹…D â‹… P^^-1^^// where //P// is invertible and //D// is diagonal.

If a spectral decomposition exists, the matrix //A// is said to be //diagonalizable//.

If an invertiable matrix //P// exists such that //A = P â‹… B â‹… P^^-1^^//, then //A// and //B// are said to be //similar//.

According to the spectral theorem, and spectral decomposition exists when the matrix //A// is //normal//, which means it commutes with its conjugate transpose.

If a matrix //A// is symmetric, then a spectral decomposition //P â‹… D â‹… P^^-1^^// exists, and moreover //P// and //D// are real matrices.

The spectral decomposition is also called the //eigendecomposition//.  The values on the diagonal of //D// are eigenvalues of the original matrix //A//.

[[# lup-decomposition-note]]
++ [#lup-decomposition LUP decomposition]

Factor a square matrix //A// into a lower triangular matrix //L//, an upper triangular matrix //U//, and a permutation matrix //P//.

An LUP factorization of a square matrix always exists.  

[[# qr-decomposition-note]]
++ [#qr-decomposition QR decomposition]

[[# jordan-decomposition-note]]
++ [#jordan-decomposition jordan decomposition]

[[# svd-note]]
++ [#svd singular value decomposition]

[[# polar-decomposition-note]]
++ [#polar-decomposition polar decomposition]

[[# combinatorics-note]]
+ [#combinatorics Combinatorics]

Enumerative combinatorics is the study of the size of finite sets.  The sets are defined by some property, and we seek a formula for the size of the set so defined.

For some simple examples, let //A// and //B// be disjoint sets of size //n// and //m// respectively.  The size of the union //A âˆª B// is //n + m// and the size of the Cartesian product //A Ã— B// is //nm//.  The size of the power set of //A// is //2^^n^^//.

[[# factorial-note]]
++ [#factorial factorial]

The factorial function //n!// is the product of the first //n// positive integers //1 Ã— 2 Ã— ... Ã— n//.

It is also the number of permutations or bijective functions on a set of //n// elements.  It is the number of orderings that can be given to //n// elements.

See the section on permutations below for how to iterate through all //n!// permutations on a set of //n// elements.

As the factorial function grows rapidly with //n//, it is useful to be aware of this approximation:

[[math]]
\ln n! \approx n \ln n - n + \frac{1}{2} \ln 2 \pi n
[[/math]]

[[# binomial-coefficient-note]]
++ [#binomial-coefficient binomial coefficient]

The binomial coefficient can be defined using the factorial function:

[[math]]
{n \choose k} = \frac{n!}{(n-k)! k!}
[[/math]]

The binomial coefficient appears in the binomial theorem:

[[math]]
(x+y)^n = \sum_{k=0}^{n} {n \choose k} x^k y^{n-k}
[[/math]]

The binomial cofficient [[$ { n \choose k } $]] is the number of sets of size //k// which can be drawn from a set of size //n// without replacement.

[[# multinomial-coefficient-note]]
++ [#multinomial-coefficient multinomial coefficient]

[[# int-partitions-note]]
++ [#int-partitions integer partitions]

[[# compositions-note]]
++ [#compositions compositions]

[[# set-partitions-note]]
++ [#set-partitions set partitions]

[[# bell-num-note]]
++ [#set-bell-num bell number]

[[# permutations-k-disjoint-cycles-note]]
++ [#permutations-k-disjoint-cycles permutations with k disjoint cycles]

[[# fibonacci-num-note]]
++ [#fibonacci-num fibonacci number]

[[# bernoulli-num-note]]
++ [#bernoulli-num bernoulli number]

[[# harmonic-num-note]
++ [#harmonic-num harmonic number]

[[# catalan-num-note]]
++ [#catalan-num catalan number]

[[# number-theory-note]]
+ [#number-theory Number Theory]

[[# pseudoprime-test-note]]
++ [#pseudoprime-test pseudoprime test]

A fast primality test.

A number of primality tests exists which give occasional false positives.  The simplest of these use Fermat's Little Theorem, in which for prime //p// and //a// in [[$ \{1, ..., p - 1\} $]]:

[[math]]
a^{p-1} \equiv 1 \;(\text{mod}\; p)
[[/math]]

The test for a candidate prime //p// is to randomly choose several values for //a// in  [[$ \{1, ..., p - 1\} $]] and evaluate

[[math]]
a^{p-1} \;(\text{mod}\; p)
[[/math]]

If any of them are not equivalent to 1, then the test shows that p is not prime.  Unfortunately, there are composite numbers //n//, the [https://oeis.org/A002997 Carmichael numbers], for which

[[math]]
a^{n-1} \equiv 1 \;(\text{mod}\; n)
[[/math]]

holds for all //a// in [[$ \{1, ..., n - 1\} $]].

A stronger test is the Miller-Rabin primality test.  Given a candidate prime //n//, we factor //n - 1// as 2^^r^^ â‹… //d// where //d// is odd.  If //n// is prime, then one of the following must be true:

[[math]]
a^d \equiv 1 \;(\text{mod}\;n)
[[/math]]

[[math]]
a^{2^r \cdot d} \equiv -1 \;(\text{mod}\;n)
[[/math]]


[[# true-prime-test-note]]
++ [#true-prime-test true prime test]

Pseuodoprime tests are known for which there are no known counterexamples, and which are correct for all integers up to a very large size.  Since conclusively showing that a number is prime is a slow operation for larger integers, a true prime test is often not practical.

[[# divisors-note]]
++ [#divisors divisors]

The list of divisors for an integer.

[[# prime-factors-note]]
++ [#prime-factors prime factors]

The list of prime factors for an integer, with their multiplicities.

[[# next-prime-note]]
++ [#next-prime next prime]

The smallest prime number greater than an integer.  Also the greatest prime number smaller than an integer.

[[# nth-prime-note]]
++ [#nth-prime nth prime]

The n-th prime number.

[[# prime-counting-func-note]]
++ [#prime-counting-func prime counting function]

The number of primes less than or equal to a value.

According to the prime number theorem:

[[math]]
\lim_{n \rightarrow \infty} \frac{\pi(n)}{n/\log n} = 1
[[/math]]

[[# divmod-note]]
++ [#divmod divmod]

The quotient and remainder.

If the divisor is positive, then the remainder is non-negative.

[[# gcd-note]]
++ [#gcd greatest common divisor]

The greatest common divisor of a pair of integers.  The divisor is always positive.

Two integers are relatively prime if their greatest common divisor is one.

[[# extended-euclidean-algorithm-note]]
++ [#extended-euclidean-algorithm extended euclidean algorithm]

How to express a greatest common divisor as a linear combination of the integers it is a GCD of.

The functions described return the GCD in addition to the coefficients.

[[# lcm-note]]
++ [#lcm least common multiple]

The least common multiple of a pair of integers.

The LCM can be calculated from the GCD using this formula:

[[math]]
\text{lcm}(m, n) = \frac{|m\cdot n|}{\text{gcd}(m, n)}
[[/math]]

[[# int-residues-note]]
++ [#int-residues integer residues]

The integer residues or integers modulo //n// are the equivalence classes formed by the relation

[[math]]
a\;(\text{mod}\;n) = b\; (\text{mod}\;n)
[[/math]]

An element in of these equivalence classes is called a representative.  We can extend addition and multiplication to the residues by performing integer addition or multiplication on representatives.  This is well-defined in the sense that it does not depend on the representatives chosen.  Addition and multiplication defined this way turn the integer residues into commutative rings with identity.

[[# mult-inverse-note]]
++ [#mult-inverse multiplicative inverse]

How to get the multiplicative inverse for a residue.

If the representative for a residue is relatively prime to the modulus, then the residue has a multiplicative inverse.  For that matter, if the modulus //n// is a prime, then the ring of residues is a field.

Note that we cannot in general find the inverse using a representative, since the only units in the integers are -1 and 1.

By Euler's theorem, we can find a multiplicative inverse by raising it to the power [[$ \phi(n) - 1 $]]:

[[math]]
a^{\phi(n) - 1} \cdot a = a^{\phi(n)} \equiv 1 \;(\text{mod}\;n)
[[/math]]

When //a// doesn't have a multiplicative inverse, then we cannot cancel it from both sides of a congruence.  The following is true, however:

[[math]]
az \equiv az' \;(\text{mod}\; n) \iff z \equiv z' \;\left(\text{mod}\; \frac{n}{\text{gcd}(a, n)}\right)
[[/math]]

[[# chinese-remainder-thm-note]]
++ [#chinese-remainder-thm chinese remainder theorem]

A function which finds a solution to a system of congruences.

The Chinese remainder theorem asserts that there is a solution //x// to the system of  //k//  congruences

[[math]]
x \equiv a_i \;(\text{mod}\;n_i)
[[/math]]

provided that the //n,,i,,// are pairwise relatively prime.  In this case there are an infinite number of solutions, all which are equal modulo [[$ N = n_1 \cdots n_k $]].  For this reason the solution is returned as a residue modulo //N//.

[[# lift-int-residue-note]]
++ [#lift-int-residue lift integer residue]

How to get a representative from the equivalence class of integers modulo //n//.

Typically an integer in [[$ \{0, ..., n - 1\} $]] is chosen.  A centered lift chooses a representative //x// such that [[$ -n/2 < x \leq n/2 $]].

[[# euler-totient-note]]
++ [#euler-totient euler totient]

The Euler totient function is defined for any positive integer //n// as:

[[math]]
\phi(n) = n \prod_{p | n} \frac{p - 1}{p}
[[/math]]

Note that the product is over the primes that divide //n//.

The Euler totient is the number of integers in [[$ \{1, ..., n - 1\} $]] which are relatively prime to //n//.  It is thus the size of the multiplicative group of integers modulo //n//.

The Euler totient appears in Euler's theorem:

[[math]]
a^{\phi(n)} \equiv 1 \;(\text{mod}\;n)
[[/math]]

[[# mult-order-note]]
++ [#mult-order multiplicative order]

The multiplicative order of a residue //a// is the smallest exponent //k// such that

[[math]]
a^k \equiv 1\;(\text{mod}\;n)
[[/math]]

In older literature, it is sometimes said that //a// belongs to the exponent //k// modulo //n//.

[[# primitive-roots-note]]
++ [#primitive-roots primitive roots]

A primitive root is a residue module //n// with multiplicative order //Ï†(n)//.

The multiplicative group is not necessarily cyclic, though it is when //n// is prime.  If it is not cyclic, then there are no primitive roots.

Any primitive root is a generator for the multiplicative group, so it can be used to find the other primitive roots.

[[# discrete-log-note]]
++ [#discrete-log discrete logarithm]

For a residue //x// and a base residue //b//, find a positive integer such that:

[[math]]
b^k \equiv x\;(\text{mod}\; n)
[[/math]]

[[# carmichael-func-note]]
++ [#carmichael-func carmichael function]

The smallest number //k// such that //a^^k^^ â‰¡ 1 (//mod //n)// for all residues //a//.

The Carmichael function Î»(n) is less that or equal to the Euler totient function Ï†(n).  The functions are equal when there are primitive roots modulo //n//.

[[# kronecker-symbol-note]]
++ [#kronecker-symbol kronecker symbol]

A quadratic residue is a non-zero residue //a// which has a square root modulo //p//.  That is, there is //x// such that

[[math]]
x^2 \equiv a \;(\text{mod}\;p)
[[/math]]

If //a// is non-zero and doesn't have a square root, then it is a quadratic non-residue.

The Legendre symbol is used to indicate whether a number is a quadratic residue and is defined as follows:

[[math]]
\left( \frac{a}{p} \right)  = \begin{cases} \;\; 1 \;\;\; a \; \text{is a quadratic residue} \\ \;\; 0 \;\;\; p \mid a \\ -1 \;\;\; a \; \text{is a quadratic nonresidue} \end{cases}
[[/math]]

The Legendre symbol is only defined when //p// is prime, but if //n// is a positive integer with prime factorization

[[math]]
p_1^{\alpha_1} \ldots p_n^{\alpha_n}
[[/math]]

then the Jacobi symbol is defined as

[[math]]
\left( \frac{a}{n} \right) = \left( \frac{a}{p_1} \right)^{\alpha_1} \ldots \left( \frac{a}{p_n} \right)^{\alpha_n}
[[/math]]

[[# moebius-func-note]]
++ [#moebius-func moebius function]

The MÃ¶bius function //Î¼(n)// is 1, -1, or 0 depending upon when //n// is a square-free integer with an even number of prime factors, a square-free integer with an odd number of prime factors, or an integer which is divisible by //p^^2^^// for some prime //p//.

The MÃ¶bius function is multiplicative: when //a// and //b// are relatively prime, //Î¼(a)Î¼(b) = Î¼(ab)//.

//MÃ¶bius inversion formula//

[[# riemann-zeta-func-note]]
++ [#riemann-zeta-func riemann zeta function]

[[# dirichelt-char-note]]
++ [#dirichlet-char dirichlet character]

[[# mangoldt-lambda-note]]
++ [#mangoldt-lambda mangoldt lambda]

[[# polynomials-note]]
+ [#polynomials Polynomials]

[[# trigonometry-note]]
+ [#trigonometry Trigonometry]

[[# special-functions-note]]
+ [#special-functions Special Functions]

[[# permutations-note]]
+ [#permutations Permutations]

A permutation is a bijection on a set of //n// elements.

The notation that Mathematica and GAP use assumes the set the permutation operates on is indexed by {1, .., n}.  The notation that SymPy uses assumes the set is indexed by {0, ..., n-1}.

//Cayley two line notation//

//one line notation//

//cycle notation//

//inversions//

[[# groups-note]]
+ [#groups Groups]

A //group// is a set G and a binary operatorâ€”written here as{{*}}â€”which takes elements of the set as operands and obeys the following axioms:

* //Closure:// For every g and h in G, g * h is also in G.
* //Identity:// There exists e in G such that for all g in G, e * g = g * e = g.
* //Associativity:// For all f, g and h in G, (f * g) * h = f * (g * h).
* //Inverse:// For every g in G, there exists g' in G such that g * g' = g' * g = e.

//Abelian// groups obey an additional axiom:

* //Commutativity:// For all g and h in G, g * h = h * g.

The //order// of a group is the number elements in the set.  The smallest group is the //trivial group//, which contains a single element which is the identity.  It has order 1.

The integers, rationals, real numbers, and complex numbers are Abelian groups under addition; zero is the identity element.  The integers and rationals are countably infinite.  The real numbers and complex numbers are uncountably infinite.

The integers modulo //n// are an Abelian group under addition; zero is the identity number.  The group is finite and has order //n//.

The non-zero rationals, non-zero real numbers, and non-zero complex numbers are Abelian groups under multiplication; one is the identity element.

The set of permutations on a set of //n// elements are non-Abelian groups under composition; the identity permutation which maps each element of the set to itself is the identiy.  The order of the group is //n//!.

++ classical lie groups

The classical Lie groups provide examples of infinite, non-Abelian groups.  In all cases the group operation is matrix multiplication:

||GL(n, â„)||general linear group of degree n||invertible nÃ—n matrices||
||SL(n, â„)||special linear group of degree n||nÃ—n matrices with determinant one||
||O(n, â„)||orthogonal group of degree n||nÃ—n orthogonal matrices; i.e. MM^^T^^ = I||
||SO(n, â„)||special orthogonal group of degree n||nÃ—n orthogonal matrices with determinant one||
||U(n, â„‚)||unitary group of degree n||nÃ—n unitary matrices; i.e. MM* = I||
||SU(n, â„‚)||special unitary group of degree n||nÃ—n unitary matrices with determinant one||

++ group from generators

**gap:**

When a group is created using {{GroupByGenerators}}, the generators returned by {{GeneratorsOfGroup}} will not necessarily be the same as the generators provided to the constructor.

If the group is created using {{GroupWithGenerators}}, then the generators returned by {{GeneratorsOfGroup}} will be the same.

++ named groups

[[# subgroups-note]]
+ [#subgroups Subroups]

A //subgroup// is a subset of a group which is itself a group.

//testing whether a set is a subgroup//

A nontrivial group always has at least two subgroups: the group itself and the trivial subgroup.

++ subgroup from generators

**gap:**

{{ClosureGroup}} finds the smallest group containing a group and a list of elements, some of which might not be in the group which is the first argument.


[[# group-homomorphisms-note]]
+ [#group-homomorphisms Group Homomorphisms]

A //homomorphism// is a function Ï† from (G, *) to (H, *') such that

* Ï†(x * y) = Ï†(x) *' Ï†(y) for all x, y âˆˆ G.

An //isomorphism// is a bijective //homomorphism//.

If an isomorphism exists between two groups, they are said to be //isomorphic//.   Isomorphic groups are in a sense the same, except that the elements and the operation are written differently.  Isomorphism is an equivalence relation.  Group theory is the study of properties which if they hold for one member of an isomorphism equivalence class, they hold for all members of the equivalence class.

[[# actions-note]]
+ [#actions Actions]

A group G is said to //act// on a set A if there is an operation â‹…: G Ã— A â†’ A such that

* gâ‚â‹…(gâ‚‚â‹…a) = (gâ‚*gâ‚‚)â‹…a for all gâ‚, gâ‚‚ âˆˆ G and a âˆˆ A
* eâ‹…a = a for all a âˆˆ A where e is the identity in A

[[# descriptive-statistics-note]]
+ [#descriptive-statistics Descriptive Statistics]

[[# distributions-note]]
+ [#distributions Distributions]

[[# univariate-chart-note]]
+ [#univariate-charts Univariate Charts]

A univariate chart can be used to display a list or array of numerical values.  Univariate data can be displayed in a table with a single column or two columns if each numerical value is given a name.  A multivariate chart, by contrast, is used to display a list or array of //tuples// of numerical values.

In order for a list of numerical values to be meaningfully displayed in a univariate chart, it must be meaningful to perform comparisons (<, >, =) on the values.  Hence the values should have the same unit of measurement.

[[# bar-chart]]
++ vertical bar chart

A chart which represents values with rectangular bars which line up on the bottom.  It is a deceptive practice for the bottom not to represent zero, even if a y-axis with labelled tick marks or grid lines is provided.  A cut in the vertical axis and one of the bars may be desirable if the cut value is a large outlier.  Putting such a cut all of the bars near the bottom is a deceptive practice similar not taking to the base of the bars to be zero, however.

Another bad practice is the 3D bar chart.  In such a chart heights are represented by the height of what appear to be three dimensional blocks.  Such charts impress an undiscriminating audience but make it more difficult to make a visual comparison of the charted quantities.

**mathematica**

[[# horizontal-bar-chart]]
++ horizontal bar chart

A bar chart in which zero is the y-axis and the bars extend to the right.

[[# pie-chart]]
++ pie chart

A bar chart displays values using the areas of circular sectors or equivalently, the lengths of the arcs of those sectors.  A pie chart implies that the values are percentages of a whole.  The viewer is likely to make an assumption about what the whole circle represents.  Thus, using a pie chart to show the revenue of some companies in a line of business could be regarded as deceptive if there are other companies in the same line of business which are left out.  The viewer may mistakenly assume the whole circle represents the total market.

If two values are close in value, people cannot determine visually which of the corresponding sectors in a pie chart is larger without the aid of a protractor.  For this reason many consider bar charts superior to pie charts.

Many software packages make 3D versions of pie charts which communicate no additional information and in fact make it harder to interpret the data.

[[# stem-and-leaf-plot]]
++ stem-and-leaf plot

[[# histogram]]
++ histogram

[[# box-and-whisker-plot]]
++ box-and-whisker plot

[[# univariate-title]]
++ set chart title

[[# bivariate-chart-note]]
+ [#bivariate-charts Bivariate Charts]

[[# stacked-bar-chart]]
++ stacked bar chart

[[# trivariate-chart-note]]
+ [#trivariate-charts Trivariate Charts]

[[# mathematica]]
+ [#top Mathematica]

[http://reference.wolfram.com/mathematica/guide/Mathematica.html Mathematica Documentation Center]
[http://wolframalpha.com WolframAlpha]

[[# maple]]
+ [#top Maple]

http://www.maplesoft.com/support/help/

[[# maxima]]
+ [#top Maxima]

http://maxima.sourceforge.net/docs/manual/maxima.html

[[# sympy]]
+ [#top SymPy]

[http://docs.sympy.org/latest/index.html Welcome to SymPyâ€™s documentation!]